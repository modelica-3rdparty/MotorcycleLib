import "BondLib/BondLib.mo";
import "MultiBondLib/MultiBondLib.mo";
import "WheelsAndTires/WheelsAndTires.mo";


package MotorcycleLib

  package UsersGuide "User's Guide"

    annotation (DocumentationClass=true,Documentation(info="<html>
<h3><font color=\"#008000\" size=5>MotorcycleLib User's Guide</font></h3>
<p>


<p>
This package contains the <b>user's guide</b> to the library, and has the following content:
</p>
<ol>
<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview\">Overview of library</a>
       gives an overview of the library.
<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Versions\">Release Notes</a>
       offers a historic perspective on the development of this library.
</ol>

</html>"));
    package Overview "Overview"
      model ShortIntroduction "Short Introduction"
        annotation (Documentation(info="<html>
<h3><font color=\"#008000\" size=5>Short Introduction</font></h3>
<p>

Among the vehicle models, models of bicycles and motorcycles turn out to be particularly delicate. Whereas
a four-wheeled vehicle remains stable on its own, the same does not hold true for a single-track (two-wheeled)
vehicle. For this reason, the stabilization of such a vehicle, a control issue, requires special attention.
  <!--l. 62--></p><p class=\"indent\">
A key task for a virtual rider is to stabilize the vehicle. To this end, a controller has to generate a suitable steering
  torque based on the feedback of appropriate state variables of the vehicle (e.g. lean angle and lean rate). One major
  problem in controlling single-track vehicles is that the coefficients of the controller are strongly velocity
  dependent. This makes the manual configuration of a controller laborious and error-prone. To overcome this
  problem, an automatic calculation of the controller's coefficients is desired. This calculation requires an
  eigenvalue analysis of the corresponding uncontrolled vehicle which is performed in order to determine the
  self-stabilizing area. The library includes the means for such an analysis and its results can be interpreted by three
  different modes that qualitatively describe the vehicle's motion <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">SMP05</a>]</span>. This enables a convenient
  controller design and hence several control laws that ensure a stable driving behavior are provided. The
  corresponding output represents a state feedback matrix that can be directly applied to ready-made controllers
  which are the core of virtual riders.  To validate the motorcycle's performance, the virtual riders are capable of either tracking a roll angle profile (open-loop method) or a pre-defined path (closed-loop method).The functionality of the virtual riders are illustrated by several examples in the
  library.
  <!--l. 65--></p><p class=\"indent\">


<!--l. 71--></p>
</html>"));
      end ShortIntroduction;

      class BicycleAndMotorcycleDynamics "Bicycle and Motorcycle Dynamics"
        annotation (Documentation(info="<html>
<h3><font color=\"#008000\" size=5>Bicycle and Motorcycle Dynamics</font></h3>
<p>
This chapter is intended to learn the basics about the physical behavior of bicycle and motorcycles (single-track) vehicles. The focus of this chapter lies in the physical effects that cause an uncontrolled version of a bicycle or motorcycle to stay upright. Unlike to four-wheeled vehicles, single-track vehicles are unstable when stationary. Under certain conditions a self-stabilizing area appears when the vehicle moves in forward direction. This area mainly depends on the geometry and mass distribution of the vehicle but as well on gyroscopic effects.
<p>
In the following some important terms and definitions are introduced. Afterwards the gyroscopic effects are described. Finally the importance of trail is discussed.
<p>
<h2><font color=\"#008000\" size=4>Terms and Definitions</font></h2>
Bicycles and motorcycles are described with reference to the terms and definitions depicted in Figure 1.
<p>
<img src=\"../Images/od_termsAndDefinitions.png\">
</p>
<b>Figure 1:</b> Terms and definitions of bicycles and motorcycles
<p>
The wheelbase <b>p</b> is the distance between front wheel- and rear wheel contact point. The trail <b>t</b> is the distance between the front wheel contact point and the point of intersection of the steering axis with the ground line (horizontal axis). The head angle <font face=\"Symbol\">&#945;</font>, also called caster angle, is the inclination between steering axis and ground line. It is also common to define the head angle <font face=\"Symbol\">&#949;</font> as the inclination between steering axis and vertical axis. However, this depends on the convention.
<p>
<hr>
<h2><font color=\"#008000\" size=4>Gyroscopic Forces</font></h2>
From a physical point of view a wheel is nothing else but a gyroscope. In the following the so called gyroscopic effects are demonstrated with reference to Figure 2.
<p>
<img src=\"../Images/od_gyro1.png\">
</p>
<b>Figure 2:</b> Demonstration of gyroscopic effects
<p>

Let us say that the wheel performs a counter-clockwise rotation about the spin axis. This results in an angular momentum L<sub>W</sub> in direction of the spin-axis. The angular momentum of a rigid body is defined as
<p>
    L = I <font face=\"Symbol\">&#215;</font><font face=\"Symbol\">&#969;</font>
<p>
Where I is the moment of inertia and <font face=\"Symbol\">&#969;</font> is the angular velocity.

Let us now apply a counter-clockwise torque (e.g. side wind) about the disturbance axis. This generates an additional angular momentum L<sub>D</sub>. As a consequence of L<sub>D</sub>, the wheel tries to elude an thus performs a counter-clockwise rotation about the reaction axis. This effect is referred to as <i>precession</i> of a gyroscope. The rotation about the reaction axis stops as soon as the spin axis is coincident with the resulting angular momentum L<sub>R</sub>. For a better understanding Figure 3 depicts each step of this sequence.
<p>
<img src=\"../Images/od_gyro2.png\">
</p>
<b>Figure 3:</b> Stepwise demonstration of gyroscopic effects
<p>
This effect is utilized by human bicycle riders. To enter a <i>left turn</i> it is not mandatory to apply a steering torque. As described in Figure 2 it is absolutely sufficient to lean to the left. Due to gyroscopic effects the front wheel of the bicycle steers into the lean. Thus it is possible to enter a turn without touching the handlebar of the bicycle (free-hand). Figure 4 illustrates that this effect works also vice-versa.
<p>
<img src=\"../Images/od_gyro3.png\">
</p>
<b>Figure 4:</b> Demonstration of gyroscopic effects
<p>
In order to enter a left turn one has initially steer to the right. Again, due to gyroscopic forces this causes the vehicle to lean to the left. This effect is usually referred to as countersteering and is utilized by both motorcycle and bicycle riders.

<h2><font color=\"blue\" size=3>Straight Running</font></h2>
Due to geometry and gyroscopic forces Klein and Sommerfeld <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">KS10</a>]</span> found out that a single-track vehicle is self-stabilizing within a certain velocity range. In this range an interaction of the effects mentioned in Figure 2 and 4 take place. Hence, the vehicle performs a tail motion about the longitudinal direction which makes it possible to ride free-hands.
Below this area the steering deflections caused by gyroscopic forces are too small in order to generate enough centrifugal force.
Thus the amplitude of the tail motion increases and the vehicle falls over. Although, these interactions are damped by the trail (refer to section \"The Importance of Trail\") it is still impossible to achieve a stable behavior.
Hence the rider has to apply a steering torque so that the vehicle stays upright.
Above this are, for high speeds, the gyroscopic forces are almost unnoticeable for the rider. That is, the amplitude of the tail motion is close to zero. More precisely, although the vehicle feels stable, after a certain time, it falls over like a capsizing ship. However, by applying a steering torque it is rather simple to stabilize the vehicle. In most cases it is sufficient that one solely touches the handle bars in order to stabilize the vehicle. To this end, in chapter <li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.EigenvalueAnalysis\">Eigenvalue Analysis</a> the straight running capabilities are considered from a more theoretical point of view.

In reality, due to friction the velocity of the vehicle decreases and hence, after a certain time, the vehicle becomes unstable.
For a detailed description regarding gyroscopic effects refer to \\cite{Sommer}.

<h2><font color=\"blue\" size=3>Turning</font></h2>
During a turn a single-track vehicle has a specific lean angle depending on the velocity and the radius of the turn.
For a given velocity and turn radius the corresponding lean angle results in:
<p>
<img src=\"../Images/od_eqLean.png\">
</p>
<hr>
<h2><font color=\"#008000\" size=4>The Importance of Trail</font></h2>
As already mentioned, the trail is significantly involved in the process of stabilizing the vehicle. The stabilizing effect caused by the trail is explained with reference to Figure 5.
<p>
<img src=\"../Images/od_trail.png\">
</p>
<b>Figure 5:</b> Self-stabilizing aligning moment caused by the trail
<p>
Let us say that due to a disturbance (e.g. side wind) the vehicle leans to the left. Thus, the front wheel is as well turned to the left (as depicted in Figure 5). Furthermore, let us say that the vehicle drives with a constant velocity <b>v</b>. Now a cornering force F<sub>lat</sub> appears. This force in combination with the trail generates an aligning moment M<sub>a</sub> that turns the wheel back. That is, the trail has the function of a lever arm. The more trail the longer the lever arm and the more aligning moment is generated. For a detailed description refer to <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Cos06</a>]</span>. .
<p>
Thus, mountain bikes have less trail in order to be more agile. Consequently, the stability decreases. Vehicles with more trail are less agile but more stable. For this reason while riding a vehicle with more trail one has to apply higher steering torques in order to turn.
<p>
Finally, the center of mass and the wheelbase are taken into account. Basically, a high center of mass makes it easier to balance the vehicle than a short one. The wheelbase p is a crucial factor for the time needed in order to reach the desired lean. The higher p, the larger is the lateral distance that the center of mass has to cover and the more time it takes to reach the desired lean angle.

</html>"));
      end BicycleAndMotorcycleDynamics;

      class LibraryStructure "Library Structure"
        annotation (Documentation(info="<html>
<h3><font color=\"#008000\" size=5>Library Structure</font></h3>
<p>
The top layer of the MotorcycleLib is depicted in Figure 1.
<p>
<img src=\"../Images/Library_Structure_Top_Layer.png\" width=\"843\" heigth=\"408\">
</p>
<b>Figure 1:</b> Top Layer of the MotorcycleLib
<p>

<!--l. 35--><p class=\"noindent\">For each single-track vehicle a separate sub-package is provided. The basic bicycle sub-package is
composed of a rigid rider and a movable rider sub-package. Both include the corresponding wrapped
model and a function in order to perform an eigenvalue analysis. The basic motorcycle sub-package
also includes a wrapped model and an eigenvalue analysis function. The structure of the
advanced motorcycle models is much more detailed since each part (e.g.&nbsp;front frame) is
created in a fully object-oriented fashion. It is composed of a <span class=\"cmti-10\">parts</span>, an <span class=\"cmti-10\">aerodynamics </span>and a
<span class=\"cmti-10\">stability analysis </span>sub-package. The parts sub-package includes several different front and
swinging arms, a rear frame, the rider's upper body, a torque engine, the elasto-gap and a
utilities sub-package. Here models of characteristic spring and damper elements are stored.
The aerodynamics sub-package includes a lift force, a drag force and a pitching moment
model.
<!--l. 39--></p><p class=\"noindent\">The controller design sub-package contains pole placement functions in order to design appropriate
controllers. The virtual rider sub-package includes, among others, a virtual rigid rider and a virtual
movable rider sub-package. In both the riders are capable of either tracking a roll angle profile or a
pre-defined trajectory. To this end, several different controllers (e.g.&nbsp;classic, state-space and LQR) are
incorporated into the virtual riders.
<!--l. 42--></p><p class=\"noindent\">The environments sub-package provides tracks for both roll angle tracking and path tracking. In
addition, the models for single-point path tracking are included. The visualization sub-package
provides the graphical information for the environments sub-package. In the ideal wheels sub-package
the visualization of the rolling objects from Dirk Zimmer's <span class=\"cmti-10\">MultiBondLib </span>were modified such that the
appearance is similar to real motorcycle wheels. The utilities sub-package provides some
additional functions and models which are partly used in the library. The purpose of the
examples sub-package is to provide several different examples that demonstrate how to use the
library.
</p>
</html>

"));
      end LibraryStructure;

      package BicycleMotorcycleModeling "Bicycle and Motorcycle Modeling"
        class BasicBicycle "Basic Bicycle"
          annotation (Documentation(info="<html>
<p>
<img height=\"322\" width=\"620\" src=\"../Images/benchmarkBicycles.png\">
</p>

Although bicycles are composed of several different parts, in the simplest case the mechanical model
consists of four rigid bodies. A rear frame including the rigidly attached rider, a front
frame including the front fork and handle bar assembly and two ideal knife-edge wheels
touching the ground at a single contact point. The front- and rear wheels are attached to
the front- and rear frame revolute joints.
<p>
<hr>
<p>

<h3><font color=\"#008000\" size=5>3 Degrees of Freedom Model (Rigid Rider)</font></h3>
The following picture depicts the Basic Model of a Bicycle.

<p>
<img src=\"../Images/BasicMotorcycle.png\">
</p>
<p>
Source: <a href=\"http://audiophile.tam.cornell.edu/~als93/Publications/paper100028KSMEIntJ.pdf\">
Benchmark Results on the Linearized Equations of Motion of an Uncontrolled Bicycle
</p>

<p>
<b>
Model Description
</b>
</p>
<p>
The model consists of four rigid bodies
</p>
<ul>
<li>Rear Frame (including the rigidly attached rider)</li>
<li>Front Frame</li>
<li>Rear Wheel</li>
<li>Front Wheel</li>
</ul>

<p>
The wheels assumed to be thin without slippage in the longitudinal and lateral direction. Furthermore the aerodynamic forces (e.g. lift and drag forces), the frame flexibility and the suspension system (consisting of the telescopic front suspension and the swinging arm) are neglected.
</p>
<p>
The two Frames are connected via an inclined revolute joint (steering axis). Each wheel is connected to the frame via a revolute joint. Since a rigid body in space has 6 d.o.f. one would think that the Basic Motorcycle in total has 24 d.o.f.. But: Each revolute joint inhibits 5 d.o.f. and each contact point between wheel and ground 3 d.o.f.. Hence the total number of d.o.f. is <b>24 - 3<font face=\"Symbol\">&#215;</font>5 - 2<font face=\"Symbol\">&#215;</font>3 = 3</b>.
</p>
<p>
The remainig 3 d.o.f. are:
</p>
<ul>
<li>the Roll angle <FONT FACE=\"Symbol\">&#981;</FONT> of the rear frame</li>
<li>the steering angle <FONT FACE=\"Symbol\">d</FONT></li>
<li><FONT FACE=\"Symbol\">q</FONT><sub>r</sub>, which is the angle of the rear wheel w.r.t. the rear frame</li>
</ul>

The origin (0) of the global co-ordinate system is at the contact point of the rear wheel. The orientation of the rear frame with respect to the global co-ordinate system is clearly defined by means of three angular rotations:
<ul>
<li>a yaw rotation <FONT FACE=\"Symbol\">y</FONT> about the global z-axis </li>
<li>a roll rotation <FONT FACE=\"Symbol\">&#981;</FONT> about the rotated x-axis </li>
<li>a pitch rotation <FONT FACE=\"Symbol\">q</FONT> about the rotated y-axis</li>
</ul>

The geometry of bicycles is described with the following parameters: The wheel base p, the trail t, the head angle <FONT FACE=\"Symbol\">a</FONT> and the radii of the wheels
(refer to Figure <a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.BicycleAndMotorcycleDynamics#x1-8001r1\">1<!--tex4ht:ref: tl --></a>).
<hr> <p>


The model of the basic bicycle used in this documentation was presented by Schwab et al. in 2005
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">SMP05</a>]</span>. This model is based on Whipple's model <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Whi99</a>]</span>. To develop a model within the Dymola
environment, a different co-ordinate system is introduced.
<p>
<img src=\"../Images/coord_sys.png\">
</p>

The parameters of Schwab's benchmark bicycle are listed in the following Table.

<p>
<img src=\"../Images/param_3dof.png\">
</p>
<b>Table 1:</b> Parameters of Schwab's benchmark bicycle
<p>
The parameter values in the Table are different from those described in Schwab's paper since Dymola uses a different co-ordinate system.

<hr>
<h3><font color=\"#008000\" size=5>4 Degrees of Freedom Model (Movable Rider)</font></h3>
This section is intended to extend the former described model by an additional d.o.f. allowing the rider's upper body to lean sideways. Schwab et al. introduced the model of a 4 d.o.f. bicycle in their recently published paper <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">SKM08</a>]</span>. The following Figure shows the extended model of the bicycle. The additional d.o.f. is represented by the angle <FONT FACE=\"Symbol\">g</FONT>. Apart from the additional d.o.f. the definition of the bicycle is equal to the former one.
The 4 d.o.f. model is shown in the following figure:
<p>
<img src=\"../Images/MovableRiderBicycle2.png\">
</p>
<p>
Source: <a href=\"http://audiophile.tam.cornell.edu/~als93/Publications/SchwabKooijmanMeijaard2008.pdf\">
Some recent developments in bicycle dynamics and control
</p>

<p>
<b>
Model Description
</b>
</p>
<p>

The model consists of an additional d.o.f. (rider lean angle <FONT FACE=\"Symbol\">g</FONT>) allowing the rider upper body to lean sideways. Hence, the former rigid rider is split into two parts.
</p>
<ul>
<li>Rear Frame (including the rigidly attached rider lower body)</li>
<li>Rider Upper Body</li>
</ul>
<p>
The rotational d.o.f. is given by means of a revolute joint (hinge). If the hinge is fixed this model yields the same simulation results as the former (3 d.o.f. model) one.
</p>

<p>
The parameters for the benchmark bicycle are in the following Table:
<p>
<img src=\"../Images/param_4dof.png\">
</p>
<b>Table 2:</b> Parameters of Schwab's benchmark bicycle including a movable rider
<p>

</html>"));
        end BasicBicycle;

        class BasicMotorcycle "Basic Motorcycle"
          annotation (Documentation(info="<html>

<h3><font color=\"#008000\" size=4>Definition of Motorcycles</font></h3>
<p>
The motorcycle introduced in this section uses the same definitions as the basic bicycle. As already mentioned it is based on V. Cossalter's model <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Cos06</a>]</span>. In the beginning, the motorcycle has 3 d.o.f.. Later on, with reference to Markus Andres' WheelsAndTires library, the model can be extended by an additional d.o.f. allowing the motorcycle's rear frame to move laterally. That means that lateral slip of the wheels is incorporated.

<p><hr><p>


<h3><font color=\"#008000\" size=4>Geometry of Motorcycles</font></h3>
<p>

The following figure depicts the geometrical definition of V. Cossalter's motorcycle model (<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Cos06</a>]</span>, page 262).

<p>
<img src=\"../Images/geometry_cossalter.png\">
</p>

In contrast to the bicycle model, the position of the steering axis is not given anymore. This position is automatically calculated in the background. Furthermore, a second co-ordinate system is introduced to describe the geometry of the front frame. The origin of this co-ordinate system is the position of the steering axis revolute joint, and the direction of the y<sub>f</sub>-axis is coincident with the steering axis. The reason for the orientation of the front frame co-ordinate system is to avoid products of inertia. The inertia tensor of a body in space is given by:

<p>
<img src=\"../Images/tensor1.png\">
</p>

If the axes of a co-ordinate system are coincident with the principle axes of a symmetrical body, the products of inertia are eliminated and the remaining elements are the principal moments of inertia:

<p>
<img src=\"../Images/tensor2.png\">
</p>
<p><hr><p>
<h3><font color=\"#008000\" size=4>Model of the Basic Motorcycle</font></h3>
<p>

The objective is to feed the model with exactly the same parameters as listed in the following table.
<p>
<img src=\"../Images/param_cossalter.png\">
</p>

Since Dymola uses world (global) co-ordinates to describe the whole geometry of a multi-body system, some parameters of the motorcycle have to be re-calculated in order to develop the model. Furthermore, the calculation of the steering axis co-ordinates should be done automatically in the background. If the front frame center of mass co-ordinates are entered, the re-calculation of the center of mass position with reference to the global co-ordinate system has to be done automatically as well.

<p>
<b>Remark:</b>
<p>
The cornering and cambering stiffness of the front and rear wheel are neglected.
<p><hr><p>
<h3><font color=\"#008000\" size=4>Calculation of the steering axis co-ordinates</font></h3>
<p>
The calculations are done with reference to the following figure:

<p>
<img src=\"../Images/geometry2_cossalter.png\">
</p>

The normal trail a<sub>n</sub> is given by:
<p>
<img src=\"../Images/an.png\">
</p>
The normal rear trail b<sub>n</sub> is
<p>
<img src=\"../Images/bn.png\">
</p>
By introducing the auxiliary variable
<p>
<img src=\"../Images/h.png\">
</p>
the length of the rear frame becomes
<p>
<img src=\"../Images/lrf.png\">
</p>
Hence, the x and y co-ordinates of the steering axis are
<p>
<img src=\"../Images/xst.png\">
</p>
<p><hr><p>

<h3><font color=\"#008000\" size=4>Calculation of the front frame co-ordinates</font></h3>
<p>
The following figure depicts the front frame of the motorcycle with the appropriate co-ordinates to calculate the center of mass.
<p>
<img src=\"../Images/geometry3_cossalter.png\">
</p>

By means of another auxiliary variable
<p>
<img src=\"../Images/dx.png\">
</p>
the length of the line between the steering axis and the intersection between the steering axis and x-axis is given by
<p>
<img src=\"../Images/lff.png\">
</p>

with
<p>
<img src=\"../Images/h2.png\">
</p>
and
<p>
<img src=\"../Images/h3.png\">
</p>
The y-coordinate of the front frame center of mass becomes
<p>
<img src=\"../Images/yf.png\">
</p>
Finally, with two additional auxiliary variables
<p>
<img src=\"../Images/x1x2.png\">
</p>
the x co-ordinate is given by
<p>
<img src=\"../Images/xf.png\">
</p>

Hence, the center of mass
<p>
<img src=\"../Images/CoM.png\">
</p>
<p><hr><p>
<h3><font color=\"#008000\" size=4>Transformation of the front-frame-inertia tensor</font></h3>

The last step in order to develop a model of the motorcycle is the transformation of the front frame inertia tensor. As mentioned before, the principal axes of the front frame are coincident with the co-ordinate system (x<sub>f</sub>,y<sub>f</sub>). To obtain an inertia tensor valid for Dymola's world co-ordinate system, it is rotated about the z-axis. The amount of rotation is equal to the caster angle.
<p>
The inertia tensor of the front frame co-ordinate system is:

<p>
<img src=\"../Images/tensor3.png\">
</p>
The rotation matrix about the z-axis is given by:
<p>
<img src=\"../Images/rot.png\">
</p>
By definition, the inertia tensor valid for Dymola's world co-ordinate system becomes:
<p>
<img src=\"../Images/tensor4.png\">
</p>


</html>"));
        end BasicMotorcycle;

        class AdvancedMotorcycle "Advanced Motorcycle"
          annotation (Documentation(info="<html>

<p>
<img src=\"../Images/advancedMotorcycle_logo1a.png\" width=\"258\" height=\"214\">
</p>

<p>
<img src=\"../Images/advancedMotorcycle_logo3.png\" width=\"319\" height=\"173\">
</p>

<p>
<b>
Sub-package Description
</b>
</p>
<p>
This subpackage is an extention of the Basic Models subpackage. Unlike to the basic models, these models consitst of 11 degrees of freedom (d.o.f.).
</p>

The following picture shows an Advanced Model of a Motorcycle.
<p>
<img src=\"../Images/SL2001_2.png\">
</p>
<p>
Source: <a href=\"http://www3.imperial.ac.uk/controlandpower/research/motorcycles/publications\">
Imperial College London: Control and dynamic analysis of two-wheeled road vehicles
</p>
<p><hr><p>
<h3><font color=\"#008000\" size=5>Definition of the SL2001 Motorcycle</font></h3>
<p>
The basic components of the SL2001 model <span class=\"cite\">[<a href=\"#XSharp2001\">SL01</a>]</span> are (refer to <span class=\"cite\">[<a href=\"#XEvangelou\">Eva03</a>]</span>, page 70/181):
     </p><ul class=\"itemize1\">
     <li class=\"itemize\">a front and a rear frame connected via an inclined revolute joint
     </li>

     <li class=\"itemize\">a front and a rear wheel
     </li>
     <li class=\"itemize\">yaw, roll and lateral translation freedoms of the rear frame
     </li>
     <li class=\"itemize\">one d.o.f. for the steering axis and another one for the twist axis relative to the rear frame


     </li>
     <li class=\"itemize\">non-ideal tire characteristics<span class=\"footnote-mark\"><a href=\"Documentation_MotorcycleLib2.html#fn1x3\"><sup class=\"textsuperscript\">1</sup></a></span><a id=\"x1-54001f1\"></a>
     (e.g. slip)
     </li>
     <li class=\"itemize\">aerodynamic forces
     </li>

     <li class=\"itemize\">an additional d.o.f for the rider?s upper body to lean sideways
     </li>
     <li class=\"itemize\">main frame bounce, pitch and suspension freedoms</li></ul>
<!--l. 628--><p class=\"noindent\">


<p>
The model in the picture above was originally developed by C. KOENEN during his Ph.D. Thesis \"The dynamic behaviour of motorcycles when running straight ahead and when cornering\" at Delft University in 1983. ROBIN S. SHARP and DAVID J.N. LIMEBEER introduced the SL2001 Model which is based on Koenen's Model. They reproduced Koenen's Model as acurately as possible and described it by means of Multi Bodies. <b>The model used in this Library is based on the SL2001 model.</b>
</p>
<p>
<p class=\"noindent\">The model is composed of six parts:
     </p><ol class=\"enumerate1\">

     <li class=\"enumerate\" id=\"x1-55004x1\">a front frame including the front forks and handle bar assembly
     </li>
     <li class=\"enumerate\" id=\"x1-55006x2\">a rear frame including the lower rigid body of the rider
     </li>
     <li class=\"enumerate\" id=\"x1-55008x3\">a swinging arm including the rear suspension
     </li>
     <li class=\"enumerate\" id=\"x1-55010x4\">the rider's upper body
     </li>
     <li class=\"enumerate\" id=\"x1-55012x5\">a rear wheel and
     </li>
     <li class=\"enumerate\" id=\"x1-55014x6\">a front wheel</li></ol>

<!--l. 677--><p class=\"noindent\">The parameter values of the SL2001 motorcycle can be found on:
<a href=\"http://www3.imperial.ac.uk/controlandpower/research/motorcycles/programs\" class=\"url\"><span class=\"cmtt-10\">http://www3.imperial.ac.uk/controlandpower/research/motorcycles/programs</span>
</p>
<p>
The geometry of the motorcycle is described with reference to the following co-ordinates (see table below).

<p>
<img src=\"../Images/coord_SL2001.png\">
</p>
<p><hr><p>
<h3><font color=\"#008000\" size=5>Definition of Sharp's Improved Motorcycle Model</font></h3>
<p>

This model has the same number of bodies and freedoms as the SL2001 model ([Eva03], page 124/181). Among others, some new components such as a telelever front suspension and a chain drive are considered. However, both are not included in the MotorcycleLib. Additionally, a monoshock rear suspension as can be found in modern motorcycle designs was taken into account. In order to develop a model of a monoshock rear suspension, some additional co-ordinates are needed.

<h3><font color=\"#008000\" size=4> Geometry of Sharp's Improved Motorcycle Model</font></h3>
<p>
Sharp's improved motorcycle model is illustrated in the following figure.
<p>
<img src=\"../Images/geom_Sharp_imp.png\">
</p>
The geometry is described with reference to the following co-ordinates (see table below).
<p>
<img src=\"../Images/table_Sharp_imp.png\">
</p>

The parameter values of the improved motorcycle can be found in the paper [SEL04].
<p><hr><p>
<h3><font color=\"#008000\" size=5>Parts and Models</font></h3>
<p>
Each body is designed in an object-oriented fashion (each body is described within its own class).
<p>
<img src=\"../Images/advancedParts.png\" width=\"531\" height=\"290\">
</p>

A  model of a motorcycle is built by simply \"drag and drop\" the components into the diagram window (see the picture below)
</p>

<p>
<img src=\"../Images/advancedMotorcycle.png\">
</p>


</html>"));
        end AdvancedMotorcycle;
        annotation (Documentation(info="<html>
<h3><font color=\"#008000\" size=5>Bicycle and Motorcycle Models</font></h3>

The mathematical modeling of single-track vehicles is a challenging task which covers a wide range of models
of varying complexity. The library provides several single-track vehicle models of different complexity. The
models are composed of multibodies and are based on bond graphs <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">CN05</a>]</span> and multi-bond graphs <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Zim06</a>]</span>. Basically two types of models are provided. Some include out-of-plane
modes only, while others include both in-plane and out-of-plane modes. Roughly speaking, out-of-plane modes are
related to stability and handling of single-track vehicles whereas in-plane modes are dealing with riding comfort.
The wheels used in this library are either provided by
D. Zimmer's <span class=\"ptmri8t-x-x-109\">MultiBondLib </span><span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Zim06</a>]</span> or by M. Andres'

<span class=\"ptmri8t-x-x-109\">WheelsAndTires </span>library <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">And</a>]</span>. The former are ideal, whereas
in the latter models non-ideal effects such as slip can be
considered. For the bicycle, both 3 and 4 degree of
freedom (d.o.f.) out-of-plane mode models are included in the
library. The former are composed of four rigid bodies,
namely a front frame, a rear frame including a rigidly
attached rider and two wheels, connected via revolute
joints. The wheels are infinitesimally thin (knife-edge).
The latter introduce an additional degree of freedom that
allows the rider's upper body to lean sideways. Both
models are based on those introduced by Schwab et al.
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">SMP05</a>]</span> and <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">SKM08</a>]</span>.
<!--l. 79--></p><p class=\"indent\">  The out-of-plane mode motorcycle model is a 4 d.o.f. model that is based on a model established by V. Cossalter <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Cos06</a>]</span>. Basically, V. Cossalter's model is the
same as the one introduced by R. S. Sharp in 1971 <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Sha71</a>]</span>.
This model allows a lateral displacement of the rear frame
since the wheels are not ideal anymore. Due to the fact
that the wheels of D. Zimmer's <span class=\"ptmri8t-x-x-109\">MultiBondLib </span><span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Zim06</a>]</span> are
ideal, the model is reduced to 3 d.o.f.. Later, with
reference to M. Andres' <span class=\"ptmri8t-x-x-109\">WheelsAndTires </span>library <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">And</a>]</span>, it is
possible to consider non-ideal effects of wheels and tires
and thus simulate the lateral displacement of the rear    wheel caused by tire slip. The animation of a 3 d.o.f.
  motorcycle is depicted in Figure&nbsp;<a href=\"#x1-30011\">1<!--tex4ht:ref: animMoto --></a>. </p><hr class=\"figure\"><div class=\"figure\">



<a id=\"x1-30011\"></a>


<div class=\"center\">
<!--l. 81--><p class=\"noindent\">

<!--l. 82--></p><p class=\"noindent\"><img src=\"../Images/motorcycle_3dof_animation.png\" alt=\"PIC\" width=\"207\" height=\"144\"></p></div>
<br> <div class=\"caption\"><span class=\"id\">Figure&nbsp;1: </span><span class=\"content\">Animation of a 3 d.o.f. motorcycle model</span></div><!--tex4ht:label?: x1-30011 -->


<!--l. 86--><p class=\"indent\">  </p></div><hr class=\"endfigure\">
<!--l. 87--><p class=\"indent\">  To incorporate in-plane modes two even more complex
models are included in the library. The first model was
originally developed by C. Koenen during his Ph.D.
Thesis <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Koe83</a>]</span>. R. S. Sharp and D. J. N. Limebeer introduced
the SL2001 model which is based on Koenen's model

<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">SL01</a>]</span>. They reproduced Koenen's model as accurately as
possible and described it by means of multibodies. The
model developed in this library is based on the SL2001
motorcycle. The second model is based on an improved
more state-of-the-art version of the former developed by
R. Sharp, S. Evangelou and D. J. N. Limebeer <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">SEL04</a>]</span>.
Another detailed description of these models can be found
in S. Evangelou's Ph.D. Thesis <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Eva03</a>]</span>. Such models are
composed of a front frame including the front forks and
handle bar assembly, a rear frame including the lower rigid
body of the rider, a swinging arm including the rear
suspensions, the rider's upper body, a front and a rear
wheel. Furthermore several additional freedoms due to
twist frame flexibility at the steering head, suspensions,
non-ideal tire models and aerodynamics are taken into
account. The animation of the SL2001 model is depicted
in Figure&nbsp;<a href=\"#x1-30022\">2<!--tex4ht:ref: animMoto2 --></a>. </p><hr class=\"figure\"><div class=\"figure\">


<a id=\"x1-30022\"></a>



<div class=\"center\">
<!--l. 90--><p class=\"noindent\">

<!--l. 91--></p><p class=\"noindent\"><img src=\"../Images/advancedMotorcycle_logo3.png\" alt=\"PIC\" width=\"311\" height=\"172\"></p></div>
<br> <div class=\"caption\"><span class=\"id\">Figure&nbsp;2:   </span><span class=\"content\">Animation   of   the   SL2001   motorcycle
model</span></div><!--tex4ht:label?: x1-30022 -->


<!--l. 95--><p class=\"indent\">  </p></div><hr class=\"endfigure\">
<!--l. 96--><p class=\"indent\">  In contrast to the former models each body is created in
a fully object-oriented fashion. As with the out-of-plane
models these models only include all degrees of freedom
in combination with M. Andres <span class=\"ptmri8t-x-x-109\">WheelsAndTires </span>library.
Without this library several freedoms are inhibited.

<!--l. 99--></p><p class=\"indent\">  It is important to keep in mind that all vehicles in combination with ideal wheels include
so-called holonomic constraints. Such constraints are
based on location and in case of single-track vehicles
prevent them from sinking into the ground.
  </p>
</html>"));
      end BicycleMotorcycleModeling;

      class EigenvalueAnalysis "Eigenvalue Analysis"
        annotation (Documentation(info="<html>
<h3><font color=\"#008000\" size=5>Eigenvalue Analysis</font></h3>

Due to geometry and gyroscopic forces Klein and Sommerfeld <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">KS10</a>]</span> found out that a single-track vehicle is self-stabilizing within a certain velocity range. That is, the vehicle performs a tail motion in the longitudinal direction which makes it possible to ride free-hands. Below this range the steering deflections caused by gyroscopic forces are too small in order to generate enough centrifugal force. Thus the amplitude of the tail motion increases and the vehicle falls over. Although, these interactions are damped by the trail it is still impossible to achieve stable behavior. Hence the rider has to apply a steering torque to ensure that the vehicle stays upright. Above this range, for high speeds, the gyroscopic forces are almost unnoticeable for the rider. That is, the amplitude of the tail motion is close to zero. More precisely, although the vehicle feels stable, after a certain time, it falls over like a capsizing ship. However, by applying a steering torque it is rather simple to stabilize the vehicle. In most cases it is sufficient that one solely touches the handle bars in order to compensate for the instabilities.

An eigenvalue analysis is performed in order to determine the self-stabilizing range of an uncontrolled bicycle or motorcycle. For this purpose the state variables of the vehicle that are responsible for stability are of interest. These are the steer angle <FONT FACE=\"Symbol\">d</FONT>, the lean angle <FONT FACE=\"Symbol\">&#981;</FONT>, and their derivatives.

<p>
<img src=\"../Images/ev.png\">
</p>

In case of vehicles with an additional d.o.f. allowing the rider's upper body to lean sideways, the state variables <FONT FACE=\"Symbol\">g</FONT> and its derivative are also taken into account, where <FONT FACE=\"Symbol\">g</FONT> is the lean angle of the rider's upper body relative to the rear frame and its derivative the corresponding lean rate. All the other state variables (e.g. lateral- and longitudinal position) of the state vector have no influence on the stability of single-track vehicles.
<p>
Compared to the 3 and 4 d.o.f. basic bicycle, and the basic motorcycle, the SL2001
motorcycle (advanced motorcycle) includes much more state variables which are responsible for the stability.
In total, the vehicle includes 18 state variables, whereas 15 have an influence on the
stability. In addition to the state variables mentioned so far, the following have to be
taken into account: The states of the front frame's revolute joint which is connected to
the front wheel, the states of the twist axis' revolute joint, the states of the swinging
arm's revolute joint which is connected to the rear wheel, the states of the swinging
arm's actuated prismatic joint and the angular rotation about the z-axis of the rear
wheel.
<p>

Now, the eigenvalues (one for each state variable) are calculated as a function of the vehicle's forward velocity <FONT FACE=\"Symbol\">l</FONT> = f(v) (e.g. v = 10ms<sup>-1</sup> to v = 50ms<sup>-1</sup>). Thus, for each specific velocity the model is linearized. The result of such an analysis are three different velocity ranges at which the motion of the vehicle changes qualitatively. Figure 3 depicts a typical result of such an analysis.

<p>
<img src=\"../Images/ev_moto.png\">
</p>

The figure above depicts the result of the eigenvalue analysis for a 3 d.o.f. motorcycle model. The stable region is determined by eigenvalues with a negative real part. Here it is from v<sub>w</sub> =6.1ms<sup>-1</sup> to v<sub>c</sub>=10.3ms<sup>-1</sup>

The first velocity range is below the stable region, the second one is within, and the third one above the stable region. Positive eigenvalues, or more precisely eigenvalues with a positive real part, correspond to unstable behavior whereas eigenvalues with a negative real part correspond to stable behavior. Eigenvalues including an imaginary part emphasize that the system is oscillating whereas eigenvalues without an imaginary part are non-oscillating. A stable region exists, if and only if all real parts of the eigenvalues are negative. In the following, the modes of single-track vehicles are explained with reference to the figure above.

<h3><font color=\"blue\" size=4>Weave Mode</font></h3>
The weave mode begins at zero velocity. This mode is non-oscillating in the beginning and after a certain value passes over into an oscillating motion. The non-oscillating motion at very low speeds states that the bicycle is too slow to perform a tail motion and thus falls over like an uncontrolled inverted pendulum. As soon as it passes a certain value of approximately v<sub>w</sub> = 0.12ms<sup>-1</sup> the real parts of the eigenvalues merge and two conjugate complex eigenvalues appear. Hence, a tail motion in the longitudinal direction emerges. This motion is still unstable but becomes stable as soon as the real parts of the eigenvalues cross zero. This happens at a velocity of about v<sub>w</sub> = 6.1ms<sup>-1</sup>. For all velocities greater than vw this motion is stable.

<h3><font color=\"blue\" size=4>Capsize Mode</font></h3>
The capsize mode is a non-oscillating motion that corresponds to a real eigenvalue dominated by the lean. As soon as the bicycle speed passes the upper limit of the stable region of about v<sub>c</sub> = 10.3ms<sup>-1</sup>, it falls over like a capsizing ship. However, above the stable region the bicycle is easy to stabilize although the real eigenvalue is positive. In the paper [12] of Sharp et al. this motion is called mildly unstable as long as the absolute value of the eigenvalues is smaller than 2s<sup>-1</sup>.

<h3><font color=\"blue\" size=4>Castering Mode</font></h3>
The castering mode is a non-oscillating mode that corresponds to a real negative eigenvalue dominated by the steer. In this mode the front wheel has the tendency to turn towards the direction of the traveling vehicle.
<p><hr><p>
<h3><font color=\"#008000\" size=5>A Function For the Eigenvalue Analysis</font></h3>
To be able to perform an eigenvalue analysis, specific functions for each vehicle model are provided. The code of such a function can be found in <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.BasicMotorcycle.CalculateEigenvaluesMotorcycle\">BasicMotorcycle.CalculateEigenvaluesMotorcycle</a>]</span>.
After executing the function, the following window appears.
<p>
<img src=\"../Images/ev_function.png\">
</p>

The first parameter are inputs. Firstly, the user has to enter the model name. This can be done by simply drag and drop the model into the input field. The input variable name which
represents the sweep velocity is set to \"vs\" by default. This parameter is defined in the vehicle model in order to sweep the velocity. In the next two input fields, the start and end velocities are set. The last input value states how many steps are performed. The more steps are performed, the more accurate are the results. The next parameter is the state vector. It includes the necessary states for the analysis.
<p>
The function
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.Examples.BasicMotorcycle.StabilityAnalysis\">Examples.BasicMotorcycle.StabilityAnalysis</a>]</span>.
exploits (executes)
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.BasicMotorcycle.CalculateEigenvaluesMotorcycle\">Examples.BasicMotorcycle.CalculateEigenvaluesMotorcycle</a>]</span>.
</p>

<p>
<b>Remark</b>
<p>
If the states of the vehicle are not known the function <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.Utilities.getStates\">MotorcycleLib.Utilities.getStates</a>]</span> has to be executed first.


</html>

"));
      end EigenvalueAnalysis;

      package ControllerDesign "Controller Design"
        model Intro "Short Introduction to State Space"
          annotation (Documentation(info="<html>
In general, the state-space representation of a linear system is given by:

<p>
<img src=\"../Images/state_eq.png\">
</p>

where x is a (nx1) state vector, y is a (mx1) output vector, A is referred to as system matrix with a dimension of (nxn), B is a (nxr) input matrix, C is a (mxn)  output matrix and D the \"feedthrough\" matrix with a dimension of (mxr). Usually D is set to zero, except if the output directly depends on the input. The state vector x at time t = 0 includes the initial conditions, sometimes referred to as initial disturbances x<sub>0</sub>.
<p>
The block diagram of a system described in state-space is illustrated in the following figure:
<p>
<img src=\"../Images/ss_bd.png\">
</p>

One major advantage of state-space control compared to classic control is that each state of the system can be controlled. In order to control the system, the state vector x is fed back. The state feedback control law for a linear time-invariant system is given by:
<p>
<img src=\"../Images/ufx.png\">
</p>

By substituting u of equation 1 with equation 3 the state equation results in
<p>
<img src=\"../Images/xdot.png\">
</p>

The block diagram of the equation above is shown in the figure below.
<p>
<img src=\"../Images/ss_fb.png\">
</p>

The elements of the feedback matrix F have to be chosen in such a way that the initial disturbances x<sub>0</sub>(t) for t towards infinity converge towards zero
<p>
<img src=\"../Images/inf.png\">
</p>
and the system becomes stable.
<p>
The main task of the state feedback control is to find appropriate coefficients for the feedback matrix F in order to achieve the desired dynamical behavior of the system. One method that fulfills all the requirements is the so-called pole placement technique (refer to <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Föl08</a>]</span>). The following figure illustrates the graphical interpretation.
<p>
<img src=\"../Images/pp.png\">
</p>


</html>"));
        end Intro;

        model StateSpaceControllerDesign
          "State-Space Controller Design Based on a Preceding Eigenvalue Analysis"

          annotation (Documentation(info="<html>

The library includes several different stabilizing controllers. Although classic controllers and linear quadratic regulators (LQR) are included in the library, the focus lies in state-space controller design via the pole placement technique. In the simplest case the lean angle and the lean rate of the vehicle are fed back in order to generate an appropriate steering torque. However, since a physical interpretation of the eigenvalues is not possible an alternative (additional) approach is introduced in the library.
This approach is based on a preceding eigenvalue analysis. That is, exactly the same state variables, namely the steer angle <FONT FACE=\"Symbol\">d</FONT>, the lean angle <FONT FACE=\"Symbol\">&#981;</FONT>, and their derivatives, are used to design the controller (as shown in the following figure).
<p><hr><p>
<h3><font color=\"#008000\" size=5>State-Space Controller Based on a Preceding Eigenvalue Analysis</font></h3>

<p>
<img src=\"../Images/ss_ev.png\">
</p>

Of course if the upper body of the rider is movable, the states <FONT FACE=\"Symbol\">d</FONT> and its derivative are taken into account as well. Thus, a physical interpretation of the poles is available.
<p>
As already mentioned the eigenvalues are a function of the velocity, i.e. the trajectory of each eigenvalue is thus perfectly known. With this knowledge the velocity dependent coefficients of the state feedback matrix can be conveniently calculated. To this end, three different approaches were developed.
<p>
The controller design can be carried out for either one specific velocity (e.g. 5ms<sup>-1</sup>) or a specific velocity range (e.g. 5ms<sup>-1</sup> to 50ms<sup>-1</sup>). In the following both methods are introduced.
<p><hr><p>
<h3><font color=\"#008000\" size=5>Controller Design for a specific Velocity</font></h3>
By means of a preceding eigenvalue analysis, the controller is designed in a much more physical fashion. In the following approach, the controller design is carried out for a specific velocity.
<p>
The state feedback control law is given by:
<p>
<img src=\"../Images/cl_ev.png\">
</p>

Now, all poles are shifted by the same amount into the left-half plane. Therefore an offset is defined. Let us say that the poles of the motorcycle for an arbitrary velocity are
poles = [p1; p2; p3; p4]. Now, all poles are shifted by means of an offset d. Thus, the desired
pole locations are: pdesired = [p1 - d; p2 - d; p3 - d; p4 - d]. The following figure depicts the graphical
interpretation.
<p>
<img src=\"../Images/pp_ss.png\">
</p>

Now, a Modelica pole placement function based on Ackermann's formula is introduced.
<p>
<img src=\"../Images/ackermann.png\">
</p>
where
<p>
<img src=\"../Images/tn.png\">
</p>
is a vector of length n which is used to store the last row of the inverted controllability matrix
<p>
<img src=\"../Images/sn.png\">
</p>
and
<p>
<img src=\"../Images/phi.png\">
</p>
is the characteristic polynomial of the system matrix A. The coefficients am are chosen in such a way that <FONT FACE=\"Symbol\">l</FONT><sub>1</sub>, <FONT FACE=\"Symbol\">l</FONT><sub>2</sub>,..., <FONT FACE=\"Symbol\">l</FONT><sub>n</sub> are the eigenvalues (poles) of the polynomial
<p>
<img src=\"../Images/char_pol.png\">
</p>
The code of the function can be found in
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.ControllerDesign.RigidRider.place\">ControllerDesign.RigidRider.place</a>]</span>.
<p>
By executing the Modelica function place the following window appears.
<p>
<img src=\"../Images/place_window.png\">
</p>
In order to calculate the coefficients of the state feedback matrix, one has to enter the velocity
of the motorcycle, the offset and the appropriate states.
<p>
The model of the controller can be found in: <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StateSpace_LeanSteer\">VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StateSpace_LeanSteer</a>]</span>.
<p>

<p>
<b>Remark</b>
<p>
Since the function Modelica.Math.Matrices.eigenValues() orders the Eigenvalues not always in the same way, it is necessary to re-order the Eigenvalues such that the order of the closed-loop poles corresponds to the order of the vehicles poles. Otherwise the coefficients of the feedback matrix are wrong

<p><hr><p>
<h3><font color=\"#008000\" size=5>Controller Design for a specific Velocity Range</font></h3>
<h3><font color=\"blue\" size=4>1<sup>st</sup> Approach</font></h3>
In the first approach all eigenvalues (poles) of the system are simply shifted towards the left-half plane (see figure above) by the same value (offset). A typical result for the controlled version of the 3 d.o.f. motorcycle is illustrated in the following figure.

<p>
<img src=\"../Images/ss_ev_res1.png\">
</p>
<b>Figure:</b> Result of the controller design for a velocity range from 4ms<sup>-1</sup> to 12ms<sup>-1</sup>, where the offset is d = 5.
<p>

The code of the function can be found in
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.ControllerDesign.RigidRider.placeRange_offset\">ControllerDesign.RigidRider.placeRange_offset</a>]</span>.

<h3><font color=\"blue\" size=4>2<sup>nd</sup> Approach</font></h3>
Two improved control laws have been established. Both are based on solely shifting those poles towards the left-half plane that are unstable. Within the stable region the motorcycle needs no control and thus no offset. Above the stable region (for velocities greater than vc) the behavior of the bicycle is dominated by the capsize mode. Hence, it is absolutely sufficient to shift just this pole towards the left-half plane and leave all other poles unchanged. Below the stable region, for velocities lower than vw, the instability of the motorcycle is caused by the weave mode (see Figure above). To ensure stable behavior the two real parts of the conjugate complex poles have to be shifted towards the left-half plane. Now, a control law for the regions below and above the stable region is set up:
<p>
<img src=\"../Images/cl1.png\">
</p>
<p>
<img src=\"../Images/ss_ev2.png\">
</p>
<b>Figure:</b> Controller design with reference to a preceding eigenvalue analysis. The stable region is left unchanged - below v<sub>w</sub>, the weave mode eigenvalues are modified - above v<sub>c</sub>, the capsize mode eigenvalue is modified.
<p>

The next figure shows the result of the individual controller design.
<p>
<img src=\"../Images/ss_ev_res2.png\">
</p>
<b>Figure:</b>Result of the individual controller design for a velocity range from 4ms<sup>-1</sup> to 12ms<sup>-1</sup>, where v<sub>w</sub> = 6.1ms<sup>-1</sup>, v<sub>c</sub> = 10.3ms<sup>-1</sup>, d<sub>w</sub> = 1.5 and d<sub>c</sub> = 0.1.
<p>

The code of the function can be found in <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.ControllerDesign.RigidRider.placeRange_individual_vw_vc\">ControllerDesign.RigidRider.placeRange_individual_vw_vc</a>]</span>.

<h3><font color=\"blue\" size=4>3<sup>rd</sup> Approach</font></h3>
Although the results of the individual controller are rather good, there is still potential for improvements. For velocities equal to vw or vc the eigenvalues that are responsible for stability are close or equal to zero. To be more precise, for such velocities the stability of the motorcycle is critical since a real part equal to zero has no damping. Somewhere in the stable region the weave and the capsize mode have an intersection point v<sub>i</sub>. Instead of the previous control law, the improved control law results in:
<p>
<img src=\"../Images/cl2.png\">
</p>

A graphical interpretation of the control law is illustrated in the figure below.
<p>
<img src=\"../Images/ss_ev3.png\">
</p>
<b>Figure:</b>Controller design with reference to a preceding eigenvalue analysis. Below v<sub>i</sub>, the weave mode eigenvalues are modified - Above v<sub>i</sub>, the capsize mode eigenvalue is modified. In addition both the weave and the capsize eigenvalues can be shifted by a value equal to d<sub>0</sub>.
<p>
The next figure depicts the result of the improved individual controller design.
<p>
<img src=\"../Images/ss_ev_res3.png\">
</p>
<b>Figure:</b>Result of the improved individual controller design for a velocity range from 4ms<sup>-1</sup> to 12ms<sup>-1</sup>, where vi = 6.9ms<sup>-1</sup>, d<sub>w</sub> = 0.75, d<sub>c</sub> = 0.1 and d0 = 0
<p>
The code of the function can be found in <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.ControllerDesign.RigidRider.placeRange_individual_vi\">ControllerDesign.RigidRider.placeRange_individual_vi</a>]</span>.
<p>
The Modelica model for the pole placement functions valid for a specific velocity range can be found in: <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StabilityController_table\">VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StabilityController_table</a>]</span>.
<p><hr><p>
<h3><font color=\"#008000\" size=5>Results</font></h3>
The results are several pole placement functions that automatically calculate the controller coefficients, i.e. the elements of the feedback matrix. The corresponding output represents a state feedback matrix that can be directly applied to ready-made controllers. The algorithm of the functions is based on Ackermann's formula. Unfortunately, it is just valid for single-input, single-output (SISO) systems. In order to design a multiple-input, multiple-output (MIMO) controller, e.g. for vehicles including rider's capable of leaning sideways, a MATLAB m-file based on the place()-function is provided.

Finally, the coefficients of the state feedback matrix are automatically fed into a ready-made controller which is incorporated into a virtual rider. With respect to the virtual rider the vehicle's performance can now be evaluated.
</html>"));
        equation

        end StateSpaceControllerDesign;

        model LQR_Design "Linear Quadratic Regulator (LQR) Design"
          annotation (Documentation(info="<html>
<h3><font color=\"#008000\" size=5>LQR Design</font></h3>
Another possibility to design a controller is to use a linear quadratic regulator (LQR). Until now, each controller was designed in such a way that the closed-loop system becomes stable. In order to fulfill this requirement the poles of the closed-loop system were placed in the left-half plane. This was done using several different approaches. However, the basic idea is always the same: The more negative the location of the poles, the faster the system and the more control energy (e.g. steering torque) is needed. So far, the control energy (cost) of the system was never taken into account, i.e. it was implicitly assumed that the control energy does not play an important role. Unfortunately, this is everything else but close to reality (e.g. a steering torque of 10kNm can never be applied by a human).
To take the control energy into account right from the start of the controller design, the optimal control theory provides several methods in order to minimize it. For linear time-invariant (LTI) systems the LQR method is the most suitable one.

<a id=\"x1-940005.4\"></a>Basic Idea</h5>
<!--l. 458--><p class=\"noindent\">Again, the plant is considered to be a linear system described by means of a state-space representation. The
feedback matrix F has to be chosen in such a way that:
     </p><ol class=\"enumerate1\">

     <li class=\"enumerate\" id=\"x1-94002x1\">the closed-loop system is not too slow and not too much oscillating
     </li>
     <li class=\"enumerate\" id=\"x1-94004x2\">the control energy is minimized</li></ol>

<p>
The quality criterion (cost functional) in order to fulfill (1) takes the following form:
<p>
<img src=\"../Images/J1.png\">
</p>
where x is the state vector and Q is a symmetric, positive semidefinite matrix.
<p>
Analog to (1) the quality criterion of (2) is given by:
<p>
<img src=\"../Images/J2.png\">
</p>
where u is the input vector and R is a symmetric, positive definite matrix .
<p>
In order to fulfill both quality criteria the quations above are combined. The resulting cost functional is given by:
<p>
<img src=\"../Images/J3.png\">
</p>
where Q and R are weighting matrices.
<p>
To minimize the cost functional J, the control law u = -F x is modified. F is substituted by
<p>
<img src=\"../Images/F.png\">
</p>
where P is found by solving the following equation
<p>
<img src=\"../Images/riccati.png\">
</p>
Which is referred to as continuous time algebraic riccati equation.
<p>

For a detailed description of the equations above, refer to Föllinger <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Föl08</a>]</span> or Lunze <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Lun06</a>]</span>. To this end it is not necessary to understand the theory in detail since the algorithm, in order to find the optimal feedback matrix, is provided by many programs (e.g. MATLAB, Scilab, Octave).
<p>
Due to the absence of a Modelica LQR function, this problem is solved with the lqr()-function provided by MATLAB.
<p>
The main task is to find appropriate weighting factors for Q and R to fulfill (1) and (2). In order to do that, some design goals have to be specified. According to that goals, Q and R are modified as long as the results are such that the requirements are fulfilled. This is a laborious and time consuming task. Nevertheless, in the following it is carried out for the basic bicycle model.
<p><hr><p>
<h3><font color=\"#008000\" size=5>Demonstrative Example - Basic Bicycle</font></h3>
In a first approach the lean angle is minimized. Since the bicycle has just one input, namely the steering torqu u = T<sub>steering</sub> applied by the rider, the R matrix is reduced to a scalar. In the simplest case R = 1. The state vector
<p>
<img src=\"../Images/ev.png\">
</p>

has a size of (4 x 1) and hence Q is a (4 x 4) matrix. Now, the weightings of Q have to be chosen such that  <FONT FACE=\"Symbol\">&#981;</FONT> is minimized. Thus Q results in:
<p>
<img src=\"../Images/Q1.png\">
</p>

The value of R which is equal to one, states that the control energy has the same weighting as the lean angle. More precisely, the lean angle is minimized by the same amount as the steering torque.
<p>
In the following, a controller design for a bicycle velocity from v = 1ms<sup>-1</sup> to 10ms<sup>-1</sup> is carried out. In order to calculate the coefficients, the basic bicycle model has to be linearized for each velocity. The corresponding MATLAB code is shown below:
<p>
<img src=\"../Images/lqr_mfile.png\">
</p>

The results of the simulation are shown in the following figure.
<p>
<img src=\"../Images/lqr_res.png\">
</p>
<b>Figure</b>LQR design - minimization of the lean angle: Left plot - eigenvalue analysis for the uncontrolled version of the bicycle; Right plot - eigenvalues of the controlled bicycle.
<p>
This approach was also carried out by Schwab et al. in their recently published paper <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">SKM08</a>]</span> on page 4/8. Fortunately the results are the same.
<p>
The model of an LQR controller can be found in:
 <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.LQR_LeanSteer\">VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.LQR_LeanSteer</a>]</span>.


</html>"));
        end LQR_Design;
      end ControllerDesign;

      class VirtualRider "Virtual Rider"
        annotation (Documentation(info="<html>

<h3><font color=\"#008000\" size=5>Roll Angle Tracking</font></h3>
For virtual riders capable of tracking a roll angle profile, several test tracks are provided. So far, due to appropriate feedback matrix coefficients, the set-values were automatically set to zero. Instead of these set-values the roll angle profile (e.g. of a standard 90°-curve) is fed into the virtual rider. The corresponding block diagram is illustrated in Figure 1.

<p>
<img src=\"../Images/rat.png\">
</p>
<b>Figure 1:</b> Block diagram of a virtual rider composed of a state-space controller and an additional block in order to calculate the corresponding steer angle
<p>
Since each vehicle has its own specific profile, some records including such profiles are provided. The corresponding Modelica model is shown in Figure 2.
<p>
<img src=\"../Images/vr1.png\">
</p>
<b>Figure 2:</b> Wrapped model of the virtual rider composed of a state-space controller for a user defined velocity range. The inputs (blue) are lean and steer angle, lean angle set-value and the velocity of the motorcycle, the output u (white) is the steering torque.
<p>
The model can be found in:
 <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StabilityController_table\">VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StabilityController_table</a>]</span>.
<p>
The incorporated controller is shown in Figure 3.
<p>
<img src=\"../Images/vr2.png\">
</p>
<b>Figure 3:</b>Wrapped model of a state-space controller for a specific velocity range. The table includes the state feedback matrix coefficients which by default are stored in <i>place.mat</i>.
<p>

<p><hr><p>
<h3><font color=\"#008000\" size=5>Path Tracking</font></h3>
In order to track a path, the controllers have to be extended <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">SV01</a>]</span> (see Figure 4).
<p>
<img src=\"../Images/pp_controller.png\">
</p>
<b>Figure 4:</b> Path Preview Controller
<p>
The controller is composed of a non-preview and a path preview part. The former one is responsible for the motorcycle's stability.
The latter one is an additional controller which constraints the vehicle to follow a pre-defined path. The corresponding control law results in:
<p>
<img src=\"../Images/pp_cl.png\">
</p>

Where x1 and x2 are state vectors. The elements of x1 depending on the particular controller design. In the simplest case, x2 is the lateral position x<sub>lat</sub> a pre-defined distance x<sub>preview</sub> ahead of the vehicle (see figure below). The path (roadway) is defined by a lateral profile i.e. the x-direction is fixed (see Figure 5)
<p>
<img src=\"../Images/ss_pp.png\">
</p>
<b>Figure 5:</b> Single-point path preview
<p>
Such a path preview controller is determined with reference to several different approaches. The library provides three different approaches.
Firstly, the controller designed in <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.ControllerDesign.StateSpaceControllerDesign\">UsersGuide.Overview.ControllerDesign.StateSpaceControllerDesign</a>]</span> is extended by a PI-controller. Secondly, a state-space controller is developed.
Thirdly, an approach based on optimal control is provided.
<p>

To emulate a real human rider, single-point path preview is performed, i.e. the rider looks a pre-defined distance ahead. It is worth noting that a similar deviation pattern is actually observed from human riders. The path preview model can be found in
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.Environments.Tracks.OpenLoopMethod.PathPreview\">Environments.Tracks.OpenLoopMethod.PathPreview</a>]</span>
and
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.Environments.Tracks.OpenLoopMethod.PathPreview_StateSpace\">Environments.Tracks.OpenLoopMethod.PathPreview_StateSpace</a>]</span>
<p><hr></p>
<h3><font color=\"blue\" size=4>Path Generation</font></h3>
The path generation is done with MATLAB. It is based on an approach introduced by R. S. Sharp and V. Valtetsiotis <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">SV01</a>]</span>.
Basically, a random signal is generated. Afterwards, the offset is eliminated. In the next step, the signal is filtered in such a way that the result is a smooth path. A typical path is shown in the next Figure 6.
<p>
<img src=\"../Images/matlab_path.png\">
</p>
<b>Figure 6:</b> Path generated with MATLAB
<p>
This path is stored in a mat-file which is fed into a model that can be found in:
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.Environments.Tracks.ClosedLoopMethod.Path\">Environments.Tracks.ClosedLoopMethod.Path</a>]</span>


</html>"));
      end VirtualRider;

      class Environments "Environments"
        annotation (Documentation(info="<html>
The environments sub-package provides tracks for both roll angle tracking and path tracking. In addition, the models for single-point path tracking are included.

<h3><font color=\"#008000\" size=5>Open-Loop Method</font></h3>
Several standard test tracks are provided in order to validate the motorcycle?s performance.
In the following, the model of a standard 90°-curve is explained. The wrapped model is in Figure 1.

<p>
<img src=\"../Images/curve90.png\">
</p>
<b>Figure 1:</b> Wrapped model of a 90° curve
<p>

The actual position of the vehicle is the product of velocity and actual simulation time.
The Visualization model includes the picture of the 90°-curve. The dimensions of the curve are shown in Figure 2.
<p>
<img src=\"../Images/curve90_dim.png\">
</p>
<b>Figure 2:</b> Dimensions of a 90° curve
<p>
The lean angle profile data for a specific vehicle are fed into the table shown in Figure 1. In the first column of this table, the positional information (traveled distance) is stored.
This can be done in two different ways. The data can be entered directly or by means of a record.
The second column includes the corresponding lean angles that are calculated with reference to the following equation.
<p>
<img src=\"../Images/lean_eq.png\">
</p>
Where R is the radius of the curve, g is the gravity and v is the velocity of the vehicle.

<h3><font color=\"#008000\" size=4>Lean Angle Profile Example</font></h3>
In the table below, the lean angle profile of a 90°-curve for the basic (3 d.o.f.) motorcycle is listed.
<p>
<img src=\"../Images/curve_table.png\">
</p>

An Example can be found in:
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.Examples.BasicMotorcycle.controlled_3dof_motorcycle_Curve\">Examples.BasicMotorcycle.controlled_3dof_motorcycle_Curve</a>]</span>.

<p><hr></p>
<h3><font color=\"#008000\" size=5>Closed-Loop Method</font></h3>
--> see <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.VirtualRider\">UsersGuide.Overview.VirtualRider</a>]</span> section \"PathTracking\".


</html>"));
      end Environments;

      class Visualisation "Visualisation"
        annotation (Documentation(info="<html>
The visualization sub-package provides the graphical information for the environments sub-package.
<p>
For example, the dimensions of the following figure are used in the environments sub-package in order to define the roll angle profile of a 90° curve.
<p>
<img src=\"../Images/curve90_dim.png\">
</p>

</html>"));
      end Visualisation;

      class IdealWheels "Ideal Wheels"
        annotation (Documentation(info="<html>
In the ideal wheels sub-package the visualization of the rolling objects from D. Zimmer's MultiBondLib <span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Zim06</a>]</span> were modified such that the appearance is similar to real motorcycle wheels.

The next figure shows D. Zimmer's wheel connected to the basic bicycle model.
<p>
<img src=\"../Images/Bicycle_mod.png\" width=\"443\" heigth=\"323\">
</p>

The modified wheels connected to the basic motorcycle model are shown below.
<p>
<img src=\"../Images/Logo.png\" width=\"395\" heigth=\"265\">
</p>
</html>"));
      end IdealWheels;

      class Utilities "Utilities"
        annotation (Documentation(info="<html>
The utilities sub-package provides some additional functions and models which are partly used in the library.



</html>"));
      end Utilities;

      class Examples "Examples"
        annotation (Documentation(info="<html>
<h3><font color=\"#008000\" size=5>Example: Benchmark Bicycle</font></h3>
Let us start with a simple example of an uncontrolled 3 d.o.f. bicycle model shown in Figure 1.

<p>
<img src=\"../Images/ex1_1.png\">
</p>
<b>Figure 1:</b> Example of an uncontrolled 3 d.o.f. bicycle
<p>

A \"double-click\" on the model opens the following parameter window.
<p>
<img src=\"../Images/p_window_benchBike.png\" width=\"706\" heigth=\"395\">
</p>
<b>Figure 2:</b> Parameter window
<p>
Now, the vehicle specific parameters are entered. For this example, the parameters of table 1 in
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.BicycleMotorcycleModeling.BasicBicycle\">UsersGuide.Overview.BicycleMotorcycleModeling.BasicBicycle</a>]</span>. were used.
For the velocity of the bicycle, let us create a global variable.

<p>
  <i>import SI = Modelica.SIunits;  </i>
<p>
  <i>parameter SI.Velocity vs = 3; </i>
<p>
The value of the global variable vs is now set as the initial velocity of the rear wheel. Again, a \"double-click\" on the rear wheel model opens the parameter window. In order to define the initial conditions, one has to click on the initialization tab. Now several input-fields appear. The global variable vs is entered into the w_start field. Since the input has to be an angular velocity, the following values are entered:
<p>
  <i> vs*{0,0,1/0.3*180/Modelica.Constants.pi} </i>
<p>
The factor 1/0.3, where 0.3 is the rear wheel?s radius, is used to calculate the corresponding angular velocity (<font face=\"Symbol\">w</font> = v r). The factor 180-<font face=\"Symbol\">p</font> is needed to convert radians into degrees. In the next step the model is simulated. Figure 3 shows the animation result for a velocity of 3m/s.
<p>
<img src=\"../Images/ex1_2.png\">
</p>
<b>Figure 3:</b> Animation result of the uncontrolled 3 d.o.f. benchmark bicycle. After about 2s the vehicle falls over like an uncontrolled inverted pendulum.
<p>
In the next step we perform an eigenvalue analysis to get the self-stabilizing area. Therefore the function <b>stabilitAnylysis</b> (Examples.BenchmarkBicycle.RigidRider) is executed.
This is done by a click on the right mouse button in the package browser. Now, the following window appears (see Figure 4).
<p>
<img src=\"../Images/eva_window.png\">
</p>
<b>Figure 4:</b> Parameter window of the eigenvalue function
<p>
The result of the eigenvalue analysis for a velocity range from 0 to 10m/s is shown below.
<p>
<img src=\"../Images/stabilityAnalysis_benchBicycle.png\">
</p>
<b>Figure 5:</b> Result of the eigenvalue analysis
<p>
In the next step let us calculate the coefficients of the feedback matrix for a specific velocity. For this purpose the function <b>ControllerDesign</b> (Examples.BenchmarkBicycle.RigidRider) is executed. According to the results of the eigenvalue analysis, it can be seen that the vehicle is truly unstable for a velocity of 3m/s.
<p>
In the following, the vehicle is stabilized for a velocity of 3m/s.
Out of Figure 5, one can see that an offset greater than 1.7 is sufficient in order to achieve stable behavior. Let us cover the behavior of a cautious rider and thus set the value of the offset equal to 2.
<b>The higher the offset, the more aggressive the rider.</b>
Finally, the state variables are entered. If they are not similar to the default values, the function getStates (Utilities) should be executed in order to determine the appropriate states. The output of the function call is displayed in the command window.
<p>
  [15.9523615979054, 1.81106337719821, 21.5057512252129, 2.1654011773943]
<p>
The model of the controlled 3 d.o.f. bicycle is shown in Figure6.
<p>
<img src=\"../Images/ex1_3.png\">
</p>
<b>Figure 6:</b> Model of the controlled bicycle
<p>
To simulate the model, one has to copy the feedback matrix (displayed in the command window) and insert it into the controller. Figure 7 shows the animation result for a velocity of 3m/s and an initial lean angle of 5°.
<p>
<img src=\"../Images/ex1_4.png\">
</p>
<b>Figure 6:</b> Animation result of the controlled bicycle
<p>

</html>"));
      end Examples;

      class Literature "Literature"
        annotation (Documentation(info="<html>
[And]    <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XAndres\"></a>M.&nbsp;Andres. Object-oriented modeling of wheels and tires. Master?s Thesis, 2009.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [Ass07]   <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XModelica\"></a>Modelica     Association.             Modelica     3.0     language     specification.
         <a href=\"http://www.modelica.org/documents/ModelicaSpec30.pdf\" class=\"url\"><span class=\"cmtt-10\">http://www.modelica.org/documents/ModelicaSpec30.pdf</span></a>, 2007.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">

 [Ass09]   <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XModelicaStandardLib\"></a>Modelica       Associantion.                    Modelica       standard       library.
         <a href=\"http://www.modelica.org/libraries/Modelica\" class=\"url\"><span class=\"cmtt-10\">http://www.modelica.org/libraries/Modelica</span></a>, 2009.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [Cel]     <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XCellierPP\"></a>F.&nbsp;E. Cellier. A numerically stable algorithm for pole placement of single/input
         and  multi/input  systems.    Technical  report,  Dept.  of  Electrical  &amp;  Computer
         Engineering, Univ. of Arizona/Tucson.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">

 [Cel91]   <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XCellierRed\"></a>Francois&nbsp;E. Cellier. <span class=\"cmti-10\">Continuous System Modeling</span>. Springer, 1991.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [CN05]   <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XBondLib\"></a>F.&nbsp;E. Cellier and À.&nbsp;Netbot.  The modelica bond-graph library.  In <span class=\"cmti-10\">Proceedings</span>
         <span class=\"cmti-10\">of the 4th International Modelica Conference, Hamburg</span>, pages 57?65, 2005.
         </p>

         <p class=\"bibitem\"><span class=\"biblabel\">
 [Cos06]  <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XCossalter\"></a>V.&nbsp;Cossalter. <span class=\"cmti-10\">Motorcycle Dynamics</span>. 2006. 2nd edition.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">

 [Eva03]  <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XEvangelou\"></a>S.&nbsp;Evangelou.  <span class=\"cmti-10\">The control and stability analysis of two-wheeled road vehicles</span>.
         PhD thesis, Imperial College London, September, 2003.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [Föl08]   <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XFoellinger\"></a>Otto  Föllinger.     <span class=\"cmti-10\">Regelungstechnik,  Einf</span><span class=\"cmti-10\">ührung  in  die  Methoden  und  ihre</span>

         <span class=\"cmti-10\">Anwendungen</span>. Hüthig, 2008. 10. durchgesehene Auflage.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [Koe83]  <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XKoenen\"></a>C.&nbsp;Koenen. <span class=\"cmti-10\">The dynamic behaviour of motorcycles when running straight ahead</span>
         <span class=\"cmti-10\">and when cornering</span>. PhD thesis, Delft University, 1983.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">

 [KS10]   <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XSommer\"></a>F.&nbsp;Klein and A.&nbsp;Sommerfeld.  Über die theorie des kreisels.  <span class=\"cmti-10\">Quarterly Journal</span>
         <span class=\"cmti-10\">of Pure and Applied Mathematics</span>, Chapter 9, Section 8:863?884, Leipzig, 1910.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [LS06]   <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XSharp2006\"></a>D.&nbsp;J.&nbsp;N. Limebeer and R.&nbsp;S. Sharp.  Bicycles, motorcycles and models.  <span class=\"cmti-10\">IEEE</span>

         <span class=\"cmti-10\">Control Systems Magazine</span>, pages 34?61, October, 2006.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [Lun06]  <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XLunze\"></a>Jan  Lunze.     <span class=\"cmti-10\">Regelungstechnik  II,  Mehrgr</span><span class=\"cmti-10\">ößensysteme,  Digitale  Regelung</span>.
         Springer, 2006. 4. neu bearbeitete Auflage.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [McB05]  <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XMcBride\"></a>Robert&nbsp;Thomas McBride. <span class=\"cmti-10\">System Analysis through Bond Graph Modeling</span>. PhD
         thesis, University of Arizona, 2005.
         </p>

         <p class=\"bibitem\"><span class=\"biblabel\">
 [MPRS07]<span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XMeijaard\"></a>J.&nbsp;P. Meijaard, J.&nbsp;M. Papadopoulos, A.&nbsp;Ruina, and A.&nbsp;L. Schwab. Linearized
         dynamics equations for the balance and steer of a bicycle: a benchmark and review.
         <span class=\"cmti-10\">R. Soc</span>, page&nbsp;63, 2007.
         </p>


         <p class=\"bibitem\"><span class=\"biblabel\">
 [OEM03] <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XOtter\"></a>M.&nbsp;Otter,  H.&nbsp;Elmqvist,  and  S.&nbsp;E.  Mattsson.   The  new  modelica  multibody
         library.  <span class=\"cmti-10\">Proceedings of the third International Modelica Conference, Link</span><span class=\"cmti-10\">öping</span>, 3,
         2003.
         </p>

         <p class=\"bibitem\"><span class=\"biblabel\">
 [Sch09]   <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XMasterarbeit\"></a>Thomas Schmitt. Modeling of a motorcycle in dymola/modelica. Master?s thesis,
         Vorarlberg University of Applied Sciences, 2009.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [SEL04]  <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XSharp2004\"></a>R.&nbsp;S. Sharp, S.&nbsp;Evangelou, and D.&nbsp;J.&nbsp;N. Limebeer. Advances in the modelling
         of motorcycle dynamics. <span class=\"cmti-10\">Multibody System Dynamics</span>, Volume 12:251?283, 2004.
         </p>

         <p class=\"bibitem\"><span class=\"biblabel\">
 [Sha71]  <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XSharp1971\"></a>R.&nbsp;S. Sharp.   The stability and control of motorcycles.   <span class=\"cmti-10\">Journal Mechanical</span>
         <span class=\"cmti-10\">Engineering Science</span>, Volume 13:316?329, 1971.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [Sha07a] <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XSharp2007a\"></a>R.&nbsp;S. Sharp.  Optimal stabilization and path-following controls for a bicycle.
         <span class=\"cmti-10\">Proc. IMechE</span>, 221:34?61, 2007.
         </p>

         <p class=\"bibitem\"><span class=\"biblabel\">
 [Sha07b] <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XSharp2007b\"></a>R.&nbsp;S. Sharp. Motorcycle steering control by road preview. <span class=\"cmti-10\">Journal of Dynamic</span>
         <span class=\"cmti-10\">Systems, Measurement, and Control</span>, 129:415?428, July, 2007.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [SKM08] <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XSchwab2\"></a>A.&nbsp;L.  Schwab,  J.&nbsp;D.&nbsp;G.  Kooijman,  and  J.&nbsp;P.  Meijaard.     Some  recent
         developments in bicycle dynamics and control.   <span class=\"cmti-10\">Fourth European Conference on</span>

         <span class=\"cmti-10\">Structural Control</span>, page&nbsp;8, 2008.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [SL01]   <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XSharp2001\"></a>R.&nbsp;S. Sharp and D.&nbsp;J.&nbsp;N. Limebeer.   A motorcycle model for stability and
         control analysis. <span class=\"cmti-10\">Multibody System Dynamics</span>, Volume 6:123?142, 2001.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">

 [SMP05] <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XSchwab\"></a>A.&nbsp;L. Schwab, J.&nbsp;P. Meijaard, and J.&nbsp;M. Papadopoulos. Benchmark results on
         the linearized equations of motion of an uncontrolled bicycle. <span class=\"cmti-10\">KSME International</span>
         <span class=\"cmti-10\">Journal of Mechanical Science and Technology</span>, pages 292?304, 2005.
         </p>


         <p class=\"bibitem\"><span class=\"biblabel\">
 [SV01]   <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XSharpValtetsiotis\"></a>R.&nbsp;S. Sharp and V.&nbsp;Valtetsiotis. Optimal preview car steering control. <span class=\"cmti-10\">Vehicle</span>

         <span class=\"cmti-10\">System Dynamics</span>, Supplement 35:101?117, 2001.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [Unb07]  <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XUnbehauen\"></a>Heinz  Unbehauen.     <span class=\"cmti-10\">Regelungstechnik  II,  Zustandsregelungen,  digitale  und</span>
         <span class=\"cmti-10\">nichtlineare Regelsysteme</span>. Hüthig, 2007. 9. durchgesehene und korrigierte Auflage.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">

 [Whi99]  <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XWhipple\"></a>F.&nbsp;J.&nbsp;W. Whipple. The stability of the motion of a bicycle. <span class=\"cmti-10\">Quarterly Journal</span>
         <span class=\"cmti-10\">of Pure and Applied Mathematics</span>, Volume 30:312?348, 1899.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [ZC06]   <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XZimmer\"></a>D.&nbsp;Zimmer and F.&nbsp;E. Cellier. Multibond graph library. <span class=\"cmti-10\">Proceedings of the Fifth</span>

         <span class=\"cmti-10\">International Modelica Conference</span>, pages 559?568, 2006.
         </p>
         <p class=\"bibitem\"><span class=\"biblabel\">
 [Zim06]  <span class=\"bibsp\">&nbsp;&nbsp;&nbsp;</span></span><a id=\"XMultiBondLib\"></a>Dirk Zimmer.  A modelica library for multibond graphs and its application in
         3d-mechanics. Master?s thesis, ETH Zürich, 2006.
</p>
</html>"));
      end Literature;

      annotation (Documentation(info="<html>
This overview contains the following sections: <p>

<ol>
<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.ShortIntroduction\">Short Introduction</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.BicycleAndMotorcycleDynamics\">Bicycle and Motorcycle Dynamics</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.LibraryStructure\">Library Structure</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.BicycleMotorcycleModeling\">Bicycle and Motorcycle Modeling</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.EigenvalueAnalysis\">Eigenvalue Analysis</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.ControllerDesign\">Controller Design</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.VirtualRider\">Virtual Rider</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Environments\">Environments</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Visualisation\">Visualisation</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.IdealWheels\">Ideal Wheels</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Utilities\">Utilities</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Examples\">Examples</a>

<li><a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Literature</a>
</ol>
</html>"));
    end Overview;

    package Versions "Release Notes"
      annotation (Documentation(info="<html>


</html>"));
    end Versions;

  end UsersGuide;

  package BasicBicycle
    "3 d.o.f models (rigid rider) and 4 d.o.f. models (movable rider)"
    package RigidRider "3 d.o.f bicycle models"

      annotation (Icon, Documentation(info="<html>
<p>
<img height=\"322\" width=\"461\" src=\"../Images/bicycle_3dof_animation.png\">
</p>
</html>"));

      model BicycleModel_3dof "Multi-Body Model of a basic 3 d.o.f. bicycle"

        import SI = Modelica.SIunits;
        import CO = Modelica.SIunits.Conversions;
        import MB = Modelica.Mechanics.MultiBody;

      // TAB: "General" - General parameter (valid for whole motorcycle)
        parameter SI.Distance rRW = 0.30 "Rear wheel radius";
        parameter SI.Distance rFW = 0.35 "Front wheel radius";
        parameter SI.Distance p = 1.02 "Wheel base";
        parameter SI.Distance t = 0.08 "Trail";

        parameter CO.NonSIunits.Angle_deg alpha = Modelica.Math.atan(3)*180/Modelica.Constants.pi
          "Steering head angle";
        final parameter SI.Angle alpha_rad = CO.from_deg(alpha);
        final parameter SI.Angle epsilon_rad = Modelica.Constants.pi/2 - alpha_rad;
        final parameter SI.Position nSt[3] = {sin(epsilon_rad),cos(epsilon_rad),0}
          "direction of steering axis";

        parameter SI.Position p1[3] = {1,1,0} "Center of mass rear frame";
        final parameter SI.Position CoM_RF[3] = {-p1[1], p1[2] - rRW, p1[3]};

        parameter SI.Position p2[3] = {1, 1, 0} "Center of mass front frame";
        final parameter SI.Position CoM_FF[3] = {p - p2[1], p2[2] - rFW, p2[3]};

        parameter SI.Position p3[3] = {1, 1, 0} "Steering axis position";
        final parameter SI.Position rRF[3] = {p3[1], rRW-p3[2], p3[3]};

        // Calculate the distance between rear wheel center point and front wheel center point
        final parameter SI.Distance p_rRW_rFW = sqrt((rFW-rRW)^2 + p^2);

        final parameter SI.Position rFF[3] = {p_rRW_rFW-rRF[1], p3[2]-rFW, p3[3]};

        parameter SI.Mass mFF = 4 "Front frame mass";
        parameter SI.Mass mRF = 85 "Rear frame mass";

      // TAB: Intertia Tensor of the Rear Frame - Rear Frame parameter
        parameter SI.Inertia I_RF_11=0.001 "(1,1) element of inertia tensor"
          annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
        parameter SI.Inertia I_RF_22=0.001 "(2,2) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
        parameter SI.Inertia I_RF_33=0.001 "(3,3) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
        parameter SI.Inertia I_RF_21=0 "(2,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
        parameter SI.Inertia I_RF_31=0 "(3,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
        parameter SI.Inertia I_RF_32=0 "(3,2) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));

      // TAB: Intertia Tensor of the Front Frame - Front Frame parameter
        parameter SI.Inertia I_FF_11=0.001 "(1,1) element of inertia tensor"
          annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
        parameter SI.Inertia I_FF_22=0.001 "(2,2) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
        parameter SI.Inertia I_FF_33=0.001 "(3,3) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
        parameter SI.Inertia I_FF_21=0 "(2,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
        parameter SI.Inertia I_FF_31=0 "(3,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
        parameter SI.Inertia I_FF_32=0 "(3,2) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));

      // TAB: Advanced - State Selection
        parameter Boolean enforceStates =  false
          "|Advanced||enforce lean angle and lean rate as states - <true> in order to perform an eigenvalue analysis or a controller design";

        // Calculation of the lean angle
      protected
        Real eAxis[3] "unit vector aligned to wheel Axis in inertial frame";
      public
        Real leanAngle(stateSelect= if enforceStates then StateSelect.always else StateSelect.prefer);
        Real leanRate(stateSelect= if enforceStates then StateSelect.always else StateSelect.prefer)
          "Derivative of the lean angle";

      // TAB: Initial Conditions
        parameter CO.NonSIunits.Angle_deg init_steerAngle = 0
          "|Initial Conditions||initial steer angle";

       // parameter CO.NonSIunits.Angle_deg init_leanAngle = 0
       //   "|Initial Conditions||initial lean angle of the rear frame w.r.t. xz-plane";

        annotation(Diagram(
            Line(points=[90,28; 110,28; 110,80; 130,80], style(
                color=10,
                rgbcolor={95,95,95},
                pattern=2)),
      Rectangle(extent=[-102,-62; -82,-82],
                                          style(color=83, rgbcolor={255,85,255})),
      Text(
      extent=[-102,-62; -82,-82],
      style(color=83, rgbcolor={255,85,255}),
      string="Connected?"),
            Line(points=[-72,-72; -72,-50], style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-82,-72; 50,-72],  style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[50,-72; 50,-66],   style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-72,-50; -46,-50], style(color=83, rgbcolor={255,85,
                    255}))), Documentation(info="<html>

</html>"));

        // Picture (TAB General) - Geometric description
        annotation (Images(Parameters(name="", source="images/bicycle_3dof.jpg")),
            Diagram(
      Rectangle(extent=[-102,-62; -82,-82],
                                          style(color=83, rgbcolor={255,85,255})),
      Text(
      extent=[-102,-62; -82,-82],
      style(color=83, rgbcolor={255,85,255}),
      string="Connected?"),
            Line(points=[-72,-72; -72,-50], style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-82,-72; 50,-72],  style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-72,-50; -46,-50], style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[50,-72; 50,-66],   style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[90,28; 110,28; 110,80; 130,80], style(
                color=10,
                rgbcolor={95,95,95},
                pattern=2))),
          Icon(
            Bitmap(extent=[-130,102; 130,-100], name="Images/Bicycle_Logo.png"),
            Line(points=[-10,-100; -10,-22; -10,10; -60,60],
                                                      style(color=10, rgbcolor={
                    95,95,95})),
            Line(points=[-60,60; -60,-100], style(color=10, rgbcolor={95,95,95})),
            Line(points=[124,-80; 128,-80],   style(color=10, rgbcolor={95,95,95})),
            Line(points=[-128,-70; -122,-70], style(color=10, rgbcolor={95,95,95})),
            Line(points=[120,-84; 120,-100],style(color=10, rgbcolor={95,95,95})),
            Line(points=[120,-76; 120,-30; 130,-30; 130,-32],style(color=10,
                  rgbcolor={95,95,95})),
            Line(points=[2,36; 2,36; 46,80; 130,80],         style(color=10,
                  rgbcolor={95,95,95}))));

        // Animation
      public
        parameter SI.Angle saddlepipeAngle = 75
          "|Animation || angle of saddlepipe";
        final parameter SI.Angle saddlepipeAngleRad = SI.Conversions.from_deg(saddlepipeAngle);
        parameter SI.Position saddlenodeHeight = 0.4
          "|Animation || height of the saddle node";
        parameter SI.Position saddleHeight = 0.15
          "|Animation || height of the saddle above the saddlenode";
        parameter SI.Position chainwheelPos = 1.3*0.3
          "|Animation || xposition of the chainwheel";
        parameter Real ladyFactor = 0
          "|Animation || factor for low entrance: Pushes down the upper frame bar.";
        parameter SI.Angle handlebarAngle = 110
          "|Animation || angle of the handlebar";
        final parameter SI.Angle handlebarAngleRad = SI.Conversions.from_deg(handlebarAngle);

        final parameter SI.Position chainwheel[3] = {-chainwheelPos,0,0};
        final parameter SI.Position saddlenode[3] = {chainwheel[1]+(1/tan(saddlepipeAngleRad))*saddlenodeHeight,saddlenodeHeight,0};
        final parameter SI.Position upperframenode[3] = ladyFactor*chainwheel + (1-ladyFactor)*saddlenode;

        MultiBondLib.Mechanics3D.Joints.Revolute FWRevolute(
          phi(stateSelect=StateSelect.always),
          initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
          phi_start=0,
          animation=true,
          cylinderLength=0.05,
          cylinderDiameter=0.08,
          cylinderColor={255,0,0},
          enforceStates=true)
          annotation (extent=[-100,-10; -80,10], rotation=90);
        MultiBondLib.Mechanics3D.Parts.SimpleBody FrontMass(
          sphereDiameter=0.1,
          animation=true,
          sphereColor={0,180,0},
          I_11=I_FF_11,
          I_22=I_FF_22,
          I_33=I_FF_33,
          I_21=I_FF_21,
          I_31=I_FF_31,
          I_32=I_FF_32,
          m=mFF)
               annotation (extent=[-100,70; -80,90],rotation=90);
        MultiBondLib.Mechanics3D.Parts.SimpleBody RearMass(
          animation=true,
          sphereDiameter=0.1,
          sphereColor={0,180,0},
          I_11=I_RF_11,
          I_22=I_RF_22,
          I_33=I_RF_33,
          I_21=I_RF_21,
          I_31=I_RF_31,
          I_32=I_RF_32,
          m=mRF)
               annotation (extent=[80,70; 100,90],rotation=90);
        MultiBondLib.Mechanics3D.Parts.FixedTranslation RearMassPos(animation=
              false, r=CoM_RF)
                      annotation (extent=[80,40; 100,60],rotation=90);
        MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontMassPos(
                             animation=false, r=CoM_FF)
                                                 annotation (extent=[-100,40; -80,60],
            rotation=90);

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspRight(
           lengthDirection=chainwheel,
           length=sqrt(chainwheel*chainwheel),
           shapeType="box",
           color={0,0,100},
           width=0.05,
           height=0.03,
           r_shape={0,0,0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSusp2Right(
           length=sqrt(saddlenode*saddlenode),
           shapeType="box",
           color={0,0,100},
           lengthDirection=saddlenode,
           width=0.05,
           height=0.03,
           r_shape={0,0,0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspLeft(
           lengthDirection=chainwheel,
           length=sqrt(chainwheel*chainwheel),
           shapeType="box",
           color={0,0,100},
           width=0.05,
           height=0.03,
           r_shape={0,0,-0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSusp2Left(
           length=sqrt(saddlenode*saddlenode),
           shapeType="box",
           color={0,0,100},
           lengthDirection=saddlenode,
           width=0.05,
           height=0.03,
           r_shape={0,0,-0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SaddlePipe(
          shapeType="cylinder",
          color={0,0,100},
          r_shape=chainwheel,
          lengthDirection=saddlenode-chainwheel,
          width=0.06,
          height=0.06,
          length=(saddlenodeHeight+saddleHeight)*(1/sin(saddlepipeAngleRad)),
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape lowerframepipe(
           shapeType="box",
           color={0,0,100},
           r_shape=chainwheel,
           width=0.1,
           height=0.06,
           lengthDirection=-RearFrame.r-chainwheel,
           widthDirection={0,0,1},
           length=sqrt((-RearFrame.r-chainwheel)*(-RearFrame.r-chainwheel)),
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape upperframepipe(
           shapeType="box",
           color={0,0,100},
           width=0.1,
           height=0.06,
           widthDirection={0,0,1},
           r_shape=upperframenode,
           lengthDirection=(-RearFrame.r-upperframenode),
           length=sqrt((-RearFrame.r-upperframenode)*(-RearFrame.r-upperframenode)),
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape chainwheelpipe(
          shapeType="cylinder",
          color={0,0,100},
          widthDirection={1,0,0},
          r_shape=chainwheel+{0,0,-0.08},
          lengthDirection={0,0,1},
          width=0.1,
          height=0.1,
          length=0.16,
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Saddle(
          color={0,0,0},
          shapeType="beam",
          lengthDirection={-1,0,0},
          widthDirection={0,0,1},
          length=0.2,
          width=0.1,
          height=0.04,
          r_shape={saddlenode[1]+(saddleHeight/tan(saddlepipeAngleRad))+0.07,saddleHeight+saddlenodeHeight,0},
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe1(
          shapeType="box",
          color={0,0,100},
          lengthDirection={cos(handlebarAngleRad),sin(handlebarAngleRad),0},
          r_shape={0,0,0},
          length=0.134,
          width=0.05,
          height=0.05,
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe2(
          shapeType="cylinder",
          color={0,0,0},
          lengthDirection={0,0,1},
          width=0.06,
          height=0.04,
          r_shape={cos(handlebarAngleRad),sin(handlebarAngleRad),0}*0.134+{0,0,-0.22},
          length=0.44,
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspLeft(
          shapeType="box",
          r_shape={0,0,-0.050},
          color={0,0,100},
          width=0.03,
          height=0.03,
          lengthDirection=Steering.n,
          length=-FrontFrame.length,
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspRight(
          shapeType="box",
          color={0,0,100},
          width=0.03,
          height=0.03,
          lengthDirection=Steering.n,
          r_shape={0,0,0.050},
          length=-FrontFrame.r*Steering.n/sqrt(Steering.n*Steering.n),
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        annotation (
          Diagram(
      Rectangle(extent=[-102,-62; -82,-82],
                                          style(color=83, rgbcolor={255,85,255})),
      Text(
      extent=[-102,-62; -82,-82],
      style(color=83, rgbcolor={255,85,255}),
      string="Connected?"),
            Line(points=[-82,-72; 50,-72],  style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-72,-50; -46,-50], style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-72,-72; -72,-50], style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[50,-72; 50,-66],   style(color=83, rgbcolor={255,85,
                    255}))),
          experiment(StopTime=10),
          experimentSetupOutput,
          Documentation(info="<html>
This example presents the model of a bicycle. This model is a slight modification of Dirk Zimmers Bicycle.
<p>
  --> The steering angle is changed to arctan(3)
</p>

<p>
  --> The coordinates of the bicycle are modified
</p>

However, the dynamic characteristics of the bycicle are not changed in any way.

<p>
<img src=\"../Images/Bicycle_mod.png\">
</p>

<p>
The joints of the bicycle are frictionless and the wheels are ideally rolling.
The bicycle is uncontrolled, but due to its initial velocity it is self-stabilizing.
Within a certain a range of driving velocity a bicycle is stable.
<p>

A bicycle has 7 degrees of freedom on positional level and 3 degrees of freedom on
velocity level.
</html>"),Coordsys(extent=[-130,-100; 130,100], scale=0.4),
          Icon(
            Rectangle(extent=[130,100; -130,-100], style(
                color=7,
                rgbcolor={255,255,255},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Bitmap(extent=[-131,100; 129,-100], name="Images/Bicycle_Logo.png"),
            Line(points=[-10,-100; -10,-2; -10,10; -60,60],
                                                      style(color=10, rgbcolor={
                    95,95,95})),
            Line(points=[-60,60; -60,-100], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-128,-70; -124,-70], style(color=10, rgbcolor={95,95,95})),
            Line(points=[122,-80; 128,-80],   style(color=10, rgbcolor={95,95,95})),
            Line(points=[-2,36; -2,36; 42,80; 130,80],       style(color=10,
                  rgbcolor={95,95,95})),
            Line(points=[120,-100; 120,-84], style(color=10, rgbcolor={95,95,95})),
            Line(points=[120,-76; 120,-30; 130,-30; 134,-30],style(color=10,
                  rgbcolor={95,95,95}))));
        MultiBondLib.Mechanics3D.Parts.FixedTranslation RearFrame(animation=false, r=
              rRF)                               annotation (extent=[50,18; 70,38],
            rotation=0);
        MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontFrame(                 r=
             rFF, animation=false)               annotation (extent=[-70,18; -50,38],
                   rotation=0);
        MultiBondLib.Mechanics3D.Joints.ActuatedRevolute Steering(
          phi(stateSelect=StateSelect.always),
          initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
          cylinderDiameter=0.07,
          cylinderColor={255,0,0},
          cylinderLength=0.1,
          n=nSt,
          enforceStates=true,
          phi_start=init_steerAngle)
          annotation (extent=[-10,18; 10,38], rotation=0);
        BondLib.Mechanical.Rotational.Sources.Torque torque1
          annotation (extent=[40,-27; 60,-7],  rotation=90);
        BondLib.Mechanical.Rotational.Sensors.SpeedSensor speedSensor
          annotation (extent=[64,-40; 84,-20],  rotation=270);
        BondLib.Mechanical.Rotational.Sensors.AngleSensor angleSensor
          annotation (extent=[0,-40; 20,-20],
                                            rotation=270);
        BondLib.Mechanical.Rotational.Sources.Torque torque
          annotation (extent=[-20,-27; 0,-7],  rotation=90);
        Modelica.Blocks.Logical.Switch switch1
          annotation (extent=[-40,-60; -20,-40]);
        Modelica.Blocks.Logical.Switch switch2
          annotation (extent=[40,-60; 60,-40], rotation=90);
        Modelica.Blocks.Sources.Constant const(k=0)
          annotation (extent=[-126,-100; -106,-80]);
        Modelica.Blocks.Interfaces.RealInput T_Steering "steering torque"
          annotation (extent=[-22,-124; 2,-100], style(color=10, rgbcolor={95,95,
                95}),
          rotation=90);
        Modelica.Blocks.Interfaces.RealInput T_engine "engine torque"
          annotation (extent=[108,-124; 132,-100],
                                                 rotation=90);
        Modelica.Blocks.Interfaces.RealOutput w
          "angular velocity of the rear wheel"  annotation (extent=[130,-40; 150,-20]);
        Modelica.Blocks.Interfaces.RealOutput steer_angle
                                                 annotation (extent=[-70,-120; -50,
              -100],     rotation=270);
        MultiBondLib.Mechanics3D.Interfaces.Frame_a connectFW
          "interface front wheel revolute joint"
          annotation (extent=[-148,-80; -128,-60], rotation=0);
        MultiBondLib.Mechanics3D.Interfaces.Frame_a connectRW
          "interface rear wheel revolute joint"
          annotation (extent=[118,-90; 138,-70], rotation=0);
        Modelica.Blocks.Interfaces.RealOutput phi
          "lean (roll) angle of the rear frame" annotation (extent=[130,70; 150,
              90]);

      //initial equation
      //  leanAngle = init_leanAngle;

        MultiBondLib.Mechanics3D.Joints.ActuatedRevolute RWRevolute(
          phi(stateSelect=StateSelect.always),
          cylinderColor={255,0,0},
          cylinderLength=0.05,
          cylinderDiameter=0.08,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          enforceStates=false)
          annotation (extent=[80,-10; 100,10],rotation=270);
      equation
        // lean angle calculation - scalar product
        eAxis = transpose(RearMassPos.frame_a.P.R)*{0,0,1};
        leanAngle = -arcsin({0,1,0}*eAxis);
        phi = leanAngle;
        leanRate = der(leanAngle);

        // check whether inputs are connected or not
        if cardinality(T_Steering) <= 1 then
          T_Steering = 0;
          switch1.u2 = false;
        else
          switch1.u2 = true;
        end if;

        if cardinality(T_engine) <= 1 then
          T_engine = 0;
          switch2.u2 = false;
        else
          switch2.u2 = true;
        end if;
        connect(RearMass.frame_a, RearMassPos.frame_b)       annotation (points=[90,69;
              90,61],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontMassPos.frame_b, FrontMass.frame_a) annotation (points=[-90,61;
              -90,69], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontMassPos.frame_a, FWRevolute.frame_b) annotation (points=[-90,39;
              -90,11],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontFrame.frame_a, FWRevolute.frame_b) annotation (points=[-71,28;
              -90,28; -90,11],    style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontFrame.frame_b,Steering. frame_a) annotation (points=[-49,28;
              -11,28],
                     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Steering.frame_b,RearFrame. frame_a) annotation (points=[11,28;
              49,28],style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(speedSensor.w,w)  annotation (points=[74,-40; 74,-60; 110,-60; 110,
              -30; 140,-30],     style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FWRevolute.frame_a,connectFW)
                                             annotation (points=[-90,-11; -90,-30;
              -120,-30; -120,-70; -138,-70],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(switch1.y,torque. tau) annotation (points=[-19,-50; -10,-50; -10,-28],
                    style(color=74, rgbcolor={0,0,127}));
        connect(const.y,switch1. u3) annotation (points=[-105,-90; -66,-90; -66,-58;
              -42,-58],      style(color=74, rgbcolor={0,0,127}));
        connect(switch2.u1,T_engine)  annotation (points=[42,-62; 42,-84; 120,
              -84; 120,-112],
                         style(color=74, rgbcolor={0,0,127}));
        connect(switch2.u3,const. y) annotation (points=[58,-62; 58,-90; -105,-90],
            style(color=74, rgbcolor={0,0,127}));
        connect(switch2.y,torque1. tau) annotation (points=[50,-39; 50,-28],
            style(color=74, rgbcolor={0,0,127}));
        connect(switch1.u1,T_Steering)  annotation (points=[-42,-42; -56,-42; -56,-66;
              -10,-66; -10,-112],  style(color=74, rgbcolor={0,0,127}));
        connect(angleSensor.phi,steer_angle)  annotation (points=[10,-40; 10,
              -80; -60,-80; -60,-110],
                                  style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(angleSensor.flange_a, Steering.axis) annotation (points=[10,-20;
              10,21; 7,21],
                         style(color=0, rgbcolor={0,0,0}));
        connect(torque.flange_b, Steering.axis) annotation (points=[-10,-7; 10,
              -7; 10,21; 7,21],
                         style(color=0, rgbcolor={0,0,0}));
        connect(w, w) annotation (points=[140,-30; 140,-30], style(color=74,
              rgbcolor={0,0,127}));
        connect(RearMassPos.frame_a, RWRevolute.frame_a) annotation (points=[90,
              39; 90,11], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RearFrame.frame_b, RWRevolute.frame_a) annotation (points=[71,
              28; 90,28; 90,11], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RWRevolute.frame_b, connectRW) annotation (points=[90,-11; 90,
              -80; 128,-80], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(speedSensor.flange_a, RWRevolute.axis) annotation (points=[74,-20;
              74,-7; 83,-7],      style(color=0, rgbcolor={0,0,0}));
        connect(torque1.flange_b, RWRevolute.axis) annotation (points=[50,-7;
              66.5,-7; 66.5,-7; 83,-7], style(color=0, rgbcolor={0,0,0}));
      end BicycleModel_3dof;

      function CalculateEigenvaluesBicycle
        "Stability analysis of an uncontrolled bicycle, plots eigenvalues as a function of bicycle's forward velocity"

        extends Modelica.Icons.Function;
        input String modelName;
        input String independentVariableName;
        input Real startValue "lowest velocity";
        input Real endValue "highest velocity";
        input Integer number_of_values;

      input Real states[4] = {5,6,1,2}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle), rider lean angle, der(rider lean angle)";

        input Integer plotSignals = 0
          "|Signals to plot| 0 ... real and imaginary eigenvalues; 1 ... real eigenvalues; 2 ... imaginary eigenvalues";

      protected
        Boolean hd = LinearSystems.Internal.SetHideDymosim();
        Boolean OK=linearizeModel(modelName);
        Real[number_of_values] values = linspace(startValue, endValue, number_of_values);

        Real nxMat[1, 1] = readMatrix("dslin.mat", "nx", 1, 1);
        Integer ABCDsizes[2] = readMatrixSize("dslin.mat", "ABCD");
        Integer nx = integer(nxMat[1, 1]);
        Integer nu = ABCDsizes[2] - nx;
        Integer ny = ABCDsizes[1] - nx;

        LinearSystems.StateSpace ABCD(
          nx = nx,
          ny = ny,
          nu = nu);

        /* Matrix which includes the relevant statevariables to compute the Eingenvalues
     Simulation window: type importInitial() then linearize the model and open the function "dslin.mat"
     type xuyName to get the selceted StateVariables */
        Real Arelevant[4,4];
        Real EigenValuesi[4, 2] = fill(0, 4, 2);
        Real EV_history[4,number_of_values] = fill(0, 4, number_of_values);
        Real EV_history_imag[4,number_of_values] = fill(0, 4, number_of_values);
        Real EV_real[4];
        Real EV_imag[4];
        Real EV_sort[4];
        Real EV_sort_imag[4];

        Integer n;
        Integer k;
        Integer m;

        String stateNames[nx] "Number of system states";
        Integer window = 0;
        Boolean status = animationOnline(loadInterval=  0.05);

      algorithm
        // plot settings
        window := createPlot(id=  1,
                             position=   {2, 3, 750, 450},
                             y=   fill("", 0),
                             heading=  "Eigenvalue Analysis",
                             range=  {(-2.0), 12.0, 6.0, (-10.0)},
                             autoscale=  false,
                             autoerase=  false,
                             autoreplot=  true,
                             description=  false,
                             grid=  true,
                             color=  true,
                             online=  false,
                             legendLocation=  5,
                             legendHorizontal=  false,
                             leftTitle=  "Real, Imaginary Eigenvalues",
                             bottomTitle=  "Velocity [m/s]");

        ABCD := LinearSystems.linearize(modelName);
        EV_sort :={0,0,0,0};
        for i in 1:number_of_values loop
          SetVariable(independentVariableName, values[i]);
          OK := linearizeModel(modelName);
          if OK then
            ABCD := LinearSystems.readStateSpace("dslin.mat");
            stateNames := ABCD.xNames;

            /* Select the relevant states for the stability analysis
         here: Arelevant = {steer angle, steer rate, lean angle, lean rate, rider lean angle, rider lean rate} */
            Arelevant := (ABCD.A)[states, states];
            EigenValuesi := Modelica.Math.Matrices.eigenValues(Arelevant);
            // Eigenvalues are stored in two separate vectors
            EV_real := EigenValuesi[:, 1];
            EV_imag := EigenValuesi[:, 2];

            // control variables
            k := 0;
            m := 1;

            n :=size(EV_imag, 1);

            /* Remark:
           Since the function Modelica.Math.Matrices.eigenValues() orders the Eigenvalues not always in the same way it is
           necessary to re-order the Eigenvalues stored in the Eigenvalue-Vector EigenValuesi.
         Algorithm:
           1. check whether the eigenvalues include imaginary parts
             -> if an imaginary part appears, store the values in the last row of the vector EV_sort and EV_sort_imag
             -> else store the eigenvalues in ascending order
           2. sort the values in ascending order
             -> if all elements of EV_imag are zero sort all rows
             -> else (if imaginary parts appear) sort the first four rows and leave the remaining rows unchanged
       */

            // Part 1
            for j in 1:n loop
              if EV_imag[j] <> 0 then
                EV_sort[n-k] := EV_real[j];
                // build also a new vector which stores the imaginary values <> 0
                EV_sort_imag[n-k] := EV_imag[j];
                k := k+1;
                //p := i;
              else
                EV_sort[m] := EV_real[j];
                EV_sort_imag[m] := EV_imag[j];
                m := m+1;
              end if;
            end for;

            // Part 2
            if EV_imag[1] == 0 and EV_imag[2] == 0 and EV_imag[3] == 0 and EV_imag[4] == 0 then
               EV_history[:, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort);
               EV_history_imag[3:4, i] := EV_sort_imag[3:4];
            else
              EV_history[1:2, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort[1:2]);
              EV_history[3:4, i] := EV_sort[3:4];
              EV_history_imag[3:4,i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort_imag[3:4]);
            end if;

          end if;
        end for;

         if plotSignals == 0 then
           // plot the real eigenvalues
           plotArrays(x= values[1:number_of_values],
                     y= transpose(EV_history[:,1:number_of_values]),
                     title= "Eigenvalue Analysis",
                     legend= {"castering mode", "capsize mode", "Re(weave mode)", "Re(weave mode)"},
                     style= {0});

           // plot the imaginary eigenvalues
           plotArrays(x= values[1:number_of_values],
                     y= transpose(EV_history_imag[3:4,1:number_of_values]),
                     title= "Eigenvalue Analysis",
                     legend= {"Im(weave mode)", "Im(weave mode)"},
                     style= {1});
          elseif plotSignals == 1 then
            plotArrays(x= values[1:number_of_values],
                     y= transpose(EV_history[:,1:number_of_values]),
                     title= "Eigenvalue Analysis",
                     legend= {"castering mode", "capsize mode", "Re(weave mode)", "Re(weave mode)"},
                     style= {0});
          else
            plotArrays(x= values[1:number_of_values],
                     y= transpose(EV_history_imag[3:4,1:number_of_values]),
                     title= "Eigenvalue Analysis",
                     legend= {"Im(weave mode)", "Im(weave mode)"},
                     style= {1});
          end if;

        writeMatrix("stability.mat","eigenvalues",[values,transpose(EV_history[:,:])]);
        Advanced.HideDymosim := hd;

      end CalculateEigenvaluesBicycle;
    end RigidRider;

    package MovableRider
      "1 additional d.o.f allowing the rider upper body to lean"
      annotation (Documentation(info="<html>

<p>
<img height=\"322\" width=\"461\" src=\"../Images/Bicycle_mod_rider2.png\">
</p>

</html>"));

      model BicycleModel_4dof "Multi-Body Model of a basic 4 d.o.f. bicycle"

        import SI = Modelica.SIunits;
        import CO = Modelica.SIunits.Conversions;
        import MB = Modelica.Mechanics.MultiBody;

        // general parameter (valid for whole motorcycle)
        parameter SI.Distance rRW = 0.30 "Rear wheel radius";
        parameter SI.Distance rFW = 0.35 "Front wheel radius";
        parameter SI.Distance p = 1.02 "Wheel base";
        parameter SI.Distance t = 0.08 "Trail";

        parameter CO.NonSIunits.Angle_deg alpha = Modelica.Math.atan(3)*180/Modelica.Constants.pi
          "Steering head angle";
        final parameter SI.Angle alpha_rad = CO.from_deg(alpha);
        final parameter SI.Angle epsilon_rad = Modelica.Constants.pi/2 - alpha_rad;
        final parameter SI.Position nSt[3] = {sin(epsilon_rad),cos(epsilon_rad),0}
          "Direction of steering axis";

        parameter SI.Position p1[3] = {1,1,0} "Center of mass rear frame";
        final parameter SI.Position CoM_RF[3] = {-p1[1], p1[2] - rRW, p1[3]};

        parameter SI.Position p2[3] = {1, 1, 0} "Center of mass front frame";
        final parameter SI.Position CoM_FF[3] = {p - p2[1], p2[2] - rFW, p2[3]};

        parameter SI.Position p3[3] = {1, 1, 0} "Steering axis position";
        final parameter SI.Position rRF[3] = {p3[1], rRW-p3[2], p3[3]};

        // Calculate the distance between rear wheel center point and front wheel center point
        final parameter SI.Distance p_rRW_rFW = sqrt((rFW-rRW)^2 + p^2);

        final parameter SI.Position rFF[3] = {p_rRW_rFW-rRF[1], p3[2]-rFW, p3[3]};

        parameter SI.Position p4[3] = {1, 1, 0}
          "Rider's revolute joint position";
        final parameter SI.Position rRJ[3] = {-p4[1], p4[2]-rRW, p4[3]};

        parameter SI.Position p5[3] = {1, 1, 0}
          "Center of mass rider's upper body";
        final parameter SI.Position rRUP[3] = {p4[1]-p5[1], p5[2]-p4[2], 0};

        parameter SI.Mass mFF = 4 "Front frame mass";
        parameter SI.Mass mRF = 34 "Rear frame and rider's lower body mass";
        parameter SI.Mass mRUP = 51 "Rider's upper body mass";

      // TAB: Intertia Tensor of the Rear Frame - Rear Frame parameter
        parameter SI.Inertia I_RF_11=0.001 "(1,1) element of inertia tensor"
          annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
        parameter SI.Inertia I_RF_22=0.001 "(2,2) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
        parameter SI.Inertia I_RF_33=0.001 "(3,3) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
        parameter SI.Inertia I_RF_21=0 "(2,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
        parameter SI.Inertia I_RF_31=0 "(3,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
        parameter SI.Inertia I_RF_32=0 "(3,2) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));

      // TAB: Intertia Tensor of the Front Frame - Front Frame parameter
        parameter SI.Inertia I_FF_11=0.001 "(1,1) element of inertia tensor"
          annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
        parameter SI.Inertia I_FF_22=0.001 "(2,2) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
        parameter SI.Inertia I_FF_33=0.001 "(3,3) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
        parameter SI.Inertia I_FF_21=0 "(2,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
        parameter SI.Inertia I_FF_31=0 "(3,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
        parameter SI.Inertia I_FF_32=0 "(3,2) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));

      // TAB: Intertia Tensor of Rider's upper body - Rider's upper body parameter
        parameter SI.Inertia I_RUP_11=0.001 "(1,1) element of inertia tensor"
          annotation(Dialog(tab="Inertia tensor of rider's upper body", group="Inertia Tensor"));
        parameter SI.Inertia I_RUP_22=0.001 "(2,2) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of rider's upper body", group="Inertia Tensor"));
        parameter SI.Inertia I_RUP_33=0.001 "(3,3) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of rider's upper body", group="Inertia Tensor"));
        parameter SI.Inertia I_RUP_21=0 "(2,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of rider's upper body", group="Inertia Tensor"));
        parameter SI.Inertia I_RUP_31=0 "(3,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of rider's upper body", group="Inertia Tensor"));
        parameter SI.Inertia I_RUP_32=0 "(3,2) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of rider's upper body", group="Inertia Tensor"));

      // TAB: Advanced - State Selection
        parameter Boolean enforceStates =  false
          "|Advanced||enforce lean angle and lean rate as states - <true> in order to perform an eigenvalue analysis or a controller design";

        // Calculation of the lean angle
      protected
        Real eAxis[3] "unit vector aligned to wheel Axis in inertial frame";
      public
        Real leanAngle(stateSelect= if enforceStates then StateSelect.always else StateSelect.prefer);
        Real leanRate(stateSelect= if enforceStates then StateSelect.always else StateSelect.prefer)
          "Derivative of the lean angle";

      // TAB: Initial Conditions
        parameter CO.NonSIunits.Angle_deg init_steerAngle = 0
          "|Initial Conditions||initial steer angle";

        // Geometric description
        annotation (Images(Parameters(name="", height="242", width="394",source="images/bicycle_4dof.jpg")),
            Diagram(
      Rectangle(extent=[-102,-92; -82,-112],
                                          style(color=83, rgbcolor={255,85,255})),
      Text(
      extent=[-102,-92; -82,-112],
      style(color=83, rgbcolor={255,85,255}),
      string="Connected?"),
            Line(points=[-72,-102; -72,-80],style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-82,-102; 50,-102],style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-72,-80; -46,-80], style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[50,-102; 50,-96],  style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-72,-80; -72,90],  style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-72,90; -46,90],   style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[90,0; 130,0; 130,0; 130,0],     style(
                color=10,
                rgbcolor={95,95,95},
                pattern=2))),
          Icon(
            Rectangle(extent=[-130,130; 130,-130], style(
                color=7,
                rgbcolor={255,255,255},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Bitmap(extent=[-170,122; 168,-128], name=
                  "Images/Bicycle_Logo_4dof.png"),
            Line(points=[-10,-130; -10,-74; -10,-40; -50,0],
                                                      style(color=10, rgbcolor={
                    95,95,95})),
            Line(points=[-50,0; -50,-130],  style(color=10, rgbcolor={95,95,95})),
            Line(points=[-128,-100; -98,-100],style(color=10, rgbcolor={95,95,95})),
            Line(points=[92,-110; 128,-110],  style(color=10, rgbcolor={95,95,95})),
            Line(points=[90,-106; 90,-60; 100,-60; 130,-60], style(color=10,
                  rgbcolor={95,95,95})),
            Line(points=[90,-112; 90,-130], style(color=10, rgbcolor={95,95,95})),
            Line(points=[50,-50; 50,-50; 100,0; 130,0],      style(color=10,
                  rgbcolor={95,95,95})),
            Line(points=[40,-8; 40,-8; 108,60; 138,60],      style(color=10,
                  rgbcolor={95,95,95})),
            Line(points=[28,-8; 28,-8; -40,60; -132,60],
                                                      style(color=10, rgbcolor={
                    95,95,95}))),
          Documentation(info="<html>

</html>"));

        // Animation
        // -------------------------------------------------------------------------------------

        parameter SI.Angle saddlepipeAngle = 75
          "|Animation || angle of saddlepipe";
        final parameter SI.Angle saddlepipeAngleRad = SI.Conversions.from_deg(saddlepipeAngle);
        parameter SI.Position saddlenodeHeight = 0.4
          "|Animation || height of the saddle node";
        parameter SI.Position saddleHeight = 0.15
          "|Animation || height of the saddle above the saddlenode";
        parameter SI.Position chainwheelPos = 1.3*0.3
          "|Animation || xposition of the chainwheel";
        parameter Real ladyFactor = 0
          "|Animation || factor for low entrance: Pushes down the upper frame bar.";
        parameter SI.Angle handlebarAngle = 110
          "|Animation || angle of the handlebar";
        final parameter SI.Angle handlebarAngleRad = SI.Conversions.from_deg(handlebarAngle);

        final parameter SI.Position chainwheel[3] = {-chainwheelPos,0,0};
        final parameter SI.Position saddlenode[3] = {chainwheel[1]+(1/tan(saddlepipeAngleRad))*saddlenodeHeight,saddlenodeHeight,0};
        final parameter SI.Position upperframenode[3] = ladyFactor*chainwheel + (1-ladyFactor)*saddlenode;

        final parameter SI.Position riderConnect[3] = {0.345, 0.9, 0};
        final parameter SI.Position riderHead[3] = {0.345, 1.4, 0};
        final parameter SI.Position riderLegJoint[3] = {-0.6,0.35,0};
        final parameter SI.Position riderLegJoint2[3] = {-0.6,0.65,0};

        MultiBondLib.Mechanics3D.Joints.Revolute FWRevolute(
          phi(stateSelect=StateSelect.always),
          initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
          phi_start=0,
          animation=true,
          cylinderLength=0.05,
          cylinderDiameter=0.08,
          cylinderColor={255,0,0},
          enforceStates=true)
          annotation (extent=[-100,-40; -80,-20],rotation=90);
        MultiBondLib.Mechanics3D.Parts.SimpleBody FrontMass(
          sphereDiameter=0.1,
          animation=true,
          sphereColor={0,180,0},
          I_11=I_FF_11,
          I_22=I_FF_22,
          I_33=I_FF_33,
          I_21=I_FF_21,
          I_31=I_FF_31,
          I_32=I_FF_32,
          m=mFF)
               annotation (extent=[-100,62; -80,82],rotation=90);
        MultiBondLib.Mechanics3D.Parts.SimpleBody RearMass(
          animation=true,
          sphereDiameter=0.1,
          sphereColor={0,180,0},
          I_11=I_RF_11,
          I_22=I_RF_22,
          I_33=I_RF_33,
          I_21=I_RF_21,
          I_31=I_RF_31,
          I_32=I_RF_32,
          m=mRF)
               annotation (extent=[80,62; 100,82],rotation=90);
        MultiBondLib.Mechanics3D.Parts.FixedTranslation RearMassPos(r=CoM_RF,
            animation=false)
                      annotation (extent=[80,20; 100,40],rotation=90);
        MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontMassPos(
                             animation=false, r=CoM_FF)
                                                 annotation (extent=[-100,20;
              -80,40],
            rotation=90);

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspRight(
           lengthDirection=chainwheel,
           length=sqrt(chainwheel*chainwheel),
           shapeType="box",
           color={0,0,100},
           width=0.05,
           height=0.03,
           r_shape={0,0,0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSusp2Right(
           length=sqrt(saddlenode*saddlenode),
           shapeType="box",
           color={0,0,100},
           lengthDirection=saddlenode,
           width=0.05,
           height=0.03,
           r_shape={0,0,0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspLeft(
           lengthDirection=chainwheel,
           length=sqrt(chainwheel*chainwheel),
           shapeType="box",
           color={0,0,100},
           width=0.05,
           height=0.03,
           r_shape={0,0,-0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSusp2Left(
           length=sqrt(saddlenode*saddlenode),
           shapeType="box",
           color={0,0,100},
           lengthDirection=saddlenode,
           width=0.05,
           height=0.03,
           r_shape={0,0,-0.050},
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderBody(
           lengthDirection= {0,1,0} "Vector in length direction",
           length=riderHead[2] - riderConnect[2] "Length of visual object",
           shapeType="beam",
           color={50, 155, 50},
           width=0.05 "Width of visual object",
           height=0.1 "Height of visual object",
           r_shape={0,0,0},
           r=revolute.frame_b.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=revolute.frame_b.P.R,w=zeros(3)))
          "Rotation of the part";

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderRightLeg(
           lengthDirection= {-1,-0.75,0} "Vector in length direction",
           length=0.37 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.1 "Height of visual object",
           r_shape={0,0,0.1},
           r=revolute.frame_a.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)))
          "Rotation of the part";

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderRightLeg2(
           lengthDirection= {0.7,-1,0} "Vector in length direction",
           length=0.35 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.1 "Height of visual object",
           r_shape={-1,-0.75,0}*0.3 + {0,0,0.1},
           r=revolute.frame_a.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)))
          "Rotation of the part";

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderLeftLeg(
           lengthDirection= {-1,-0.75,0} "Vector in length direction",
           length=0.37 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.1 "Height of visual object",
           r_shape={0,0,-0.1},
           r=revolute.frame_a.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)))
          "Rotation of the part";

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderLeftLeg2(
           lengthDirection= {0.7,-1,0} "Vector in length direction",
           length=0.35 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.1 "Height of visual object",
           r_shape={-1,-0.75,0}*0.3 + {0,0,-0.1},
           r=revolute.frame_a.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)))
          "Rotation of the part";

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderRightHand(
           lengthDirection= {-1,-1,0.2} "Vector in length direction",
           length=0.4 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.05 "Height of visual object",
           r_shape={0,0.5,0.08},
           r=revolute.frame_b.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=revolute.frame_b.P.R,w=zeros(3)))
          "Rotation of the part";

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderLeftHand(
           lengthDirection= {-1,-1,-0.2} "Vector in length direction",
           length=0.4 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.05 "Height of visual object",
           r_shape={0,0.5,-0.08},
           r=revolute.frame_b.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=revolute.frame_b.P.R,w=zeros(3)))
          "Rotation of the part";

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderHead(
           lengthDirection= {0,1,0} "Vector in length direction",
           length=0.25 "Length of visual object",
           shapeType="sphere",
           color={200,200,155},
           width=0.25 "Width of visual object",
           height=0.25 "Height of visual object",
           r_shape={0,0.5,0} "Offset - rider head is 0.5m above the rider body",
           r=revolute.frame_b.P.x "Same origin as the rider body",
           R=MB.Frames.Orientation(T=revolute.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SaddlePipe(
          shapeType="cylinder",
          color={0,0,100},
          r_shape=chainwheel,
          lengthDirection=saddlenode-chainwheel,
          width=0.06,
          height=0.06,
          length=(saddlenodeHeight+saddleHeight)*(1/sin(saddlepipeAngleRad)),
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape lowerframepipe(
           shapeType="box",
           color={0,0,100},
           r_shape=chainwheel,
           width=0.1,
           height=0.06,
           lengthDirection=-RearFrame.r-chainwheel,
           widthDirection={0,0,1},
           length=sqrt((-RearFrame.r-chainwheel)*(-RearFrame.r-chainwheel)),
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape upperframepipe(
           shapeType="box",
           color={0,0,100},
           width=0.1,
           height=0.06,
           widthDirection={0,0,1},
           r_shape=upperframenode,
           lengthDirection=(-RearFrame.r-upperframenode),
           length=sqrt((-RearFrame.r-upperframenode)*(-RearFrame.r-upperframenode)),
           r=RearFrame.frame_b.P.x,
           R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape chainwheelpipe(
          shapeType="cylinder",
          color={0,0,100},
          widthDirection={1,0,0},
          r_shape=chainwheel+{0,0,-0.08},
          lengthDirection={0,0,1},
          width=0.1,
          height=0.1,
          length=0.16,
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Saddle(
          color={0,0,0},
          shapeType="beam",
          lengthDirection={-1,0,0},
          widthDirection={0,0,1},
          length=0.2,
          width=0.1,
          height=0.04,
          r_shape={saddlenode[1]+(saddleHeight/tan(saddlepipeAngleRad))+0.07,saddleHeight+saddlenodeHeight,0},
          r=RearFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe1(
          shapeType="box",
          color={0,0,100},
          lengthDirection={cos(handlebarAngleRad),sin(handlebarAngleRad),0},
          r_shape={0,0,0},
          length=0.134,
          width=0.05,
          height=0.05,
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe2(
          shapeType="cylinder",
          color={0,0,0},
          lengthDirection={0,0,1},
          width=0.06,
          height=0.04,
          r_shape={cos(handlebarAngleRad),sin(handlebarAngleRad),0}*0.134+{0,0,-0.22},
          length=0.44,
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspLeft(
          shapeType="box",
          r_shape={0,0,-0.050},
          color={0,0,100},
          width=0.03,
          height=0.03,
          lengthDirection=Steering.n,
          length=-FrontFrame.r*Steering.n/sqrt(Steering.n*Steering.n),
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspRight(
          shapeType="box",
          color={0,0,100},
          width=0.03,
          height=0.03,
          lengthDirection=Steering.n,
          r_shape={0,0,0.050},
          length=-FrontFrame.r*Steering.n/sqrt(Steering.n*Steering.n),
          r=FrontFrame.frame_b.P.x,
          R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

        annotation (
          Diagram(
      Rectangle(extent=[-102,-62; -82,-82],
                                          style(color=83, rgbcolor={255,85,255})),
      Text(
      extent=[-102,-62; -82,-82],
      style(color=83, rgbcolor={255,85,255}),
      string="Connected?"),
            Line(points=[-82,-72; 50,-72],  style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-72,-50; -46,-50], style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[-72,-72; -72,-50], style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[50,-72; 50,-66],   style(color=83, rgbcolor={255,85,
                    255}))),
          experiment(StopTime=10),
          experimentSetupOutput,
          Documentation(info="<html>
This example presents the model of a bicycle. This model is a slight modification of Dirk Zimmers Bicycle.
<p>
  --> The steering angle is changed to arctan(3)
</p>

<p>
  --> The coordinates of the bicycle are modified
</p>

However, the dynamic characteristics of the bycicle are not changed in any way.

<p>
<img src=\"../Images/Bicycle_mod.png\">
</p>

<p>
The joints of the bicycle are frictionless and the wheels are ideally rolling.
The bicycle is uncontrolled, but due to its initial velocity it is self-stabilizing.
Within a certain a range of driving velocity a bicycle is stable.
<p>

A bicycle has 7 degrees of freedom on positional level and 3 degrees of freedom on
velocity level.
</html>"),Coordsys(extent=[-130,-130; 130,130], scale=0.4),
          Icon(
            Rectangle(extent=[130,100; -130,-100], style(
                color=7,
                rgbcolor={255,255,255},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Line(points=[-10,-100; -10,-2; -10,10; -60,60],
                                                      style(color=10, rgbcolor={
                    95,95,95})),
            Line(points=[-60,60; -60,-100], style(color=10, rgbcolor={95,95,95})),
            Line(points=[-128,-70; -124,-70], style(color=10, rgbcolor={95,95,95})),
            Line(points=[122,-80; 128,-80],   style(color=10, rgbcolor={95,95,95})),
            Line(points=[-2,36; -2,36; 42,80; 130,80],       style(color=10,
                  rgbcolor={95,95,95})),
            Line(points=[120,-100; 120,-84], style(color=10, rgbcolor={95,95,95})),
            Line(points=[120,-76; 120,-30; 130,-30; 134,-30],style(color=10,
                  rgbcolor={95,95,95}))));
        MultiBondLib.Mechanics3D.Parts.FixedTranslation RearFrame(animation=false, r=
              rRF)                               annotation (extent=[30,-10; 50,10],
            rotation=0);
        MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontFrame(                 r=
             rFF, animation=false)               annotation (extent=[-50,-10; -30,10],
                   rotation=0);
        MultiBondLib.Mechanics3D.Joints.ActuatedRevolute Steering(
          phi(stateSelect=StateSelect.always),
          initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
          cylinderDiameter=0.07,
          cylinderColor={255,0,0},
          cylinderLength=0.1,
          n=nSt,
          enforceStates=true,
          phi_start=init_steerAngle)
          annotation (extent=[-10,-10; 10,10],rotation=0);
        BondLib.Mechanical.Rotational.Sources.Torque torque1
          annotation (extent=[40,-57; 60,-37], rotation=90);
        BondLib.Mechanical.Rotational.Sensors.SpeedSensor speedSensor
          annotation (extent=[64,-70; 84,-50],  rotation=270);
        BondLib.Mechanical.Rotational.Sensors.AngleSensor angleSensor
          annotation (extent=[0,-70; 20,-50],
                                            rotation=270);
        BondLib.Mechanical.Rotational.Sources.Torque torque
          annotation (extent=[-20,-57; 0,-37], rotation=90);
        Modelica.Blocks.Logical.Switch switch1
          annotation (extent=[-40,-90; -20,-70]);
        Modelica.Blocks.Logical.Switch switch2
          annotation (extent=[40,-90; 60,-70], rotation=90);
        Modelica.Blocks.Sources.Constant const(k=0)
          annotation (extent=[-126,-130; -106,-110]);
        Modelica.Blocks.Interfaces.RealInput T_Steering "steering torque"
          annotation (extent=[-21,-154; 1,-130], style(color=10, rgbcolor={95,95,
                95}),
          rotation=90);
        Modelica.Blocks.Interfaces.RealInput T_engine "engine torque"
          annotation (extent=[78,-154; 102,-130],rotation=90);
        Modelica.Blocks.Interfaces.RealOutput w
          "angular velocity of the rear wheel"  annotation (extent=[130,-70;
              150,-50]);
        Modelica.Blocks.Interfaces.RealOutput steer_angle
                                                 annotation (extent=[-60,-150;
              -40,-130], rotation=270);
        MultiBondLib.Mechanics3D.Interfaces.Frame_a connectFW
          "interface front wheel revolute joint"
          annotation (extent=[-148,-110; -128,-90],rotation=0);
        MultiBondLib.Mechanics3D.Interfaces.Frame_a connectRW
          "interface rear wheel revolute joint"
          annotation (extent=[118,-120; 138,-100],
                                                 rotation=0);
        Modelica.Blocks.Interfaces.RealOutput phi
          "lean (roll) angle of the rear frame" annotation (extent=[130,-10; 150,10]);
        MultiBondLib.Mechanics3D.Parts.SimpleBody RidersUpperBody(
          animation=true,
          sphereDiameter=0.1,
          sphereColor={0,180,0},
          m=mRUP,
          I_11=I_RUP_11,
          I_22=I_RUP_22,
          I_33=I_RUP_33,
          I_21=I_RUP_21,
          I_31=I_RUP_31,
          I_32=I_RUP_32)
               annotation (extent=[-60,40; -40,60],
                                                  rotation=180);
        MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation2(
                            r=rRUP, animation=false)
                      annotation (extent=[-30,40; -10,60],
                                                         rotation=180);
        MultiBondLib.Mechanics3D.Joints.ActuatedRevolute revolute(
          n={1,0,0},
          cylinderDiameter=0.05,
          cylinderColor={155,0,0},
          enforceStates=true,
          cylinderLength=0.06)
                              annotation (extent=[20,40; 40,60], rotation=180);
        MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation3(
                            r=rRJ, animation=false)
                      annotation (extent=[60,20; 80,40], rotation=90);
        BondLib.Mechanical.Rotational.Sensors.RelAngleSensor relAngleSensor
          annotation (extent=[20,70; 40,90], rotation=180);
        Modelica.Blocks.Interfaces.RealOutput riderLeanAngle
          "lean (roll) angle of the rider relative to the rear frame"
                                                annotation (extent=[130,50; 150,70]);
        Modelica.Blocks.Interfaces.RealInput T_RiderLean "rider lean torque"
          annotation (extent=[-152,48; -130,72],  rotation=0);
        BondLib.Mechanical.Rotational.Sources.Torque torque2
          annotation (extent=[-10,64; 10,84],  rotation=270);
        Modelica.Blocks.Logical.Switch switch3
          annotation (extent=[-40,80; -20,100]);
        MultiBondLib.Mechanics3D.Joints.ActuatedRevolute RWRevolute(
          phi(stateSelect=StateSelect.always),
          cylinderColor={255,0,0},
          cylinderLength=0.05,
          cylinderDiameter=0.08,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          enforceStates=false)
          annotation (extent=[80,-40; 100,-20],
                                              rotation=270);
      equation
        // lean angle calculation - scalar product
        eAxis = transpose(RearMassPos.frame_a.P.R)*{0,0,1};
        leanAngle = -arcsin({0,1,0}*eAxis);
        phi = leanAngle;
        leanRate = der(leanAngle);

        // check whether inputs are connected or not
        if cardinality(T_Steering) <= 1 then
          T_Steering = 0;
          switch1.u2 = false;
        else
          switch1.u2 = true;
        end if;

        if cardinality(T_engine) <= 1 then
          T_engine = 0;
          switch2.u2 = false;
        else
          switch2.u2 = true;
        end if;

        if cardinality(T_RiderLean) <= 1 then
          T_RiderLean = 0;
          switch3.u2 = false;
        else
          switch3.u2 = true;
        end if;
        connect(RearMass.frame_a, RearMassPos.frame_b)       annotation (points=[90,61;
              90,41],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontMassPos.frame_b, FrontMass.frame_a) annotation (points=[-90,41;
              -90,61], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontMassPos.frame_a, FWRevolute.frame_b) annotation (points=[-90,19;
              -90,-19],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontFrame.frame_a, FWRevolute.frame_b) annotation (points=[-51,0;
              -90,0; -90,-19],    style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FrontFrame.frame_b,Steering. frame_a) annotation (points=[-29,0; -11,
              0],    style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(Steering.frame_b,RearFrame. frame_a) annotation (points=[11,0; 29,0],
                     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(speedSensor.w,w)  annotation (points=[74,-70; 74,-90; 110,-90;
              110,-60; 140,-60], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(FWRevolute.frame_a,connectFW)
                                             annotation (points=[-90,-41; -90,
              -60; -120,-60; -120,-100; -138,-100],
                         style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(switch1.y,torque. tau) annotation (points=[-19,-80; -10,-80;
              -10,-58],
                    style(color=74, rgbcolor={0,0,127}));
        connect(const.y,switch1. u3) annotation (points=[-105,-120; -66,-120;
              -66,-88; -42,-88],
                             style(color=74, rgbcolor={0,0,127}));
        connect(switch2.u1,T_engine)  annotation (points=[42,-92; 42,-114; 90,
              -114; 90,-142],
                         style(color=74, rgbcolor={0,0,127}));
        connect(switch2.u3,const. y) annotation (points=[58,-92; 58,-120; -105,
              -120],
            style(color=74, rgbcolor={0,0,127}));
        connect(switch2.y,torque1. tau) annotation (points=[50,-69; 50,-58],
            style(color=74, rgbcolor={0,0,127}));
        connect(switch1.u1,T_Steering)  annotation (points=[-42,-72; -54,-72;
              -54,-96; -10,-96; -10,-142],
                                   style(color=74, rgbcolor={0,0,127}));
        connect(angleSensor.phi,steer_angle)  annotation (points=[10,-70; 10,
              -110; -50,-110; -50,-140],
                                  style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(angleSensor.flange_a, Steering.axis) annotation (points=[10,-50;
              10,-7; 7,-7],
                         style(color=0, rgbcolor={0,0,0}));
        connect(torque.flange_b, Steering.axis) annotation (points=[-10,-37; 10,
              -37; 10,-7; 7,-7],
                         style(color=0, rgbcolor={0,0,0}));
        connect(RidersUpperBody.frame_a,fixedTranslation2. frame_b) annotation (
           points=[-39,50; -31,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(fixedTranslation2.frame_a,revolute. frame_b) annotation (points=[-9,50;
              19,50],        style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(fixedTranslation3.frame_b,revolute. frame_a) annotation (points=[70,41;
              70,50; 41,50], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(relAngleSensor.flange_a, revolute.bearing) annotation (points=[
              40,80; 40,57; 37,57], style(
            color=0,
            rgbcolor={0,0,0},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(revolute.axis, relAngleSensor.flange_b) annotation (points=[23,
              57; 20,57; 20,80], style(
            color=0,
            rgbcolor={0,0,0},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(relAngleSensor.phi_rel, riderLeanAngle)
                                                    annotation (points=[30,90; 30,100;
              120,100; 120,60; 140,60],
                                style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(torque2.flange_b, revolute.axis) annotation (points=[
              -1.83691e-015,64; -1.83691e-015,57; 23,57],
                      style(
            color=0,
            rgbcolor={0,0,0},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(switch3.y, torque2.tau) annotation (points=[-19,90; 2.0206e-015,
              90; 2.0206e-015,85],
            style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(switch3.u3, const.y) annotation (points=[-42,82; -66,82; -66,
              -120; -105,-120], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(switch3.u1, T_RiderLean) annotation (points=[-42,98; -109.5,98;
              -109.5,60; -141,60],
            style(color=74, rgbcolor={0,0,127}));
        connect(RearMassPos.frame_a, RWRevolute.frame_a) annotation (points=[90,
              19; 90,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RearFrame.frame_b, RWRevolute.frame_a) annotation (points=[51,0;
              90,0; 90,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(fixedTranslation3.frame_a, RWRevolute.frame_a) annotation (
            points=[70,19; 70,0; 90,0; 90,-19], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RWRevolute.frame_b, connectRW) annotation (points=[90,-41; 90,
              -110; 128,-110], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(torque1.flange_b, RWRevolute.axis) annotation (points=[50,-37;
              83,-37], style(color=0, rgbcolor={0,0,0}));
        connect(speedSensor.flange_a, RWRevolute.axis) annotation (points=[74,
              -50; 74,-37; 83,-37], style(color=0, rgbcolor={0,0,0}));
      end BicycleModel_4dof;

    end MovableRider;
    annotation (Documentation(info="<html>

<p>
<img height=\"322\" width=\"620\" src=\"../Images/benchmarkBicycles.png\">
</p>

A detailed description of the models can be found in:
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.BicycleMotorcycleModeling.BasicBicycle\">UsersGuide.Overview.BicycleMotorcycleModeling.BasicBicycle</a>]</span>

</html>"), Icon(
        Rectangle(extent=[-100,-100; 80,50],   style(fillColor=30,
              fillPattern=
                1)),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
              fillColor=30, fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
              fillColor=30, fillPattern=1)),
        Text(
          extent=[-120,125; 120,70],
          string="%name",
          style(color=3, rgbcolor={0,0,255})),
        Text(
          extent=[-90,40; 70,10],
          string="Library",
          style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=0,
            rgbfillColor={0,0,0},
            fillPattern=1)),
        Ellipse(extent=[-38,-86; -90,-34],style(color=0, rgbcolor={0,0,0})),
        Line(points=[-64,-60; -26,4; -18,4; -18,4],    style(color=0,
              rgbcolor={0,0,0})),
        Line(points=[6,-38; 6,-22], style(color=0, rgbcolor={0,0,0})),
        Ellipse(extent=[-60,-64; -68,-56], style(color=0, rgbcolor={0,0,0})),
        Ellipse(extent=[70,-86; 18,-34],  style(color=0, rgbcolor={0,0,0})),
        Ellipse(extent=[48,-64; 40,-56],   style(color=0, rgbcolor={0,0,0})),
        Line(points=[-36,-14; 44,-60], style(color=0, rgbcolor={0,0,0})),
        Ellipse(extent=[10,-22; 2,-14],    style(color=0, rgbcolor={0,0,0})),
        Line(points=[-42,-18; -36,-8], style(color=0, rgbcolor={0,0,0})),
        Line(points=[-38,-21; -32,-11], style(color=0, rgbcolor={0,0,0}))));
  end BasicBicycle;
  annotation (uses(
      MultiBondLib(version="1.3"),
      Modelica(version="2.2.1"),
      BondLib(version="2.3"),
      LinearSystems(version="0.9"),
      Modelica_LinearSystems(version="0.91"),
      Vectors(version="0.8"),
      WheelsAndTires(version="1.0")),
    version="1.0",
    versionDate="2009-08-24",
    preferedView="info",
    conversion(noneFromVersion="", noneFromVersion="1"),
    Icon(Bitmap(extent=[-110,100; 110,-100], name="Images/Logo.png")),
    Coordsys(extent=[-110,-100; 110,100], scale=0.1),
    Documentation(info="<html>
<h3><font color=\"#008000\" size=5>MotorcycleLib</font></h3>
<p>
The <b>MotorcycleLib</b> is a <b>free</b> Modelica library for the purpose of simulation, analysis
and control of bicycles and motorcycles (single-track vehicles). The library focuses
on the modeling of virtual riders based on automatic controller design.
For the single-track vehicles, several models of different complexity have been developed. To validate
these models and their driving performance, virtual riders are provided. The main task of a virtual rider
is to track either a roll angle profile or a pre-defined trajectory using path-preview information. Both methods
are implemented and several test tracks are also included in the library

<p>
<img src=\"../Images/advancedMotorcycle_logo3.png\" width=\"311\" height=\"172\">
</p>

<dl>
  <dt><b>Author</b></dt>
  <dd>Thomas Schmitt, Vorarlberg University of Applied Sciences.<br>
      E-mail: <A HREF='mailto:thomas.schmitt@students.fhv.at'>thomas.schmitt@students.fhv.at</A><br>
      Austria</dd>
      This package was developed and implemented from March 2009 until August 2009,
    <br>
      This package has been originaly developed as part of a the Master's Thesis
  </dd>
  <dt><b>Contact</b></dt>
  <dd><a href='http://www.inf.ethz.ch/personal/fcellier/'>Prof. Francois E. Cellier</a><br>
      Institute of Computational Science, <br>
      Dept. Computer Science, <br>
      ETH Z&uuml;rich, <br>
      Suisse<br>
      E-mail: <A HREF='mailto:fcellier@inf.ethz.ch'>fcellier@inf.ethz.ch</A><br>&nbsp;</dd>
      </dd>
</dl>

<h4>Acknowledgement</h4>
<p>Thanks to Prof. Francois E. Cellier, Dirk Zimmer and Dr. Franz Geiger for their great support during the Master's Thesis. It was a pleasure to work with you.
<br>Thank you Markus Andres for being such a good colleague</p>
<b>Copyright (C) 2009, Thomas Schmitt</b> <p>
<i>The MotorcycleLib package is <b>free</b> software;
it can be redistributed and/or modified
under the terms of the <b>Modelica License 2</b>, see the license conditions
and the accompanying <b>disclaimer</b> in the documentation of package
Modelica in file \"Modelica/package.mo\".</i>

</html>"));

  package BasicMotorcycle
    "4 d.o.f. motorcycle model based on V. Cossalters model"

    annotation (Documentation(info="<html>

<p>
<img src=\"../Images/Logo6.png\">
</p>

A detailed description of the models can be found in:
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.BicycleMotorcycleModeling.BasicMotorcycle\">UsersGuide.Overview.BicycleMotorcycleModeling.BasicMotorcycle</a>]</span>

</html>"), Icon(
        Rectangle(extent=[-100,-100; 80,50],   style(fillColor=30,
              fillPattern=
                1)),
        Ellipse(extent=[-44,-88; -96,-36],style(color=0, rgbcolor={0,0,0})),
        Line(points=[-70,-62; -44,10; -38,10; -34,10], style(color=0,
              rgbcolor={0,0,0})),
        Line(points=[50,-62; 14,-62; -24,-62; -50,-8; -2,-14; 18,-30],style(
              color=0, rgbcolor={0,0,0})),
        Line(points=[18,-30; 64,-16],
                                    style(color=0, rgbcolor={0,0,0})),
        Ellipse(extent=[-66,-66; -74,-58], style(color=0, rgbcolor={0,0,0})),
        Ellipse(extent=[76,-88; 24,-36],  style(color=0, rgbcolor={0,0,0})),
        Ellipse(extent=[54,-66; 46,-58],   style(color=0, rgbcolor={0,0,0})),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
              fillColor=30, fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
              fillColor=30, fillPattern=1)),
        Text(
          extent=[-120,125; 120,70],
          string="%name",
          style(color=3, rgbcolor={0,0,255})),
        Text(
          extent=[-90,40; 70,10],
          string="Library",
          style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=0,
            rgbfillColor={0,0,0},
            fillPattern=1)),
        Line(points=[18,-30; 18,-62], style(color=0, rgbcolor={0,0,0}))));
    model Motorcycle_Vittore_3dof
      // extends Modelica.Icons.Example;

      import SI = Modelica.SIunits;
      import CO = Modelica.SIunits.Conversions;
      import MB = Modelica.Mechanics.MultiBody;

      // general parameter (valid for whole motorcycle)
      parameter SI.Distance rRW = 0.305 "Rear wheel radius";
      parameter SI.Distance rFW = 0.305 "Front wheel radius";
      parameter SI.Distance p = 1.414 "Wheel base";
      parameter SI.Distance t = 0.116 "Trail";

      parameter CO.NonSIunits.Angle_deg epsilon = 27
        "Steering head angle (caster angle)";
      final parameter SI.Angle epsilon_rad = CO.from_deg(epsilon);
      final parameter SI.Position nSt[3] = {sin(epsilon_rad),cos(epsilon_rad),0}
        "direction of steering axis";

      parameter SI.Position p1[3] = {1,1,0} "Center of mass rear frame";
      final parameter SI.Position CoM_RF[3] = {-p1[1], p1[2] - rRW, p1[3]};

      // Calulate coordinates of the steering axis revolute joint
      final parameter SI.Position an = cos(epsilon_rad) * t;
      final parameter SI.Position bn = (p + t) * cos(epsilon_rad);
      final parameter SI.Position h = sin(epsilon_rad)*rRW;
      final parameter SI.Position x = cos(epsilon_rad) * (bn - h);
      final parameter SI.Position y = sin(epsilon_rad) * (bn - h) + rRW;

      final parameter SI.Position rFF[3] = {p - x, y - rFW, 0};
      final parameter SI.Position rRF[3] = {x, rRW - y, 0};

      // Calculate the coordinates of the front assembly
      parameter SI.Position p2[3] = {1, 1, 0} "Center of mass front frame";

      parameter Real d(
        final unit="N/(m/s)",
        final min=0) = 0 "Steering damper";

      parameter SI.Mass mFF = 30.7 "Front frame mass";
      parameter SI.Mass mRF = 217.5 "Rear frame mass";

      // Geometric description
      annotation (Images(Parameters(name="", height="242", width="478",source="images/motorcycle_3dof_2.jpg")),
        Diagram(
    Rectangle(extent=[-102,-62; -82,-82],
                                        style(color=83, rgbcolor={255,85,255})),
    Text(
    extent=[-102,-62; -82,-82],
    style(color=83, rgbcolor={255,85,255}),
    string="Connected?"),
          Line(points=[-82,-72; 50,-72],  style(color=83, rgbcolor={255,85,
                  255})),
          Line(points=[-72,-50; -46,-50], style(color=83, rgbcolor={255,85,
                  255})),
          Line(points=[-72,-72; -72,-50], style(color=83, rgbcolor={255,85,
                  255})),
          Line(points=[50,-72; 50,-66],   style(color=83, rgbcolor={255,85,
                  255})),
          Line(points=[90,28; 110,28; 110,40; 130,40], style(
              color=10,
              rgbcolor={95,95,95},
              pattern=2))),
        Icon(
          Rectangle(extent=[-130,100; 130,-100], style(
              pattern=0,
              fillColor=7,
              rgbfillColor={255,255,255})),
          Bitmap(extent=[-127,98; 125,-84], name="Images/Logo5.png"),
          Line(points=[-52,58; -52,-102], style(color=10, rgbcolor={95,95,95})),
          Line(points=[120,-100; 120,-56], style(color=10, rgbcolor={95,95,95})),
          Line(points=[122,-50; 129,-50], style(color=10, rgbcolor={95,95,95})),
          Line(points=[-128,-50; -120,-50], style(color=10, rgbcolor={95,95,95})),
          Line(points=[120,-52; 120,-10; 130,-10; 130,-8], style(color=10,
                rgbcolor={95,95,95})),
          Line(points=[0,-100; 0,-2; 0,10; -48,58], style(color=10, rgbcolor={
                  95,95,95})),
          Line(points=[82,20; 82,20; 102,40; 130,40],      style(color=10,
                rgbcolor={95,95,95})),
          Line(points=[38,0; 38,0; 116,78; 128,78],        style(color=10,
                rgbcolor={95,95,95}))),
        Documentation(info="<html>

</html>"));

                 // Window(x=0.45,y=0.01,width=0.28,height=0.42), Diagram);

      final parameter SI.Position delta_x = (p + t) - x;
      final parameter SI.Position lff = delta_x/sin(epsilon_rad);
      final parameter SI.Position h2 = tan(epsilon_rad) * p2[1];
      final parameter SI.Position h3 = lff - p2[2] + h2;
      final parameter SI.Position yf = cos(epsilon_rad) * h3;
      final parameter SI.Position xf = x + sin(epsilon_rad)*p2[2] + cos(epsilon_rad)*p2[1];

      final parameter SI.Position CoM_FF[3] = {p - xf, yf - rFW, p2[3]};

      //final parameter SI.Position nSt[3] = {sin(epsilon_rad),cos(epsilon_rad),0};

      // Rear Frame parameter
      parameter SI.Inertia I_RF_11=31.2 "(1,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
      parameter SI.Inertia I_RF_22=21.08 "(2,2) element of inertia tensor"
      annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
      parameter SI.Inertia I_RF_33=0 "(3,3) element of inertia tensor"
      annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
      parameter SI.Inertia I_RF_21=1.74 "(2,1) element of inertia tensor"
      annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
      parameter SI.Inertia I_RF_31=0 "(3,1) element of inertia tensor"
      annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));
      parameter SI.Inertia I_RF_32=0 "(3,2) element of inertia tensor"
      annotation(Dialog(tab="Inertia tensor of the Rear Frame", group="Inertia Tensor (world co-ordinates)"));

      // Front Frame parameter (front frame co-ordinate system)
      parameter SI.Inertia I_FF_11=1.23 "(1,1) element of inertia tensor"
        annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
      parameter SI.Inertia I_FF_22=0.44 "(2,2) element of inertia tensor"
      annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
      parameter SI.Inertia I_FF_33=0 "(3,3) element of inertia tensor"
      annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
      parameter SI.Inertia I_FF_21=0 "(2,1) element of inertia tensor"
      annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
      parameter SI.Inertia I_FF_31=0 "(3,1) element of inertia tensor"
      annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));
      parameter SI.Inertia I_FF_32=0 "(3,2) element of inertia tensor"
      annotation(Dialog(tab="Inertia tensor of the Front Frame", group="Inertia Tensor (body co-ordinates)"));

      // Calculate the front frame inertia tensor for global co-ordinate system
      // I[3,3] ... Inertia Tensor in body co-ordinates
      // R[3,3] ... Rotation-Matrix (rotation about z-Axis)
      // I_global[3,3] ... Inertia Tensor in world co-ordinates
      final parameter Real I[3,3] = [I_FF_11, I_FF_21, I_FF_31; I_FF_21, I_FF_22, I_FF_32;
          I_FF_31, I_FF_32, I_FF_33];
      final parameter Real R[3,3] = [cos(-epsilon_rad), -sin(-epsilon_rad), 0; sin(-epsilon_rad), cos(-epsilon_rad), 0; 0, 0, 1];
      final parameter Real I_global[3,3] = transpose(R) * I * R;

    // TAB: Advanced - State Selection
      parameter Boolean enforceStates =  false
        "|Advanced||enforce lean angle and lean rate as states - <true> in order to perform an eigenvalue analysis or a controller design";

      // Calculation of the lean angle
    protected
      Real eAxis[3] "unit vector aligned to wheel Axis in inertial frame";
    public
      Real leanAngle(stateSelect=if enforceStates then StateSelect.always else
            StateSelect.prefer);
      Real leanRate(stateSelect= if enforceStates then StateSelect.always else StateSelect.prefer)
        "Derivative of the lean angle";

    // TAB: Initial Conditions
      parameter CO.NonSIunits.Angle_deg init_steerAngle = 0
        "|Initial Conditions||initial steer angle";

      // Animation
      // -------------------------------------------------------------------------------------

      // x Coordinates of the nodes
      parameter SI.Position node1 = 0.305+0.1
        "|Animation || xposition of node1";
    protected
      parameter SI.Position stabPos = node1 + 0.2
        "xposition of the stabilization pipe";
      parameter SI.Position node3 = stabPos + 0.2 "xposition of node3";
      parameter SI.Position node4 = node1 "xposition of node4";
      parameter SI.Position node5 = stabPos "xposition of node5";

      // The Rear Frame of the motorcycle is defined by 5 nodes
    protected
      final parameter SI.Position RFnode1[3] = {-node1,0,0};
      final parameter SI.Position RFnode2[3] = {-stabPos,0,0};
      final parameter SI.Position RFnode3[3] = {-node3,0,0};
      final parameter SI.Position RFnode4[3] = {-node4,0.7-0.305,0};
      final parameter SI.Position RFnode5[3] = {-node5,0.82-0.305,0};

    public
      parameter SI.Angle handlebarAngle = 65
        "|Animation || angle of the handlebar";
    protected
      final parameter SI.Angle handlebarAngleRad = SI.Conversions.from_deg(handlebarAngle);

      // Color of the motorcycle parts
    public
      parameter MB.Types.Color FrameColor = {20,20,100}
        "|Animation || Color of the Rear Frame";
      parameter MB.Types.Color HandleBarColor = {155,155,155}
        "|Animation || Color of the HandleBar";
      parameter MB.Types.Color HandleColor = {55,55,55}
        "|Animation || Color of the HandleBar";

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW12Right(
         lengthDirection= RFnode2 "Vector in length direction",
         length=stabPos - node1 "Length of visual object",
         shapeType="cylinder",
         color=FrameColor,
         width=0.08 "Width of visual object",
         height=0.05 "Height of visual object",
         r_shape=RFnode1 + {0,0,0.1},
         r=RearFrame.frame_b.P.x "Origin of visual object",
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW12Left(
         lengthDirection= RFnode2,
         length=stabPos - node1,
         shapeType="cylinder",
         color=FrameColor,
         width=0.08,
         height=0.05,
         r_shape=RFnode1 + {0,0,-0.1},
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Node1Pipe(
        shapeType="cylinder",
        color=FrameColor,
        widthDirection={1,0,0},
        r_shape=RFnode1+{0,0,-0.08},
        lengthDirection={0,0,1},
        width=0.08,
        height=0.08,
        length=0.16,
        r=RearFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspRight(
         lengthDirection=RFnode2,
         length=sqrt(RFnode1*RFnode1),
         shapeType="cylinder",
         color=FrameColor,
         width=0.08,
         height=0.05,
         r_shape={0,0,0.1},
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspLeft(
         lengthDirection=RFnode2,
         length=sqrt(RFnode1*RFnode1),
         shapeType="cylinder",
         color=FrameColor,
         width=0.08,
         height=0.05,
         r_shape={0,0,-0.1},
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape StabPosPipe(
        shapeType="cylinder",
        color=FrameColor,
        widthDirection={1,0,0},
        r_shape=RFnode2+{0,0,-0.08},
        lengthDirection={0,0,1},
        width=0.08,
        height=0.08,
        length=0.16,
        r=RearFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape VertPipeRight(
        shapeType="cylinder",
        color=FrameColor,
        r_shape=RFnode1 + {0,0,0.1},
        lengthDirection=RFnode4-RFnode1,
        width=0.08,
        height=0.05,
        length= RFnode4[2],
        r=RearFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape VertPipeLeft(
        shapeType="cylinder",
        color=FrameColor,
        r_shape=RFnode1 + {0,0,-0.1},
        lengthDirection=RFnode4-RFnode1,
        width=0.08,
        height=0.05,
        length= RFnode4[2],
        r=RearFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Node4Pipe(
        shapeType="cylinder",
        color=FrameColor,
        widthDirection={1,0,0},
        r_shape=RFnode4+{0,0,-0.08},
        lengthDirection={0,0,1},
        width=0.08,
        height=0.08,
        length=0.16,
        r=RearFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape BackRight(
         lengthDirection= {1,0.2,0},
         length= 0.4,
         shapeType="cylinder",
         color=FrameColor,
         width=0.08,
         height=0.05,
         r_shape=RFnode4 + {0,0,0.1},
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape BackLeft(
         lengthDirection= {1,0.2,0},
         length= 0.4,
         shapeType="cylinder",
         color=FrameColor,
         width=0.08,
         height=0.05,
         r_shape=RFnode4 + {0,0,-0.1},
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW45Right(
         lengthDirection= RFnode4 - RFnode5,
         length=sqrt((RFnode5[1]-RFnode4[1])*(RFnode5[1]-RFnode4[1]) + (RFnode5[2]-RFnode4[2])*(RFnode5[2]-RFnode4[2])),
         shapeType="cylinder",
         color=FrameColor,
         width=0.08,
         height=0.05,
         r_shape=RFnode5 + {0,0,0.1},
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW45Left(
         lengthDirection= RFnode4 - RFnode5,
         length=sqrt((RFnode5[1]-RFnode4[1])*(RFnode5[1]-RFnode4[1]) + (RFnode5[2]-RFnode4[2])*(RFnode5[2]-RFnode4[2])),
         shapeType="cylinder",
         color=FrameColor,
         width=0.08,
         height=0.05,
         r_shape=RFnode5 + {0,0,-0.1},
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Node5Pipe(
        shapeType="cylinder",
        color=FrameColor,
        widthDirection={1,0,0},
        r_shape=RFnode5+{0,0,-0.08},
        lengthDirection={0,0,1},
        width=0.08,
        height=0.08,
        length=0.16,
        r=RearFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Stabilizer(
        shapeType="cylinder",
        color=FrameColor,
        r_shape=RFnode2,
        lengthDirection=RFnode5 - RFnode2,
        width=0.08,
        height=0.05,
        length=RFnode5[2],
        r=RearFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Node3Pipe(
        shapeType="cylinder",
        color=FrameColor,
        widthDirection={1,0,0},
        r_shape=RFnode3+{0,0,-0.08},
        lengthDirection={0,0,1},
        width=0.08,
        height=0.08,
        length=0.16,
        r=RearFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW23Right(
         lengthDirection= RFnode2 - RFnode3,
         length=node3 - stabPos,
         shapeType="cylinder",
         color=FrameColor,
         width=0.08,
         height=0.05,
         r_shape=RFnode3 + {0,0,0.1},
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW23Left(
         lengthDirection= RFnode2 - RFnode3,
         length=node3 - stabPos,
         shapeType="cylinder",
         color=FrameColor,
         width=0.08,
         height=0.05,
         r_shape=RFnode3 + {0,0,-0.1},
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
        lowerframepipeRight(
         shapeType="cylinder",
         color=FrameColor,
         r_shape=RFnode3+{0,0,0.1},
         width=0.05,
         height=0.08,
         lengthDirection=-RearFrame.r-RFnode3,
         widthDirection={0,0,1},
         length=sqrt((-RearFrame.r-RFnode3)*(-RearFrame.r-RFnode3)),
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
        lowerframepipeLeft(
         shapeType="cylinder",
         color=FrameColor,
         r_shape=RFnode3+{0,0,-0.1},
         width=0.05,
         height=0.08,
         lengthDirection=-RearFrame.r-RFnode3,
         widthDirection={0,0,1},
         length=sqrt((-RearFrame.r-RFnode3)*(-RearFrame.r-RFnode3)),
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
        upperframepipeRight(
         shapeType="cylinder",
         color=FrameColor,
         width=0.05,
         height=0.08,
         widthDirection={0,0,1},
         r_shape=RFnode5+{0,0,0.1},
         lengthDirection=(-RearFrame.r-RFnode5),
         length=sqrt((-RearFrame.r-RFnode5)*(-RearFrame.r-RFnode5)),
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
        upperframepipeLeft(
         shapeType="cylinder",
         color=FrameColor,
         width=0.05,
         height=0.08,
         widthDirection={0,0,1},
         r_shape=RFnode5+{0,0,-0.1},
         lengthDirection=(-RearFrame.r-RFnode5),
         length=sqrt((-RearFrame.r-RFnode5)*(-RearFrame.r-RFnode5)),
         r=RearFrame.frame_b.P.x,
         R=MB.Frames.Orientation(T=RearFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe1_Right(
        shapeType="cylinder",
        color=HandleBarColor,
        lengthDirection={cos(handlebarAngleRad),sin(handlebarAngleRad),0},
        r_shape={0,0,0.11},
        length=0.134,
        width=0.08,
        height=0.05,
        r=FrontFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe1_Left(
        shapeType="cylinder",
        color=HandleBarColor,
        lengthDirection={cos(handlebarAngleRad),sin(handlebarAngleRad),0},
        r_shape={0,0,-0.11},
        length=0.134,
        width=0.08,
        height=0.05,
        r=FrontFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe2(
        shapeType="cylinder",
        color=HandleBarColor,
        lengthDirection={0,0,1},
        width=0.05,
        height=0.1,
        r_shape={cos(handlebarAngleRad),sin(handlebarAngleRad),0}*0.134+{0,0,-0.17},
        length=0.34,
        r=FrontFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleRight(
        shapeType="cylinder",
        color=HandleColor,
        lengthDirection={0.3,0,1},
        width=0.05,
        height=0.1,
        r_shape={cos(handlebarAngleRad), sin(handlebarAngleRad), 0}*0.134+{0,0,0.17},
        length=0.2,
        r=FrontFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleLeft(
        shapeType="cylinder",
        color=HandleColor,
        lengthDirection={-0.3,-0,1},
        width=0.05,
        height=0.1,
        r_shape={cos(handlebarAngleRad), sin(handlebarAngleRad), 0}*0.134+{0,0,-0.17},
        length=-0.2,
        r=FrontFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspLeft(
        shapeType="cylinder",
        r_shape={0,0,-0.11},
        color=HandleBarColor,
        width=0.08,
        height=0.05,
        lengthDirection=Steering.n,
        length=-FrontFrame.r*Steering.n/sqrt(Steering.n*Steering.n),
        r=FrontFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspRight(
        shapeType="cylinder",
        color=HandleBarColor,
        width=0.08,
        height=0.05,
        lengthDirection=Steering.n,
        r_shape={0,0,0.11},
        length=-FrontFrame.r*Steering.n/sqrt(Steering.n*Steering.n),
        r=FrontFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FrontPlate(
        shapeType="box",
        color=HandleBarColor,
        width=0.02,
        height=0.2,
        lengthDirection=Steering.n,
        r_shape={-0.025,0.01,0},
        length=-FrontFrame.r*Steering.n/sqrt(Steering.n*Steering.n)*0.4,
        r=FrontFrame.frame_b.P.x,
        R=MB.Frames.Orientation(T=FrontFrame.frame_b.P.R,w=zeros(3)));

      annotation (
        Diagram(
    Rectangle(extent=[-100,-60; -80,-80],
                                        style(color=83, rgbcolor={255,85,255})),
    Text(
    extent=[-100,-60; -80,-80],
    style(color=83, rgbcolor={255,85,255}),
    string="Connected?"),
          Line(points=[-80,-70; -74,-70], style(color=83, rgbcolor={255,85,
                  255})),
          Line(points=[-80,-70; 50,-70],  style(color=83, rgbcolor={255,85,
                  255})),
          Line(points=[50,-70; 50,-62],   style(color=83, rgbcolor={255,85,
                  255})),
          Line(points=[-70,-50; -70,-70], style(color=83, rgbcolor={255,85,
                  255})),
          Line(points=[-54,-50; -70,-50], style(color=83, rgbcolor={255,85,
                  255}))),
        experiment(StopTime=10),
        experimentSetupOutput,
        Documentation(info="<html>
This example presents the model of a motorcycle.
<p>
The specific data of the Multi-Body-Model are introduced in the book \"Motorcycle Dynamics, 2nd Edition, 2006\" published by Vittore Cossalter (ISBN: 978-1-4303-0861-4).
</p>

<p>
<b>
Differences:
</b>
</p>
<p>
--> Ideal wheels (discs) are used instead of wheels including the cornering- and camber stiffness
</p>

<p>
<img src=\"../Images/motorcycle4.png\">
</p>

<p>
<b>
Short Description:
</b>
</p>

<p>
The motorcycle model is based on the Multi-Bond-Graph Library which was developed by Dirk Zimmer in 2006. The motorcycle is a further development of an uncontrolled    bicycle which was \"as well\" developed by Dirk Zimmer.
</p>

<p>
The joints of the motorcycle are frictionless and the wheels are ideally rolling.
The motorcycle is uncontrolled, but due to its initial velocity it is self-stabilizing.
Within a certain range of driving velocity a motorcycle is stable.
</p>


<p>
<b>
Remark:
</b>
</p>

<p>
Since the coordinate system of V. Cossalters motorcycle model is different to dymola the inertial-tensor of the front-frame was recalculated.
<pre>
    % Inertial Tensor for principal axis (refer to Motorcycle Dynamics page 262)
    I11 = 1.23;
    I22 = 0.44;

    I = zeros(3);
    I(1,1) = I11;
    I(2,2) = I22;

    % Calculation of the new Inertial Tensor (rotation about z-axis)

    % rotation angle (caster angle)
    eps = -27*pi/180;

    R = [cos(eps) -sin(eps) 0; sin(eps) cos(eps) 0; 0 0 1];
    I_new = R'*I*R
</pre>
</p>
</html>"),
        Icon(
          Rectangle(extent=[-130,100; 130,-100],
                                               style(
              pattern=0,
              fillColor=7,
              rgbfillColor={255,255,255})),
          Bitmap(extent=[-130,95; 126,-79], name="Images/Logo5.png"),
          Line(points=[-130,60; -88,60; -56,60], style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1)),
          Line(points=[-50,60; -50,-100], style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1)),
          Line(points=[120,-100; 120,-54],
                                         style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1)),
          Line(points=[120,-8; 132,-8],  style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1)),
          Line(points=[120,-54; 120,-8], style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1)),
          Line(points=[122,-50; 132,-50],style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1)),
          Line(points=[-124,-50; -132,-50],
                                         style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1))),
        Coordsys(extent=[-130,-100; 130,100], scale=0.4),
        DymolaStoredErrors);
      MultiBondLib.Mechanics3D.Parts.SimpleBody RearMass(
        sphereDiameter=0.1,
        animation=true,
        sphereColor={0,180,0},
        m=mRF,
        I_11=I_RF_11,
        I_22=I_RF_22,
        I_33=I_RF_33,
        I_21=I_RF_21,
        I_31=I_RF_31,
        I_32=I_RF_32)
             annotation (extent=[80,70; 100,90],rotation=90);
      MultiBondLib.Mechanics3D.Parts.FixedTranslation RearFrame(
                          animation=false, r=rRF)
                                               annotation (extent=[50,18; 70,38]);
      MultiBondLib.Mechanics3D.Parts.FixedTranslation RearMassPos(animation=false,
          r=CoM_RF) annotation (extent=[80,38; 100,58],rotation=90);
      MultiBondLib.Mechanics3D.Joints.Revolute FWRevolute(
        phi(stateSelect=StateSelect.always),
        phi_start=0,
        animation=true,
        cylinderDiameter=0.08,
        cylinderColor={255,0,0},
        cylinderLength=0.15,
        initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
        enforceStates=true)
        annotation (extent=[-100,-10; -80,10], rotation=90);
      MultiBondLib.Mechanics3D.Parts.SimpleBody FrontMass(
        sphereDiameter=0.1,
        animation=true,
        sphereColor={0,180,0},
        m=mFF,
        I_11=I_global[1, 1],
        I_22=I_global[2, 2],
        I_33=I_global[3, 3],
        I_21=I_global[2, 1],
        I_31=I_global[3, 1],
        I_32=I_global[3, 2])
             annotation (extent=[-100,70; -80,90],rotation=90);
      MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontFrame(
                             animation=false, r=rFF)
                                               annotation (extent=[-70,18; -50,38]);
      MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontMassPos(
                                     animation=false, r=CoM_FF)
                                               annotation (extent=[-100,38; -80,58],
          rotation=90);
      BondLib.Mechanical.Rotational.Passive.Damper damper(d=d)
        annotation (extent=[-10,-2; 10,18],  rotation=180);
      MultiBondLib.Mechanics3D.Joints.ActuatedRevolute Steering(
        phi(stateSelect=StateSelect.always),
        initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
        cylinderLength=0.07,
        cylinderDiameter=0.07,
        cylinderColor={255,0,0},
        n=nSt,
        enforceStates=true,
        phi_start=init_steerAngle)
        annotation (extent=[-10,18; 10,38], rotation=0);
      BondLib.Mechanical.Rotational.Sources.Torque torque1
        annotation (extent=[40,-27; 60,-7],  rotation=90);
      BondLib.Mechanical.Rotational.Sensors.SpeedSensor speedSensor
        annotation (extent=[64,-40; 84,-20],  rotation=270);
      BondLib.Mechanical.Rotational.Sensors.AngleSensor angleSensor
        annotation (extent=[0,-40; 20,-20],
                                          rotation=270);
      BondLib.Mechanical.Rotational.Sources.Torque torque
        annotation (extent=[-20,-27; 0,-7],  rotation=90);
      Modelica.Blocks.Interfaces.RealInput T_Steering "steering torque"
        annotation (extent=[-12,-124; 12,-100],style(color=10, rgbcolor={95,95,
              95}),
        rotation=90);
      Modelica.Blocks.Interfaces.RealInput T_engine "engine torque"
        annotation (extent=[108,-124; 132,-100],
                                               rotation=90);
      Modelica.Blocks.Interfaces.RealOutput w
        "angular velocity of the rear wheel"  annotation (extent=[130,-20; 150,0]);
      Modelica.Blocks.Interfaces.RealOutput steer_angle
                                               annotation (extent=[-62,-120;
            -42,-100], rotation=270);
      MultiBondLib.Mechanics3D.Interfaces.Frame_a connectFW
        "interface front wheel revolute joint"
        annotation (extent=[-148,-60; -128,-40], rotation=0);
      MultiBondLib.Mechanics3D.Interfaces.Frame_a connectRW
        "interface rear wheel revolute joint"
        annotation (extent=[118,-60; 138,-40], rotation=0);
      Modelica.Blocks.Logical.Switch switch1
        annotation (extent=[-40,-60; -20,-40]);
      Modelica.Blocks.Logical.Switch switch2
        annotation (extent=[40,-60; 60,-40], rotation=90);
      Modelica.Blocks.Sources.Constant const(k=0)
        annotation (extent=[-130,-100; -110,-80]);
      MultiBondLib.Mechanics3D.Interfaces.Frame_a CoM_RearFrame
        annotation (extent=[118,68; 138,88],   rotation=0);
      Modelica.Blocks.Interfaces.RealOutput phi
        "lean (roll) angle of the rear frame" annotation (extent=[130,30; 150,
            50]);
      MultiBondLib.Mechanics3D.Joints.ActuatedRevolute RWRevolute(
        phi(stateSelect=StateSelect.always),
        cylinderColor={255,0,0},
        cylinderLength=0.05,
        cylinderDiameter=0.08,
        initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
        enforceStates=false)
        annotation (extent=[80,-10; 100,10],rotation=270);
    equation
      // lean angle calculation - scalar product
      eAxis = transpose(RearMassPos.frame_a.P.R)*{0,0,1};
      leanAngle = -arcsin({0,1,0}*eAxis);
      phi = leanAngle;
      leanRate = der(leanAngle);
      // check whether inputs are connected or not
      if cardinality(T_Steering) <= 1 then
        T_Steering = 0;
        switch1.u2 = false;
      else
        switch1.u2 = true;
      end if;

      if cardinality(T_engine) <= 1 then
        T_engine = 0;
        switch2.u2 = false;
      else
        switch2.u2 = true;
      end if;
      connect(RearMass.frame_a, RearMassPos.frame_b)       annotation (points=[90,69;
            90,59],        style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(FrontMassPos.frame_b,FrontMass. frame_a) annotation (points=[-90,59;
            -90,69], style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(FrontMassPos.frame_a,FWRevolute. frame_b) annotation (points=[-90,37;
            -90,11],      style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(FrontFrame.frame_a,FWRevolute. frame_b) annotation (points=[-71,28;
            -90,28; -90,11],  style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(Steering.frame_a, FrontFrame.frame_b) annotation (points=[-11,28; -49,
            28],    style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(Steering.frame_b, RearFrame.frame_a) annotation (points=[11,28; 49,28],
                style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(damper.flange_b, Steering.bearing) annotation (points=[-10,8; -10,
            21; -7,21],
                     style(color=0, rgbcolor={0,0,0}));
      connect(angleSensor.flange_a, damper.flange_a) annotation (points=[10,-20;
            10,-6; 10,8; 10,8],style(color=0, rgbcolor={0,0,0}));
      connect(torque.flange_b, damper.flange_a) annotation (points=[-10,-7; 10,
            -7; 10,8],   style(
          color=0,
          rgbcolor={0,0,0},
          fillColor=10,
          rgbfillColor={95,95,95},
          fillPattern=1));
      connect(damper.flange_a, Steering.axis) annotation (points=[10,8; 10,21;
            7,21],         style(color=0, rgbcolor={0,0,0}));
      connect(speedSensor.w, w) annotation (points=[74,-40; 74,-60; 110,-60; 110,
            -10; 140,-10],     style(
          color=74,
          rgbcolor={0,0,127},
          fillColor=7,
          rgbfillColor={255,255,255},
          fillPattern=1));
      connect(FWRevolute.frame_a, connectFW)
                                           annotation (points=[-90,-11; -90,-50;
            -138,-50], style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(switch1.y, torque.tau) annotation (points=[-19,-50; -10,-50; -10,
            -28], style(color=74, rgbcolor={0,0,127}));
      connect(const.y, switch1.u3) annotation (points=[-109,-90; -66,-90; -66,-58;
            -42,-58],      style(color=74, rgbcolor={0,0,127}));
      connect(switch2.u1, T_engine) annotation (points=[42,-62; 42,-80; 120,-80;
            120,-112], style(color=74, rgbcolor={0,0,127}));
      connect(switch2.u3, const.y) annotation (points=[58,-62; 58,-90; -109,-90],
          style(color=74, rgbcolor={0,0,127}));
      connect(switch2.y, torque1.tau) annotation (points=[50,-39; 50,-28],
          style(color=74, rgbcolor={0,0,127}));
      connect(w, w) annotation (points=[140,-10; 140,-10], style(color=74,
            rgbcolor={0,0,127}));
      connect(switch1.u1, T_Steering) annotation (points=[-42,-42; -56,-42; -56,
            -66; 0,-66; 0,-112], style(color=74, rgbcolor={0,0,127}));
      connect(angleSensor.phi, steer_angle) annotation (points=[10,-40; 10,-80;
            -52,-80; -52,-110], style(
          color=74,
          rgbcolor={0,0,127},
          pattern=0,
          fillColor=7,
          rgbfillColor={255,255,255},
          fillPattern=1));
      connect(CoM_RearFrame, CoM_RearFrame) annotation (points=[128,78; 128,78],
          style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(RearMassPos.frame_b, CoM_RearFrame) annotation (points=[90,59; 90,
            64; 112,64; 112,78; 128,78], style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2,
          fillColor=7,
          rgbfillColor={255,255,255},
          fillPattern=1));
      connect(RWRevolute.frame_a, RearMassPos.frame_a) annotation (points=[90,
            11; 90,37], style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(RearFrame.frame_b, RWRevolute.frame_a) annotation (points=[71,28;
            90,28; 90,11], style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(RWRevolute.frame_b, connectRW) annotation (points=[90,-11; 90,-50;
            128,-50], style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(torque1.flange_b, RWRevolute.axis) annotation (points=[50,-7; 68,
            -7; 68,-7; 83,-7], style(color=0, rgbcolor={0,0,0}));
      connect(speedSensor.flange_a, RWRevolute.axis) annotation (points=[74,-20;
            74,-7; 83,-7], style(color=0, rgbcolor={0,0,0}));
    end Motorcycle_Vittore_3dof;

    function CalculateEigenvaluesMotorcycle
      "Stability analysis of an uncontrolled motorcycle, plots eigenvalues as a function of motorcycles's forward velocity"

      extends Modelica.Icons.Function;
      input String modelName;
      input String independentVariableName;
      input Real startValue "lowest velocity";
      input Real endValue "highest velocity";
      input Integer number_of_values;

    input Real states[4] = {3, 4, 11, 13}
        "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

      input Integer plotSignals = 0
        "|Signals to plot| 0 ... real and imaginary eigenvalues; 1 ... real eigenvalues; 2 ... imaginary eigenvalues";

    protected
      Boolean hd = LinearSystems.Internal.SetHideDymosim();
      Boolean OK=linearizeModel(modelName);
      Real[number_of_values] values = linspace(startValue, endValue, number_of_values);

      Real nxMat[1, 1] = readMatrix("dslin.mat", "nx", 1, 1);
      Integer ABCDsizes[2] = readMatrixSize("dslin.mat", "ABCD");
      Integer nx = integer(nxMat[1, 1]);
      Integer nu = ABCDsizes[2] - nx;
      Integer ny = ABCDsizes[1] - nx;

      LinearSystems.StateSpace ABCD(
        nx = nx,
        ny = ny,
        nu = nu);

      /* Matrix which includes the relevant statevariables to compute the Eingenvalues
     Simulation window: type importInitial() then linearize the model and open the function "dslin.mat"
     type xuyName to get the selceted StateVariables */
      Real Arelevant[4,4];
      Real EigenValuesi[4, 2] = fill(0, 4, 2);
      Real EV_history[4,number_of_values] = fill(0, 4, number_of_values);
      Real EV_history_imag[4,number_of_values] = fill(0, 4, number_of_values);
      Real EV_real[4];
      Real EV_imag[4];
      Real EV_sort[4];
      Real EV_sort_imag[4];

      Integer n;
      Integer k;
      Integer m;

      String stateNames[nx] "Number of system states";
      Integer window = 0;
      Boolean status = animationOnline(loadInterval=  0.05);

    algorithm
      // plot settings
      window := createPlot(id=  1,
                           position=   {2, 3, 750, 450},
                           y=   fill("", 0),
                           heading=  "Eigenvalue Analysis",
                           range=  {(-2.0), 12.0, 6.0, (-10.0)},
                           autoscale=  false,
                           autoerase=  false,
                           autoreplot=  true,
                           description=  false,
                           grid=  true,
                           color=  true,
                           online=  false,
                           legendLocation=  5,
                           legendHorizontal=  false,
                           leftTitle=  "Real, Imaginary Eigenvalues",
                           bottomTitle=  "Velocity [m/s]");

      ABCD := LinearSystems.linearize(modelName);
      EV_sort :={0,0,0,0};
      for i in 1:number_of_values loop
        SetVariable(independentVariableName, values[i]);
        OK := linearizeModel(modelName);
        if OK then
          ABCD := LinearSystems.readStateSpace("dslin.mat");
          stateNames := ABCD.xNames;

          /* Select the relevant states for the stability analysis
         here: Arelevant = {steer angle, steer rate, lean angle, lean rate, rider lean angle, rider lean rate} */
          Arelevant := (ABCD.A)[states, states];
          EigenValuesi := Modelica.Math.Matrices.eigenValues(Arelevant);
          // Eigenvalues are stored in two separate vectors
          EV_real := EigenValuesi[:, 1];
          EV_imag := EigenValuesi[:, 2];

          // control variables
          k := 0;
          m := 1;

          n :=size(EV_imag, 1);

          /* Remark:
           Since the function Modelica.Math.Matrices.eigenValues() orders the Eigenvalues not always in the same way it is
           necessary to re-order the Eigenvalues stored in the Eigenvalue-Vector EigenValuesi.
         Algorithm:
           1. check whether the eigenvalues include imaginary parts
             -> if an imaginary part appears, store the values in the last row of the vector EV_sort and EV_sort_imag
             -> else store the eigenvalues in ascending order
           2. sort the values in ascending order
             -> if all elements of EV_imag are zero sort all rows
             -> else (if imaginary parts appear) sort the first four rows and leave the remaining rows unchanged
       */

          // Part 1
          for j in 1:n loop
            if EV_imag[j] <> 0 then
              EV_sort[n-k] := EV_real[j];
              // build also a new vector which stores the imaginary values <> 0
              EV_sort_imag[n-k] := EV_imag[j];
              k := k+1;
              //p := i;
            else
              EV_sort[m] := EV_real[j];
              EV_sort_imag[m] := EV_imag[j];
              m := m+1;
            end if;
          end for;

          // Part 2
          if EV_imag[1] == 0 and EV_imag[2] == 0 and EV_imag[3] == 0 and EV_imag[4] == 0 then
             EV_history[:, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort);
             EV_history_imag[3:4, i] := EV_sort_imag[3:4];
          else
            EV_history[1:2, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort[1:2]);
            EV_history[3:4, i] := EV_sort[3:4];
            EV_history_imag[3:4,i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort_imag[3:4]);
          end if;

        end if;
      end for;

       if plotSignals == 0 then
         // plot the real eigenvalues
         plotArrays(x= values[1:number_of_values],
                   y= transpose(EV_history[:,1:number_of_values]),
                   title= "Eigenvalue Analysis",
                   legend= {"castering mode", "capsize mode", "Re(weave mode)", "Re(weave mode)"},
                   style= {0});

         // plot the imaginary eigenvalues
         plotArrays(x= values[1:number_of_values],
                   y= transpose(EV_history_imag[3:4,1:number_of_values]),
                   title= "Eigenvalue Analysis",
                   legend= {"Im(weave mode)", "Im(weave mode)"},
                   style= {1});
        elseif plotSignals == 1 then
          plotArrays(x= values[1:number_of_values],
                   y= transpose(EV_history[:,1:number_of_values]),
                   title= "Eigenvalue Analysis",
                   legend= {"castering mode", "capsize mode", "Re(weave mode)", "Re(weave mode)"},
                   style= {0});
        else
          plotArrays(x= values[1:number_of_values],
                   y= transpose(EV_history_imag[3:4,1:number_of_values]),
                   title= "Eigenvalue Analysis",
                   legend= {"Im(weave mode)", "Im(weave mode)"},
                   style= {1});
        end if;

      writeMatrix("stability.mat","eigenvalues",[values,transpose(EV_history[:,:])]);
      Advanced.HideDymosim := hd;

    end CalculateEigenvaluesMotorcycle;

  end BasicMotorcycle;

  package AdvancedMotorcycle
    "11 d.o.f. motorcycle models; SL2001 and an improved version of it"

    package Parts

      package FrontFrames "Several different front frames are provided"
        model FrontFrame
          "Front Frame with additional twist axis and elasto gap"

          import SI = Modelica.SIunits;
          import CO = Modelica.SIunits.Conversions;
          import PI = Modelica.Constants.pi;
          import MB = Modelica.Mechanics.MultiBody;

          parameter SI.Distance w = 1 "wheelbase of the motorcycle";
          parameter SI.Distance R_fw = 1 "Front wheel Radius";
          parameter SI.Distance R_rw = 1
            "Rear wheel radius - in order to calculate the correct spring length";

          parameter Real c(
            final unit="N/m",
            final min=0) = 1 "Spring constant of the front suspension";

          parameter Real d(
            final unit="N/(m/s)",
            final min=0) = 0 "Damping constant of the front suspension";

          parameter Real ds(
            final unit="N/(m/s)",
            final min=0) = 0 "Steering damper";

          parameter Real ctw(
            final unit="N.m/rad",
            final min=0) = 1 "Twist axis stiffness";

          parameter Real dtw(
            final unit="N.m/(rad/s)",
            final min=0) = 0 "Twist axis damping constant";

          parameter CO.NonSIunits.Angle_deg epsilon = 0 "Steering head angle";
          final parameter SI.Angle epsilon_rad = CO.from_deg(epsilon);
          final parameter SI.Position n[3] = {sin(epsilon_rad),cos(epsilon_rad),0}
            "direction of steering axis";

          final parameter SI.Position ntw[3] = {sin(PI/2-epsilon_rad),-cos(PI/2-epsilon_rad),0};

          // The length of the spring and the translation element between spring and front wheel center point
          // are calcutalted by means of p4
          parameter SI.Position p2[3] = {1,1,0} "Steering axis co-ordinate";
          parameter SI.Position p3[3] = {0,0,0} "Center of mass front frame";
          parameter SI.Position p4[3] = {1,1,0}
            "Joint co-ordinate for front supsension and steer body";
          parameter SI.Position p5[3] = {0,0,0}
            "Center of mass front suspension";

          //final parameter SI.Position p6[3] = {w, R_fw,0};
          //final parameter SI.Distance s_rel0 = sqrt( (p6[1]-p4[1])*(p6[1]-p4[1]) + (p6[2]-p4[2])*(p6[2]-p4[2]))
          //  "Unstretched spring length";
          final parameter SI.Distance s_rel0 = sqrt( (w-p4[1])*(w-p4[1]) + (R_rw-p4[2])*(R_rw-p4[2]))
            "Unstretched spring length";
          parameter SI.Distance bias = 0.3 "Pre-load of the spring";

          parameter SI.Distance offset = 0
            "Perpendicular distance between steering axis and front wheel center point";
          final parameter SI.Distance offset_vector[3] = {cos(epsilon_rad)*offset, -sin(epsilon_rad)*offset, 0};

          final parameter SI.Position p2_offset[3] = {p2[1]+cos(epsilon_rad)*offset, p2[2]+sin(epsilon_rad)*offset, 0};
          final parameter SI.Distance r[3] = {p4[1] - p2_offset[1], p2_offset[2] - p4[2], 0}
            "Front Fork length (without front supsension)";

        // TAB: Intertia Tensor - Front Suspension
          parameter SI.Mass mFS = 1 "mass of front suspension";
          final parameter SI.Distance CoM_FS[3] = {p5[1] - p2_offset[1], p2_offset[2] - p5[2], 0};

          parameter SI.Inertia I_FS_11=0.001
            "|Inertia tensor of the Front Suspension|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_FS_22=0.001
            "|Inertia tensor of the Front Suspension|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_FS_33=0.001
            "|Inertia tensor of the Front Suspension|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_FS_21=0
            "|Inertia tensor of the Front Suspension|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_FS_31=0
            "|Inertia tensor of the Front Suspension|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_FS_32=0
            "|Inertia tensor of the Front Suspension|| (3,2) element of inertia tensor";

          parameter SI.Mass mFF = 1 "mass of front frame";
          // Since the CoM of the Front Frame is rigidly attached to p2 the difference is calculated w.r.t p2
          // final parameter SI.Distance CoM_FF[3] = {w - p3[1], p3[2] - R_fw, 0};
          final parameter SI.Distance CoM_FF[3] = {p2_offset[1] - p3[1], p3[2] - p2_offset[2], 0};

        // TAB: Intertia Tensor - Front Frame
          parameter SI.Inertia I_FF_11=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_FF_22=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_FF_33=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_FF_21=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_FF_31=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_FF_32=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,2) element of inertia tensor";

        // TAB: Initial Conditions
          parameter CO.NonSIunits.Angle_deg init_steerAngle = 0
            "|Initial Conditions||initial steer angle";

          // Animation
        public
          parameter SI.Angle handlebarAngle = 65
            "|Animation || angle of the handlebar";
        protected
          final parameter SI.Angle handlebarAngleRad = SI.Conversions.from_deg(handlebarAngle);
        public
          parameter MB.Types.Color HandleBarColor = {155,155,155}
            "|Animation || Color of the HandleBar";
          parameter MB.Types.Color HandleColor = {55,55,55}
            "|Animation || Color of the HandleBar";

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            ForkPipe1_Right(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection=Steering.n,
            r_shape={0,0,0.11},
            length=0.2,
            width=0.05,
            height=0.05,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            ForkPipe1_Left(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection=Steering.n,
            r_shape={0,0,-0.11},
            length=0.2,
            width=0.05,
            height=0.05,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe2(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection={0,0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,-0.17},
            length=0.34,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleRight(
            shapeType="cylinder",
            color=HandleColor,
            lengthDirection={0.3,0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,0.17},
            length=0.2,
             r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleLeft(
            shapeType="cylinder",
            color=HandleColor,
            lengthDirection={-0.3,-0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,-0.17},
            length=-0.2,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          MultiBondLib.Mechanics3D.Interfaces.Frame_b SteeringAxis
            annotation (extent=[36,18; 64,62]);
          annotation (Diagram(
              Line(points=[100,-50; 100,-50], style(color=83, rgbcolor={255,85,
                      255})),
              Line(points=[66,-50; 80,-50],   style(color=83, rgbcolor={255,85,
                      255})),
        Rectangle(extent=[80,-40; 100,-60], style(color=83, rgbcolor={255,85,255})),
        Text(
        extent=[80,-40; 100,-60],
        style(color=83, rgbcolor={255,85,255}),
        string="Connected?")), Icon(
              Text(extent=[-152,50; -54,-26], string="%name"),
              Rectangle(extent=[40,-84; 26,100], style(
                  color=2,
                  rgbcolor={0,255,0},
                  gradient=1,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[80,88; 40,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95})),
              Rectangle(extent=[-26,80; 26,0],  style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=3,
                  rgbfillColor={0,0,255})),
              Text(
                extent=[-20,-90; 20,-50],
                string="a",
                style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=1,
                  fillColor=42,
                  rgbfillColor={127,0,0})),
              Text(
                extent=[-18,20; 22,60],
                style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=1,
                  fillColor=42,
                  rgbfillColor={127,0,0}),
                string="b"),
              Rectangle(extent=[-26,-84; -40,100], style(
                  color=2,
                  rgbcolor={0,255,0},
                  gradient=1,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[26,88; -26,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[-40,88; -80,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=10)),
              Line(points=[-52,-8; -40,-14], style(color=45, rgbcolor={255,128,0})),
              Line(points=[-52,-8; -26,2], style(color=45, rgbcolor={255,128,0})),
              Line(points=[-26,-20; -14,-24], style(color=45, rgbcolor={255,128,0})),
              Line(points=[-14,-24; -52,-38; -40,-44], style(color=45, rgbcolor={
                      255,128,0})),
              Line(points=[-26,-50; -16,-54; -52,-68; -40,-74], style(color=45,
                    rgbcolor={255,128,0})),
              Line(points=[14,-8; 40,2], style(color=45, rgbcolor={255,128,0})),
              Line(points=[14,-8; 26,-14], style(color=45, rgbcolor={255,128,0})),
              Line(points=[40,-20; 52,-24], style(color=45, rgbcolor={255,128,0})),
              Line(points=[52,-24; 14,-38; 26,-44], style(color=45, rgbcolor={255,
                      128,0})),
              Line(points=[40,-50; 50,-54; 14,-68; 26,-74], style(color=45,
                    rgbcolor={255,128,0}))),
            Coordsys(scale=0.2, extent=[-100,-100; 100,100]));

          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontSuspensions.FrontSuspensionClassic
            frontSuspension(
            c=c,
            d=d,
            s_rel0=s_rel0,
            r=r,
            n=n,
            m=mFS,
            I_11=I_FS_11,
            I_22=I_FS_22,
            I_33=I_FS_33,
            I_21=I_FS_21,
            I_31=I_FS_31,
            I_32=I_FS_32,
            CoM_FS=CoM_FS,
            bias=bias)    annotation (extent=[-80,-30; -60,-10],rotation=90);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation FixedTranslation(
                               r=CoM_FF, animation=false)
                                                   annotation (extent=[-100,10;
                -80,30],
              rotation=90);
          MultiBondLib.Mechanics3D.Parts.SimpleBody Mass(
            sphereDiameter=0.1,
            animation=true,
            m=mFF,
            I_11=I_FF_11,
            I_22=I_FF_22,
            I_33=I_FF_33,
            I_21=I_FF_21,
            I_31=I_FF_31,
            I_32=I_FF_32)
                 annotation (extent=[-100,50; -80,70],rotation=90);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute Steering(
            cylinderLength=0.10,
            cylinderDiameter=0.07,
            cylinderColor={100,100,100},
            n=n,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
            enforceStates=true,
            phi_start=init_steerAngle,
            animation=true)
            annotation (extent=[-10,44; 10,64]);
          BondLib.Mechanical.Rotational.Passive.Damper damper(d=ds)
            annotation (extent=[-10,24; 10,44],  rotation=180);
          MultiBondLib.Mechanics3D.Joints.Revolute FWRevolute(
            phi(stateSelect=StateSelect.always),
            phi_start=0,
            animation=true,
            cylinderDiameter=0.08,
            cylinderColor={255,0,0},
            initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
            cylinderLength=0.2,
            enforceStates=true)
            annotation (extent=[-80,-60; -60,-40], rotation=90);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation
            FixedTranslation_Offset(
              animation=true, r=offset_vector)     annotation (extent=[-80,10;
                -60,30],
              rotation=90);
          MultiBondLib.Mechanics3D.Interfaces.Frame_a RevoltueAxis
            annotation (extent=[-30,-115; 30,-85], rotation=90);
          BondLib.Mechanical.Rotational.Sources.Torque SteeringTorque
            annotation (extent=[18,-20; 38,0],   rotation=90);
          Modelica.Blocks.Interfaces.RealInput T_Steering
            annotation (extent=[-16,80; 16,110], rotation=270);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute TwistAxis(n=ntw,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            animation=false,
            enforceStates=true)
            annotation (extent=[-50,44; -30,64]);
          BondLib.Mechanical.Rotational.Passive.Damper damper1(d=dtw)
            annotation (extent=[-50,24; -30,44],rotation=180);
          BondLib.Mechanical.Rotational.Passive.Spring spring(c=ctw)
            annotation (extent=[-50,2; -30,22],  rotation=180);
          BondLib.Mechanical.Rotational.Sensors.AngleSensor angleSensor
            annotation (extent=[0,8; 20,28],  rotation=270);
          Modelica.Blocks.Interfaces.RealOutput y
            annotation (extent=[-10,-20; 10,0], rotation=270);
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (extent=[100,-90; 80,-70], rotation=0);
          Modelica.Blocks.Logical.Switch switch1
            annotation (extent=[60,-60; 40,-40]);
        equation
         if cardinality(T_Steering) <= 1 then
            T_Steering = 0;
            switch1.u2 = false;
          else
            switch1.u2 = true;
          end if;
          connect(SteeringAxis, SteeringAxis) annotation (points=[50,40; 50,40],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Mass.frame_a,FixedTranslation. frame_b)            annotation (
              points=[-90,49; -90,31], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=10,
              rgbfillColor={95,95,95}));
          connect(damper.flange_a,Steering. axis) annotation (points=[10,34; 10,
                47; 7,47],
                       style(color=0, rgbcolor={0,0,0}));
          connect(damper.flange_b,Steering. bearing) annotation (points=[-10,34;
                -10,47; -7,47],
                         style(color=0, rgbcolor={0,0,0}));
          connect(SteeringTorque.flange_b, damper.flange_a) annotation (points=[28,0; 28,
                34; 10,34],                    style(color=0, rgbcolor={0,0,0}));
          connect(FWRevolute.frame_a, RevoltueAxis) annotation (points=[-70,-61;
                -70,-72; 0,-72; 0,-100],
                                style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(FixedTranslation.frame_a, frontSuspension.SteeringAxis)
            annotation (points=[-90,9; -90,0; -70,0; -70,-9.2], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(damper1.flange_b, TwistAxis.bearing) annotation (points=[-50,34;
                -50,47; -47,47], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(damper1.flange_a, TwistAxis.axis) annotation (points=[-30,34;
                -30,47; -33,47], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(TwistAxis.frame_b, Steering.frame_a) annotation (points=[-29,54;
                -11,54],style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(TwistAxis.frame_a, FixedTranslation_Offset.frame_b) annotation (
             points=[-51,54; -70,54; -70,31], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(spring.flange_b, damper1.flange_b) annotation (points=[-50,12;
                -50,34], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(spring.flange_a, damper1.flange_a) annotation (points=[-30,12;
                -30,34], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(angleSensor.flange_a, damper.flange_a) annotation (points=[10,28;
                10,31; 10,31; 10,34],     style(color=0, rgbcolor={0,0,0}));
          connect(angleSensor.phi, y) annotation (points=[10,8; 10,4; 0,4; 0,
                -10],
              style(color=74, rgbcolor={0,0,127}));
          connect(y, y) annotation (points=[0,-10; 0,-10], style(color=74,
                rgbcolor={0,0,127}));
          connect(const.y, switch1.u3) annotation (points=[79,-80; 72,-80; 72,-58;
                62,-58], style(color=74, rgbcolor={0,0,127}));
          connect(T_Steering, switch1.u1) annotation (points=[0,95; 0,72; 72,72;
                72,-42; 62,-42], style(color=74, rgbcolor={0,0,127}));
          connect(switch1.y, SteeringTorque.tau) annotation (points=[39,-50; 28,
                -50; 28,-21], style(color=74, rgbcolor={0,0,127}));
          connect(Steering.frame_b, SteeringAxis) annotation (points=[11,54; 22,
                54; 22,40; 50,40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(frontSuspension.SteeringAxis, FixedTranslation_Offset.frame_a)
            annotation (points=[-70,-9.2; -70,9], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
          connect(frontSuspension.FrontWheel, FWRevolute.frame_b) annotation (
              points=[-70,-30.8; -70,-39], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
        end FrontFrame;

        model FrontFramePreload
          "Front Frame with additional twist axis and elasto gap"

          import SI = Modelica.SIunits;
          import CO = Modelica.SIunits.Conversions;
          import PI = Modelica.Constants.pi;
          import MB = Modelica.Mechanics.MultiBody;

          parameter SI.Distance w = 1 "wheelbase of the motorcycle";
          parameter SI.Distance R_fw = 1 "Front wheel Radius";
          parameter SI.Distance R_rw = 1
            "Rear wheel radius - in order to calculate the correct spring length";

          parameter Real c(
            final unit="N/m",
            final min=0) = 1 "Spring constant of the front suspension";

          parameter Real d(
            final unit="N/(m/s)",
            final min=0) = 0 "Damping constant of the front suspension";

          parameter Real ds(
            final unit="N/(m/s)",
            final min=0) = 0 "Steering damper";

          parameter Real ctw(
            final unit="N.m/rad",
            final min=0) = 1 "Twist axis stiffness";

          parameter Real dtw(
            final unit="N.m/(rad/s)",
            final min=0) = 0 "Twist axis damping constant";

          parameter CO.NonSIunits.Angle_deg epsilon = 0 "Steering head angle";
          final parameter SI.Angle epsilon_rad = CO.from_deg(epsilon);
          final parameter SI.Position n[3] = {sin(epsilon_rad),cos(epsilon_rad),0}
            "direction of steering axis";

          final parameter SI.Position ntw[3] = {sin(PI/2-epsilon_rad),-cos(PI/2-epsilon_rad),0};

          // The length of the spring and the translation element between spring and front wheel center point
          // are calcutalted by means of p4
          parameter SI.Position p2[3] = {1,1,0} "Steering axis co-ordinate";
          parameter SI.Position p3[3] = {0,0,0} "Center of mass front frame";
          parameter SI.Position p4[3] = {1,1,0}
            "Joint co-ordinate for front supsension and steer body";
          parameter SI.Position p5[3] = {0,0,0}
            "Center of mass front suspension";

          //final parameter SI.Position p6[3] = {w, R_fw,0};
          //final parameter SI.Distance s_rel0 = sqrt( (p6[1]-p4[1])*(p6[1]-p4[1]) + (p6[2]-p4[2])*(p6[2]-p4[2]))
          //  "Unstretched spring length";
          final parameter SI.Distance s_rel0 = sqrt( (w-p4[1])*(w-p4[1]) + (R_rw-p4[2])*(R_rw-p4[2]))
            "Unstretched spring length";
          //parameter SI.Distance bias = 0.3 "Pre-load of the spring";
          parameter SI.Force preload = 0 "Front suspension preload";
          parameter SI.Distance dmax = 0.03
            "Displacement of lower suspension from nominal to give rebound stop contace";
          parameter SI.Distance dmin = 0.07
            "Corresponding bump displacement for bump stop contace";

          parameter SI.Distance offset = 0
            "Perpendicular distance between steering axis and front wheel center point";
          final parameter SI.Distance offset_vector[3] = {cos(epsilon_rad)*offset, -sin(epsilon_rad)*offset, 0};

          final parameter SI.Position p2_offset[3] = {p2[1]+cos(epsilon_rad)*offset, p2[2]+sin(epsilon_rad)*offset, 0};
          final parameter SI.Distance r[3] = {p4[1] - p2_offset[1], p2_offset[2] - p4[2], 0}
            "Front Fork length (without front supsension)";

        // TAB: Intertia Tensor - Front Suspension
          parameter SI.Mass mFS = 1 "mass of front suspension";
          final parameter SI.Distance CoM_FS[3] = {p5[1] - p2_offset[1], p2_offset[2] - p5[2], 0};

          parameter SI.Inertia I_FS_11=0.001
            "|Inertia tensor of the Front Suspension|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_FS_22=0.001
            "|Inertia tensor of the Front Suspension|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_FS_33=0.001
            "|Inertia tensor of the Front Suspension|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_FS_21=0
            "|Inertia tensor of the Front Suspension|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_FS_31=0
            "|Inertia tensor of the Front Suspension|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_FS_32=0
            "|Inertia tensor of the Front Suspension|| (3,2) element of inertia tensor";

          parameter SI.Mass mFF = 1 "mass of front frame";
          // Since the CoM of the Front Frame is rigidly attached to p2 the difference is calculated w.r.t p2
          // final parameter SI.Distance CoM_FF[3] = {w - p3[1], p3[2] - R_fw, 0};
          final parameter SI.Distance CoM_FF[3] = {p2_offset[1] - p3[1], p3[2] - p2_offset[2], 0};

        // TAB: Intertia Tensor - Front Frame
          parameter SI.Inertia I_FF_11=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_FF_22=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_FF_33=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_FF_21=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_FF_31=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_FF_32=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,2) element of inertia tensor";

        // TAB: Initial Conditions
          parameter CO.NonSIunits.Angle_deg init_steerAngle = 0
            "|Initial Conditions||initial steer angle";

          // Animation
        public
          parameter SI.Angle handlebarAngle = 65
            "|Animation || angle of the handlebar";
        protected
          final parameter SI.Angle handlebarAngleRad = SI.Conversions.from_deg(handlebarAngle);
        public
          parameter MB.Types.Color HandleBarColor = {155,155,155}
            "|Animation || Color of the HandleBar";
          parameter MB.Types.Color HandleColor = {55,55,55}
            "|Animation || Color of the HandleBar";

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            ForkPipe1_Right(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection=Steering.n,
            r_shape={0,0,0.11},
            length=0.2,
            width=0.05,
            height=0.05,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            ForkPipe1_Left(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection=Steering.n,
            r_shape={0,0,-0.11},
            length=0.2,
            width=0.05,
            height=0.05,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe2(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection={0,0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,-0.17},
            length=0.34,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleRight(
            shapeType="cylinder",
            color=HandleColor,
            lengthDirection={0.3,0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,0.17},
            length=0.2,
             r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleLeft(
            shapeType="cylinder",
            color=HandleColor,
            lengthDirection={-0.3,-0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,-0.17},
            length=-0.2,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          MultiBondLib.Mechanics3D.Interfaces.Frame_b SteeringAxis
            annotation (extent=[36,18; 64,62]);
          annotation (Diagram(
              Line(points=[100,-50; 100,-50], style(color=83, rgbcolor={255,85,
                      255})),
              Line(points=[66,-50; 80,-50],   style(color=83, rgbcolor={255,85,
                      255})),
        Rectangle(extent=[80,-40; 100,-60], style(color=83, rgbcolor={255,85,255})),
        Text(
        extent=[80,-40; 100,-60],
        style(color=83, rgbcolor={255,85,255}),
        string="Connected?")), Icon(
              Text(extent=[-152,50; -54,-26], string="%name"),
              Rectangle(extent=[40,-84; 26,100], style(
                  color=2,
                  rgbcolor={0,255,0},
                  gradient=1,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[80,88; 40,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95})),
              Rectangle(extent=[-26,80; 26,0],  style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=3,
                  rgbfillColor={0,0,255})),
              Text(
                extent=[-20,-90; 20,-50],
                string="a",
                style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=1,
                  fillColor=42,
                  rgbfillColor={127,0,0})),
              Text(
                extent=[-18,20; 22,60],
                style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=1,
                  fillColor=42,
                  rgbfillColor={127,0,0}),
                string="b"),
              Rectangle(extent=[-26,-84; -40,100], style(
                  color=2,
                  rgbcolor={0,255,0},
                  gradient=1,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[26,88; -26,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[-40,88; -80,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=10)),
              Line(points=[-52,-8; -40,-14], style(color=78, rgbcolor={127,0,
                      127})),
              Line(points=[-52,-8; -26,2], style(color=78, rgbcolor={127,0,127})),
              Line(points=[-26,-20; -14,-24], style(color=78, rgbcolor={127,0,
                      127})),
              Line(points=[-14,-24; -52,-38; -40,-44], style(color=78, rgbcolor=
                     {127,0,127})),
              Line(points=[-26,-50; -16,-54; -52,-68; -40,-74], style(color=78,
                    rgbcolor={127,0,127})),
              Line(points=[14,-8; 40,2], style(color=78, rgbcolor={127,0,127})),
              Line(points=[14,-8; 26,-14], style(color=78, rgbcolor={127,0,127})),
              Line(points=[40,-20; 52,-24], style(color=78, rgbcolor={127,0,127})),
              Line(points=[52,-24; 14,-38; 26,-44], style(color=78, rgbcolor={
                      127,0,127})),
              Line(points=[40,-50; 50,-54; 14,-68; 26,-74], style(color=78,
                    rgbcolor={127,0,127}))),
            Coordsys(scale=0.2, extent=[-100,-100; 100,100]));

          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontSuspensions.FrontSuspensionClassicPreload
            frontSuspension(
            c=c,
            d=d,
            s_rel0=s_rel0,
            r=r,
            n=n,
            m=mFS,
            I_11=I_FS_11,
            I_22=I_FS_22,
            I_33=I_FS_33,
            I_21=I_FS_21,
            I_31=I_FS_31,
            I_32=I_FS_32,
            CoM_FS=CoM_FS,
            preload=preload,
            dmax=dmax,
            dmin=dmin)    annotation (extent=[-80,-30; -60,-10],rotation=90);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation FixedTranslation(
                               r=CoM_FF, animation=false)
                                                   annotation (extent=[-100,10;
                -80,30],
              rotation=90);
          MultiBondLib.Mechanics3D.Parts.SimpleBody Mass(
            sphereDiameter=0.1,
            animation=true,
            m=mFF,
            I_11=I_FF_11,
            I_22=I_FF_22,
            I_33=I_FF_33,
            I_21=I_FF_21,
            I_31=I_FF_31,
            I_32=I_FF_32)
                 annotation (extent=[-100,50; -80,70],rotation=90);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute Steering(
            cylinderLength=0.10,
            cylinderDiameter=0.07,
            cylinderColor={100,100,100},
            n=n,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
            enforceStates=true,
            phi_start=init_steerAngle,
            animation=true)
            annotation (extent=[-10,44; 10,64]);
          BondLib.Mechanical.Rotational.Passive.Damper damper(d=ds)
            annotation (extent=[-10,24; 10,44],  rotation=180);
          MultiBondLib.Mechanics3D.Joints.Revolute FWRevolute(
            phi(stateSelect=StateSelect.always),
            phi_start=0,
            animation=true,
            cylinderDiameter=0.08,
            cylinderColor={255,0,0},
            initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
            cylinderLength=0.2,
            enforceStates=true)
            annotation (extent=[-80,-60; -60,-40], rotation=90);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation
            FixedTranslation_Offset(
              animation=true, r=offset_vector)     annotation (extent=[-80,10;
                -60,30],
              rotation=90);
          MultiBondLib.Mechanics3D.Interfaces.Frame_a RevoltueAxis
            annotation (extent=[-30,-115; 30,-85], rotation=90);
          BondLib.Mechanical.Rotational.Sources.Torque SteeringTorque
            annotation (extent=[18,-20; 38,0],   rotation=90);
          Modelica.Blocks.Interfaces.RealInput T_Steering
            annotation (extent=[-16,80; 16,110], rotation=270);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute TwistAxis(n=ntw,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            animation=false,
            enforceStates=true)
            annotation (extent=[-50,44; -30,64]);
          BondLib.Mechanical.Rotational.Passive.Damper damper1(d=dtw)
            annotation (extent=[-50,24; -30,44],rotation=180);
          BondLib.Mechanical.Rotational.Passive.Spring spring(c=ctw)
            annotation (extent=[-50,2; -30,22],  rotation=180);
          BondLib.Mechanical.Rotational.Sensors.AngleSensor angleSensor
            annotation (extent=[0,8; 20,28],  rotation=270);
          Modelica.Blocks.Interfaces.RealOutput y
            annotation (extent=[-10,-20; 10,0], rotation=270);
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (extent=[100,-90; 80,-70], rotation=0);
          Modelica.Blocks.Logical.Switch switch1
            annotation (extent=[60,-60; 40,-40]);
        equation
         if cardinality(T_Steering) <= 1 then
            T_Steering = 0;
            switch1.u2 = false;
          else
            switch1.u2 = true;
          end if;
          connect(SteeringAxis, SteeringAxis) annotation (points=[50,40; 50,40],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Mass.frame_a,FixedTranslation. frame_b)            annotation (
              points=[-90,49; -90,31], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=10,
              rgbfillColor={95,95,95}));
          connect(damper.flange_a,Steering. axis) annotation (points=[10,34; 10,
                47; 7,47],
                       style(color=0, rgbcolor={0,0,0}));
          connect(damper.flange_b,Steering. bearing) annotation (points=[-10,34;
                -10,47; -7,47],
                         style(color=0, rgbcolor={0,0,0}));
          connect(SteeringTorque.flange_b, damper.flange_a) annotation (points=[28,0; 28,
                34; 10,34],                    style(color=0, rgbcolor={0,0,0}));
          connect(FWRevolute.frame_a, RevoltueAxis) annotation (points=[-70,-61;
                -70,-72; 0,-72; 0,-100],
                                style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(damper1.flange_b, TwistAxis.bearing) annotation (points=[-50,34;
                -50,47; -47,47], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(damper1.flange_a, TwistAxis.axis) annotation (points=[-30,34;
                -30,47; -33,47], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(TwistAxis.frame_b, Steering.frame_a) annotation (points=[-29,54;
                -11,54],style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(TwistAxis.frame_a, FixedTranslation_Offset.frame_b) annotation (
             points=[-51,54; -70,54; -70,31], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(spring.flange_b, damper1.flange_b) annotation (points=[-50,12;
                -50,34], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(spring.flange_a, damper1.flange_a) annotation (points=[-30,12;
                -30,34], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(angleSensor.flange_a, damper.flange_a) annotation (points=[10,28;
                10,31; 10,31; 10,34],     style(color=0, rgbcolor={0,0,0}));
          connect(angleSensor.phi, y) annotation (points=[10,8; 10,4; 0,4; 0,
                -10],
              style(color=74, rgbcolor={0,0,127}));
          connect(y, y) annotation (points=[0,-10; 0,-10], style(color=74,
                rgbcolor={0,0,127}));
          connect(const.y, switch1.u3) annotation (points=[79,-80; 72,-80; 72,-58;
                62,-58], style(color=74, rgbcolor={0,0,127}));
          connect(T_Steering, switch1.u1) annotation (points=[0,95; 0,72; 72,72;
                72,-42; 62,-42], style(color=74, rgbcolor={0,0,127}));
          connect(switch1.y, SteeringTorque.tau) annotation (points=[39,-50; 28,
                -50; 28,-21], style(color=74, rgbcolor={0,0,127}));
          connect(Steering.frame_b, SteeringAxis) annotation (points=[11,54; 22,
                54; 22,40; 50,40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(frontSuspension.SteeringAxis, FixedTranslation_Offset.frame_a)
            annotation (points=[-70,-9.2; -70,9], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=10,
              rgbfillColor={135,135,135},
              fillPattern=1));
          connect(frontSuspension.SteeringAxis, FixedTranslation.frame_a)
            annotation (points=[-70,-9.2; -70,0; -90,0; -90,9], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=10,
              rgbfillColor={135,135,135},
              fillPattern=1));
          connect(frontSuspension.FrontWheel, FWRevolute.frame_b) annotation (
              points=[-70,-30.8; -70,-39], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=10,
              rgbfillColor={135,135,135},
              fillPattern=1));
        end FrontFramePreload;

        model FrontFrame_Ind
          "Front Frame with additional twist axis and elasto gap"

          import SI = Modelica.SIunits;
          import CO = Modelica.SIunits.Conversions;
          import PI = Modelica.Constants.pi;
          import MB = Modelica.Mechanics.MultiBody;

          parameter SI.Distance w = 1 "wheelbase of the motorcycle";
          parameter SI.Distance R_fw = 1 "Front wheel Radius";
          parameter SI.Distance R_rw = 1
            "Rear wheel radius - in order to calculate the correct spring length";

          parameter Real spring_table[:,:] = [0,0; 1,1]
            "Spring characteristics of the front suspension";
          parameter Real damper_table[:,:] = [0,0; 1,1]
            "Damper characteristics of the front suspension";

          parameter Real ds(
            final unit="N/(m/s)",
            final min=0) = 0 "Steering damper";

          parameter Real ctw(
            final unit="N.m/rad",
            final min=0) = 1 "Twist axis stiffness";

          parameter Real dtw(
            final unit="N.m/(rad/s)",
            final min=0) = 0 "Twist axis damping constant";

          parameter CO.NonSIunits.Angle_deg epsilon = 0 "Steering head angle";
          final parameter SI.Angle epsilon_rad = CO.from_deg(epsilon);
          final parameter SI.Position n[3] = {sin(epsilon_rad),cos(epsilon_rad),0}
            "direction of steering axis";

          final parameter SI.Position ntw[3] = {sin(PI/2-epsilon_rad),-cos(PI/2-epsilon_rad),0};

          // The length of the spring and the translation element between spring and front wheel center point
          // are calcutalted by means of p4
          parameter SI.Position p2[3] = {1,1,0} "Steering axis co-ordinate";
          parameter SI.Position p3[3] = {0,0,0} "Center of mass front frame";
          parameter SI.Position p4[3] = {1,1,0}
            "Joint co-ordinate for front supsension and steer body";
          parameter SI.Position p5[3] = {0,0,0}
            "Center of mass front suspension";

          //final parameter SI.Position p6[3] = {w, R_fw,0};
          //final parameter SI.Distance s_rel0 = sqrt( (p6[1]-p4[1])*(p6[1]-p4[1]) + (p6[2]-p4[2])*(p6[2]-p4[2]))
          //  "Unstretched spring length";
          final parameter SI.Distance s_rel0 = sqrt( (w-p4[1])*(w-p4[1]) + (R_rw-p4[2])*(R_rw-p4[2]))
            "Unstretched spring length";
          parameter SI.Distance bias = 0.3 "Pre-load of the spring";

          parameter SI.Distance offset = 0
            "Perpendicular distance between steering axis and front wheel center point";
          final parameter SI.Distance offset_vector[3] = {cos(epsilon_rad)*offset, -sin(epsilon_rad)*offset, 0};

          final parameter SI.Position p2_offset[3] = {p2[1]+cos(epsilon_rad)*offset, p2[2]+sin(epsilon_rad)*offset, 0};
          final parameter SI.Distance r[3] = {p4[1] - p2_offset[1], p2_offset[2] - p4[2], 0}
            "Front Fork length (without front supsension)";

        // TAB: Intertia Tensor - Front Suspension
          parameter SI.Mass mFS = 1 "mass of front suspension";
          final parameter SI.Distance CoM_FS[3] = {p5[1] - p2_offset[1], p2_offset[2] - p5[2], 0};

          parameter SI.Inertia I_FS_11=0.001
            "|Inertia tensor of the Front Suspension|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_FS_22=0.001
            "|Inertia tensor of the Front Suspension|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_FS_33=0.001
            "|Inertia tensor of the Front Suspension|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_FS_21=0
            "|Inertia tensor of the Front Suspension|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_FS_31=0
            "|Inertia tensor of the Front Suspension|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_FS_32=0
            "|Inertia tensor of the Front Suspension|| (3,2) element of inertia tensor";

          parameter SI.Mass mFF = 1 "mass of front frame";
          // Since the CoM of the Front Frame is rigidly attached to p2 the difference is calculated w.r.t p2
          // final parameter SI.Distance CoM_FF[3] = {w - p3[1], p3[2] - R_fw, 0};
          final parameter SI.Distance CoM_FF[3] = {p2_offset[1] - p3[1], p3[2] - p2_offset[2], 0};

        // TAB: Intertia Tensor - Front Frame
          parameter SI.Inertia I_FF_11=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_FF_22=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_FF_33=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_FF_21=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_FF_31=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_FF_32=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,2) element of inertia tensor";

        // TAB: Initial Conditions
          parameter CO.NonSIunits.Angle_deg init_steerAngle = 0
            "|Initial Conditions||initial steer angle";

          // Animation
        public
          parameter SI.Angle handlebarAngle = 65
            "|Animation || angle of the handlebar";
        protected
          final parameter SI.Angle handlebarAngleRad = SI.Conversions.from_deg(handlebarAngle);
        public
          parameter MB.Types.Color HandleBarColor = {155,155,155}
            "|Animation || Color of the HandleBar";
          parameter MB.Types.Color HandleColor = {55,55,55}
            "|Animation || Color of the HandleBar";

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            ForkPipe1_Right(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection=Steering.n,
            r_shape={0,0,0.11},
            length=0.2,
            width=0.05,
            height=0.05,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            ForkPipe1_Left(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection=Steering.n,
            r_shape={0,0,-0.11},
            length=0.2,
            width=0.05,
            height=0.05,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe2(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection={0,0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,-0.17},
            length=0.34,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleRight(
            shapeType="cylinder",
            color=HandleColor,
            lengthDirection={0.3,0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,0.17},
            length=0.2,
             r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleLeft(
            shapeType="cylinder",
            color=HandleColor,
            lengthDirection={-0.3,-0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,-0.17},
            length=-0.2,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          MultiBondLib.Mechanics3D.Interfaces.Frame_b SteeringAxis
            annotation (extent=[36,18; 64,62]);
          annotation (Diagram(
              Line(points=[100,-50; 100,-50], style(color=83, rgbcolor={255,85,
                      255})),
              Line(points=[66,-50; 80,-50],   style(color=83, rgbcolor={255,85,
                      255})),
        Rectangle(extent=[80,-40; 100,-60], style(color=83, rgbcolor={255,85,255})),
        Text(
        extent=[80,-40; 100,-60],
        style(color=83, rgbcolor={255,85,255}),
        string="Connected?")), Icon(
              Text(extent=[-152,50; -54,-26], string="%name"),
              Rectangle(extent=[40,-84; 26,100], style(
                  color=2,
                  rgbcolor={0,255,0},
                  gradient=1,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[80,88; 40,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95})),
              Rectangle(extent=[-26,80; 26,0],  style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=3,
                  rgbfillColor={0,0,255})),
              Text(
                extent=[-20,-90; 20,-50],
                string="a",
                style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=1,
                  fillColor=42,
                  rgbfillColor={127,0,0})),
              Text(
                extent=[-18,20; 22,60],
                style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=1,
                  fillColor=42,
                  rgbfillColor={127,0,0}),
                string="b"),
              Rectangle(extent=[-26,-84; -40,100], style(
                  color=2,
                  rgbcolor={0,255,0},
                  gradient=1,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[26,88; -26,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[-40,88; -80,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=10)),
              Line(points=[-52,-8; -40,-14], style(color=2, rgbcolor={0,255,0})),
              Line(points=[-52,-8; -26,2], style(color=2, rgbcolor={0,255,0})),
              Line(points=[-26,-20; -14,-24], style(color=2, rgbcolor={0,255,0})),
              Line(points=[-14,-24; -52,-38; -40,-44], style(color=2, rgbcolor=
                      {0,255,0})),
              Line(points=[-26,-50; -16,-54; -52,-68; -40,-74], style(color=2,
                    rgbcolor={0,255,0})),
              Line(points=[14,-8; 40,2], style(color=2, rgbcolor={0,255,0})),
              Line(points=[14,-8; 26,-14], style(color=2, rgbcolor={0,255,0})),
              Line(points=[40,-20; 52,-24], style(color=2, rgbcolor={0,255,0})),
              Line(points=[52,-24; 14,-38; 26,-44], style(color=2, rgbcolor={0,
                      255,0})),
              Line(points=[40,-50; 50,-54; 14,-68; 26,-74], style(color=2,
                    rgbcolor={0,255,0}))),
            Coordsys(scale=0.2, extent=[-100,-100; 100,100]));

          FrontSuspensions.FrontSuspensionClassic_Ind frontSuspension(
            s_rel0=s_rel0,
            r=r,
            n=n,
            m=mFS,
            I_11=I_FS_11,
            I_22=I_FS_22,
            I_33=I_FS_33,
            I_21=I_FS_21,
            I_31=I_FS_31,
            I_32=I_FS_32,
            CoM_FS=CoM_FS,
            bias=bias,
            spring_table=spring_table,
            damper_table=damper_table)
                          annotation (extent=[-80,-30; -60,-10],rotation=90);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation FixedTranslation(
                               r=CoM_FF, animation=false)
                                                   annotation (extent=[-100,10;
                -80,30],
              rotation=90);
          MultiBondLib.Mechanics3D.Parts.SimpleBody Mass(
            sphereDiameter=0.1,
            animation=true,
            m=mFF,
            I_11=I_FF_11,
            I_22=I_FF_22,
            I_33=I_FF_33,
            I_21=I_FF_21,
            I_31=I_FF_31,
            I_32=I_FF_32)
                 annotation (extent=[-100,50; -80,70],rotation=90);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute Steering(
            cylinderLength=0.10,
            cylinderDiameter=0.07,
            cylinderColor={100,100,100},
            n=n,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
            enforceStates=true,
            phi_start=init_steerAngle,
            animation=true)
            annotation (extent=[-10,44; 10,64]);
          BondLib.Mechanical.Rotational.Passive.Damper damper(d=ds)
            annotation (extent=[-10,24; 10,44],  rotation=180);
          MultiBondLib.Mechanics3D.Joints.Revolute FWRevolute(
            phi(stateSelect=StateSelect.always),
            phi_start=0,
            animation=true,
            cylinderDiameter=0.08,
            cylinderColor={255,0,0},
            initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
            cylinderLength=0.2,
            enforceStates=true)
            annotation (extent=[-80,-60; -60,-40], rotation=90);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation
            FixedTranslation_Offset(
              animation=true, r=offset_vector)     annotation (extent=[-80,10;
                -60,30],
              rotation=90);
          MultiBondLib.Mechanics3D.Interfaces.Frame_a RevoltueAxis
            annotation (extent=[-30,-115; 30,-85], rotation=90);
          BondLib.Mechanical.Rotational.Sources.Torque SteeringTorque
            annotation (extent=[18,-20; 38,0],   rotation=90);
          Modelica.Blocks.Interfaces.RealInput T_Steering
            annotation (extent=[-16,80; 16,110], rotation=270);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute TwistAxis(n=ntw,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            animation=false,
            enforceStates=false)
            annotation (extent=[-50,44; -30,64]);
          BondLib.Mechanical.Rotational.Passive.Damper damper1(d=dtw)
            annotation (extent=[-50,24; -30,44],rotation=180);
          BondLib.Mechanical.Rotational.Passive.Spring spring(c=ctw)
            annotation (extent=[-50,2; -30,22],  rotation=180);
          BondLib.Mechanical.Rotational.Sensors.AngleSensor angleSensor
            annotation (extent=[0,8; 20,28],  rotation=270);
          Modelica.Blocks.Interfaces.RealOutput y
            annotation (extent=[-10,-20; 10,0], rotation=270);
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (extent=[100,-90; 80,-70], rotation=0);
          Modelica.Blocks.Logical.Switch switch1
            annotation (extent=[60,-60; 40,-40]);
        equation
         if cardinality(T_Steering) <= 1 then
            T_Steering = 0;
            switch1.u2 = false;
          else
            switch1.u2 = true;
          end if;
          connect(SteeringAxis, SteeringAxis) annotation (points=[50,40; 50,40],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Mass.frame_a,FixedTranslation. frame_b)            annotation (
              points=[-90,49; -90,31], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=10,
              rgbfillColor={95,95,95}));
          connect(damper.flange_a,Steering. axis) annotation (points=[10,34; 10,
                47; 7,47],
                       style(color=0, rgbcolor={0,0,0}));
          connect(damper.flange_b,Steering. bearing) annotation (points=[-10,34;
                -10,47; -7,47],
                         style(color=0, rgbcolor={0,0,0}));
          connect(SteeringTorque.flange_b, damper.flange_a) annotation (points=[28,0; 28,
                34; 10,34],                    style(color=0, rgbcolor={0,0,0}));
          connect(FWRevolute.frame_a, RevoltueAxis) annotation (points=[-70,-61;
                -70,-72; 0,-72; 0,-100],
                                style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(FixedTranslation.frame_a, frontSuspension.SteeringAxis)
            annotation (points=[-90,9; -90,0; -70,0; -70,-9.2], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(damper1.flange_b, TwistAxis.bearing) annotation (points=[-50,34;
                -50,47; -47,47], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(damper1.flange_a, TwistAxis.axis) annotation (points=[-30,34;
                -30,47; -33,47], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(TwistAxis.frame_b, Steering.frame_a) annotation (points=[-29,54;
                -11,54],style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(TwistAxis.frame_a, FixedTranslation_Offset.frame_b) annotation (
             points=[-51,54; -70,54; -70,31], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(spring.flange_b, damper1.flange_b) annotation (points=[-50,12;
                -50,34], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(spring.flange_a, damper1.flange_a) annotation (points=[-30,12;
                -30,34], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(angleSensor.flange_a, damper.flange_a) annotation (points=[10,28;
                10,31; 10,31; 10,34],     style(color=0, rgbcolor={0,0,0}));
          connect(angleSensor.phi, y) annotation (points=[10,8; 10,4; 0,4; 0,
                -10],
              style(color=74, rgbcolor={0,0,127}));
          connect(y, y) annotation (points=[0,-10; 0,-10], style(color=74,
                rgbcolor={0,0,127}));
          connect(const.y, switch1.u3) annotation (points=[79,-80; 72,-80; 72,-58;
                62,-58], style(color=74, rgbcolor={0,0,127}));
          connect(T_Steering, switch1.u1) annotation (points=[0,95; 0,72; 72,72;
                72,-42; 62,-42], style(color=74, rgbcolor={0,0,127}));
          connect(switch1.y, SteeringTorque.tau) annotation (points=[39,-50; 28,
                -50; 28,-21], style(color=74, rgbcolor={0,0,127}));
          connect(Steering.frame_b, SteeringAxis) annotation (points=[11,54; 22,
                54; 22,40; 50,40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(frontSuspension.SteeringAxis, FixedTranslation_Offset.frame_a)
            annotation (points=[-70,-9.2; -70,9], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
          connect(frontSuspension.FrontWheel, FWRevolute.frame_b) annotation (
              points=[-70,-30.8; -70,-39], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
        end FrontFrame_Ind;

        model FrontFrameUSD
          "Front Frame with additional twist axis and elasto gap"

          import SI = Modelica.SIunits;
          import CO = Modelica.SIunits.Conversions;
          import PI = Modelica.Constants.pi;
          import MB = Modelica.Mechanics.MultiBody;

          parameter SI.Distance w = 1 "wheelbase of the motorcycle";
          parameter SI.Distance R_fw = 1 "Front wheel Radius";
          parameter SI.Distance R_rw = 1
            "Rear wheel radius - in order to calculate the correct spring length";

          parameter Real c(
            final unit="N/m",
            final min=0) = 1 "Spring constant of the front suspension";

          parameter Real d(
            final unit="N/(m/s)",
            final min=0) = 0 "Damping constant of the front suspension";

          parameter Real ds(
            final unit="N/(m/s)",
            final min=0) = 0 "Steering damper";

          parameter Real ctw(
            final unit="N.m/rad",
            final min=0) = 1 "Twist axis stiffness";

          parameter Real dtw(
            final unit="N.m/(rad/s)",
            final min=0) = 0 "Twist axis damping constant";

          parameter CO.NonSIunits.Angle_deg epsilon = 0 "Steering head angle";
          final parameter SI.Angle epsilon_rad = CO.from_deg(epsilon);
          final parameter SI.Position n[3] = {sin(epsilon_rad),cos(epsilon_rad),0}
            "direction of steering axis";

          final parameter SI.Position ntw[3] = {sin(PI/2-epsilon_rad),-cos(PI/2-epsilon_rad),0};

          // The length of the spring and the translation element between spring and front wheel center point
          // are calcutalted by means of p4
          parameter SI.Position p2[3] = {1,1,0} "Steering axis co-ordinate";
          parameter SI.Position p3[3] = {0,0,0} "Center of mass front frame";
          parameter SI.Position p4[3] = {1,1,0}
            "Joint co-ordinate for front supsension and steer body";
          parameter SI.Position p5[3] = {0,0,0}
            "Center of mass front suspension";

          //final parameter SI.Position p6[3] = {w, R_fw,0};
          //final parameter SI.Distance s_rel0 = sqrt( (p6[1]-p4[1])*(p6[1]-p4[1]) + (p6[2]-p4[2])*(p6[2]-p4[2]))
          //  "Unstretched spring length";
          final parameter SI.Distance s_rel0 = sqrt( (w-p4[1])*(w-p4[1]) + (R_rw-p4[2])*(R_rw-p4[2]))
            "Unstretched spring length";
          parameter SI.Distance bias = 0.3 "Pre-load of the spring";

          parameter SI.Distance offset = 0
            "Perpendicular distance between steering axis and front wheel center point";
          final parameter SI.Distance offset_vector[3] = {cos(epsilon_rad)*offset, -sin(epsilon_rad)*offset, 0};

          final parameter SI.Position p2_offset[3] = {p2[1]+cos(epsilon_rad)*offset, p2[2]+sin(epsilon_rad)*offset, 0};
          final parameter SI.Distance r[3] = {p4[1] - p2_offset[1], p2_offset[2] - p4[2], 0}
            "Front Fork length (without front supsension)";

        // TAB: Intertia Tensor - Front Suspension
          parameter SI.Mass mFS = 1 "mass of front suspension";
           final parameter SI.Distance CoM_FS[3] = {p5[1] - p2_offset[1], p2_offset[2] - p5[2], 0};

          parameter SI.Inertia I_FS_11=0.001
            "|Inertia tensor of the Front Suspension|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_FS_22=0.001
            "|Inertia tensor of the Front Suspension|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_FS_33=0.001
            "|Inertia tensor of the Front Suspension|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_FS_21=0
            "|Inertia tensor of the Front Suspension|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_FS_31=0
            "|Inertia tensor of the Front Suspension|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_FS_32=0
            "|Inertia tensor of the Front Suspension|| (3,2) element of inertia tensor";

          parameter SI.Mass mFF = 1 "mass of front frame";
          // Since the CoM of the Front Frame is rigidly attached to p2 the difference is calculated w.r.t p2
          // final parameter SI.Distance CoM_FF[3] = {w - p3[1], p3[2] - R_fw, 0};
          final parameter SI.Distance CoM_FF[3] = {p2_offset[1] - p3[1], p3[2] - p2_offset[2], 0};

        // TAB: Intertia Tensor - Front Frame
          parameter SI.Inertia I_FF_11=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_FF_22=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_FF_33=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_FF_21=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_FF_31=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_FF_32=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,2) element of inertia tensor";

        // TAB: Initial Conditions
          parameter CO.NonSIunits.Angle_deg init_steerAngle = 0
            "|Initial Conditions||initial steer angle";

          // Animation
        public
          parameter SI.Angle handlebarAngle = 65
            "|Animation || angle of the handlebar";
        protected
          final parameter SI.Angle handlebarAngleRad = SI.Conversions.from_deg(handlebarAngle);
        public
          parameter MB.Types.Color HandleBarColor = {155,155,155}
            "|Animation || Color of the HandleBar";
          parameter MB.Types.Color HandleColor = {55,55,55}
            "|Animation || Color of the HandleBar";

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            ForkPipe1_Right(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection=Steering.n,
            r_shape={0,0,0.11},
            length=0.2,
            width=0.05,
            height=0.05,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            ForkPipe1_Left(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection=Steering.n,
            r_shape={0,0,-0.11},
            length=0.2,
            width=0.05,
            height=0.05,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe2(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection={0,0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,-0.17},
            length=0.34,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleRight(
            shapeType="cylinder",
            color=HandleColor,
            lengthDirection={0.3,0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,0.17},
            length=0.2,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleLeft(
            shapeType="cylinder",
            color=HandleColor,
            lengthDirection={-0.3,-0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,-0.17},
            length=-0.2,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          MultiBondLib.Mechanics3D.Interfaces.Frame_b SteeringAxis
            annotation (extent=[36,18; 64,62]);
          annotation (Diagram(
              Line(points=[100,-50; 100,-50], style(color=83, rgbcolor={255,85,
                      255})),
              Line(points=[66,-50; 80,-50],   style(color=83, rgbcolor={255,85,
                      255})),
        Rectangle(extent=[80,-40; 100,-60], style(color=83, rgbcolor={255,85,255})),
        Text(
        extent=[80,-40; 100,-60],
        style(color=83, rgbcolor={255,85,255}),
        string="Connected?")), Icon(
              Text(extent=[-152,50; -54,-26], string="%name"),
              Rectangle(extent=[40,-84; 26,100], style(
                  color=2,
                  rgbcolor={0,255,0},
                  gradient=1,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[80,88; 40,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95})),
              Rectangle(extent=[-26,80; 26,0],  style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=3,
                  rgbfillColor={0,0,255})),
              Text(
                extent=[-20,-90; 20,-50],
                string="a",
                style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=1,
                  fillColor=42,
                  rgbfillColor={127,0,0})),
              Text(
                extent=[-18,20; 22,60],
                style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=1,
                  fillColor=42,
                  rgbfillColor={127,0,0}),
                string="b"),
              Rectangle(extent=[-26,-84; -40,100], style(
                  color=2,
                  rgbcolor={0,255,0},
                  gradient=1,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[26,88; -26,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[-40,88; -80,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=10)),
              Line(points=[-52,-8; -40,-14], style(color=45, rgbcolor={255,128,0})),
              Line(points=[-52,-8; -26,2], style(color=45, rgbcolor={255,128,0})),
              Line(points=[-26,-20; -14,-24], style(color=45, rgbcolor={255,128,0})),
              Line(points=[-14,-24; -52,-38; -40,-44], style(color=45, rgbcolor={
                      255,128,0})),
              Line(points=[-26,-50; -16,-54; -52,-68; -40,-74], style(color=45,
                    rgbcolor={255,128,0})),
              Line(points=[14,-8; 40,2], style(color=45, rgbcolor={255,128,0})),
              Line(points=[14,-8; 26,-14], style(color=45, rgbcolor={255,128,0})),
              Line(points=[40,-20; 52,-24], style(color=45, rgbcolor={255,128,0})),
              Line(points=[52,-24; 14,-38; 26,-44], style(color=45, rgbcolor={255,
                      128,0})),
              Line(points=[40,-50; 50,-54; 14,-68; 26,-74], style(color=45,
                    rgbcolor={255,128,0}))),
            Coordsys(scale=0.2, extent=[-100,-100; 100,100]));

          MultiBondLib.Mechanics3D.Parts.FixedTranslation FixedTranslation(
                               r=CoM_FF, animation=false)
                                                   annotation (extent=[-100,10;
                -80,30],
              rotation=90);
          MultiBondLib.Mechanics3D.Parts.SimpleBody Mass(
            sphereDiameter=0.1,
            animation=true,
            m=mFF,
            I_11=I_FF_11,
            I_22=I_FF_22,
            I_33=I_FF_33,
            I_21=I_FF_21,
            I_31=I_FF_31,
            I_32=I_FF_32)
                 annotation (extent=[-100,50; -80,70],rotation=90);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute Steering(
            cylinderLength=0.10,
            cylinderDiameter=0.07,
            cylinderColor={100,100,100},
            n=n,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
            enforceStates=true,
            phi_start=init_steerAngle,
            animation=true)
            annotation (extent=[-10,44; 10,64]);
          BondLib.Mechanical.Rotational.Passive.Damper damper(d=ds)
            annotation (extent=[-10,24; 10,44],  rotation=180);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation
            FixedTranslation_Offset(
              animation=true, r=offset_vector)     annotation (extent=[-80,10;
                -60,30],
              rotation=90);
          MultiBondLib.Mechanics3D.Interfaces.Frame_a RevoltueAxis
            annotation (extent=[-30,-115; 30,-85], rotation=90);
          BondLib.Mechanical.Rotational.Sources.Torque SteeringTorque
            annotation (extent=[18,-20; 38,0],   rotation=90);
          Modelica.Blocks.Interfaces.RealInput T_Steering
            annotation (extent=[-16,80; 16,110], rotation=270);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute TwistAxis(n=ntw,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            animation=false,
            enforceStates=true)
            annotation (extent=[-50,44; -30,64]);
          BondLib.Mechanical.Rotational.Passive.Damper damper1(d=dtw)
            annotation (extent=[-50,24; -30,44],rotation=180);
          BondLib.Mechanical.Rotational.Passive.Spring spring(c=ctw)
            annotation (extent=[-50,2; -30,22],  rotation=180);
          BondLib.Mechanical.Rotational.Sensors.AngleSensor angleSensor
            annotation (extent=[0,8; 20,28],  rotation=270);
          Modelica.Blocks.Interfaces.RealOutput y
            annotation (extent=[-10,-20; 10,0], rotation=270);
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (extent=[100,-90; 80,-70], rotation=0);
          Modelica.Blocks.Logical.Switch switch1
            annotation (extent=[60,-60; 40,-40]);
          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontSuspensions.FrontSuspensionUSD
            frontSuspension(
            c=c,
            d=d,
            s_rel0=s_rel0,
            r=r,
            n=n,
            m=mFS,
            I_11=I_FS_11,
            I_22=I_FS_22,
            I_33=I_FS_33,
            I_21=I_FS_21,
            I_31=I_FS_31,
            I_32=I_FS_32,
            CoM_FS=CoM_FS,
            bias=bias)    annotation (extent=[-80,-30; -60,-10],rotation=90);
          MultiBondLib.Mechanics3D.Joints.Revolute FWRevolute(
            phi(stateSelect=StateSelect.always),
            phi_start=0,
            animation=true,
            cylinderDiameter=0.08,
            cylinderColor={255,0,0},
            initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
            cylinderLength=0.2,
            enforceStates=true)
            annotation (extent=[-80,-60; -60,-40], rotation=90);
        equation
         if cardinality(T_Steering) <= 1 then
            T_Steering = 0;
            switch1.u2 = false;
          else
            switch1.u2 = true;
          end if;
          connect(SteeringAxis, SteeringAxis) annotation (points=[50,40; 50,40],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Mass.frame_a,FixedTranslation. frame_b)            annotation (
              points=[-90,49; -90,31], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=10,
              rgbfillColor={95,95,95}));
          connect(damper.flange_a,Steering. axis) annotation (points=[10,34; 10,
                47; 7,47],
                       style(color=0, rgbcolor={0,0,0}));
          connect(damper.flange_b,Steering. bearing) annotation (points=[-10,34;
                -10,47; -7,47],
                         style(color=0, rgbcolor={0,0,0}));
          connect(SteeringTorque.flange_b, damper.flange_a) annotation (points=[28,0; 28,
                34; 10,34],                    style(color=0, rgbcolor={0,0,0}));
          connect(damper1.flange_b, TwistAxis.bearing) annotation (points=[-50,34;
                -50,47; -47,47], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(damper1.flange_a, TwistAxis.axis) annotation (points=[-30,34;
                -30,47; -33,47], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(TwistAxis.frame_b, Steering.frame_a) annotation (points=[-29,54;
                -11,54],style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(TwistAxis.frame_a, FixedTranslation_Offset.frame_b) annotation (
             points=[-51,54; -70,54; -70,31], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(spring.flange_b, damper1.flange_b) annotation (points=[-50,12;
                -50,34], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(spring.flange_a, damper1.flange_a) annotation (points=[-30,12;
                -30,34], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(angleSensor.flange_a, damper.flange_a) annotation (points=[10,28;
                10,31; 10,31; 10,34],     style(color=0, rgbcolor={0,0,0}));
          connect(angleSensor.phi, y) annotation (points=[10,8; 10,4; 0,4; 0,
                -10],
              style(color=74, rgbcolor={0,0,127}));
          connect(y, y) annotation (points=[0,-10; 0,-10], style(color=74,
                rgbcolor={0,0,127}));
          connect(const.y, switch1.u3) annotation (points=[79,-80; 72,-80; 72,-58;
                62,-58], style(color=74, rgbcolor={0,0,127}));
          connect(T_Steering, switch1.u1) annotation (points=[0,95; 0,72; 72,72;
                72,-42; 62,-42], style(color=74, rgbcolor={0,0,127}));
          connect(switch1.y, SteeringTorque.tau) annotation (points=[39,-50; 28,
                -50; 28,-21], style(color=74, rgbcolor={0,0,127}));
          connect(Steering.frame_b, SteeringAxis) annotation (points=[11,54; 22,
                54; 22,40; 50,40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(frontSuspension.FrontWheel, FWRevolute.frame_b) annotation (
              points=[-70,-30.8; -70,-39], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
          connect(frontSuspension.SteeringAxis, FixedTranslation_Offset.frame_a)
            annotation (points=[-70,-9.2; -70,9], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
          connect(FixedTranslation.frame_a, frontSuspension.SteeringAxis)
            annotation (points=[-90,9; -90,0; -70,0; -70,-9.2], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
          connect(FWRevolute.frame_a, RevoltueAxis) annotation (points=[-70,-61;
                -70,-72; 0,-72; 0,-100], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
        end FrontFrameUSD;

        model FrontFrameUSD_Ind
          "Front Frame with additional twist axis and elasto gap"

          import SI = Modelica.SIunits;
          import CO = Modelica.SIunits.Conversions;
          import PI = Modelica.Constants.pi;
          import MB = Modelica.Mechanics.MultiBody;

          parameter SI.Distance w = 1 "wheelbase of the motorcycle";
          parameter SI.Distance R_fw = 1 "Front wheel Radius";
          parameter SI.Distance R_rw = 1
            "Rear wheel radius - in order to calculate the correct spring length";

          parameter Real spring_table[:,:] = [0,0; 1,1]
            "Spring characteristics of the front suspension";
          parameter Real damper_table[:,:] = [0,0; 1,1]
            "Damper characteristics of the front suspension";

          parameter Real ds(
            final unit="N/(m/s)",
            final min=0) = 0 "Steering damper";

          parameter Real ctw(
            final unit="N.m/rad",
            final min=0) = 1 "Twist axis stiffness";

          parameter Real dtw(
            final unit="N.m/(rad/s)",
            final min=0) = 0 "Twist axis damping constant";

          parameter CO.NonSIunits.Angle_deg epsilon = 0 "Steering head angle";
          final parameter SI.Angle epsilon_rad = CO.from_deg(epsilon);
          final parameter SI.Position n[3] = {sin(epsilon_rad),cos(epsilon_rad),0}
            "direction of steering axis";

          final parameter SI.Position ntw[3] = {sin(PI/2-epsilon_rad),-cos(PI/2-epsilon_rad),0};

          // The length of the spring and the translation element between spring and front wheel center point
          // are calcutalted by means of p4
          parameter SI.Position p2[3] = {1,1,0} "Steering axis co-ordinate";
          parameter SI.Position p3[3] = {0,0,0} "Center of mass front frame";
          parameter SI.Position p4[3] = {1,1,0}
            "Joint co-ordinate for front supsension and steer body";
          parameter SI.Position p5[3] = {0,0,0}
            "Center of mass front suspension";

          //final parameter SI.Position p6[3] = {w, R_fw,0};
          //final parameter SI.Distance s_rel0 = sqrt( (p6[1]-p4[1])*(p6[1]-p4[1]) + (p6[2]-p4[2])*(p6[2]-p4[2]))
          //  "Unstretched spring length";
          final parameter SI.Distance s_rel0 = sqrt( (w-p4[1])*(w-p4[1]) + (R_rw-p4[2])*(R_rw-p4[2]))
            "Unstretched spring length";
          parameter SI.Distance bias = 0.3 "Pre-load of the spring";

          parameter SI.Distance offset = 0
            "Perpendicular distance between steering axis and front wheel center point";
          final parameter SI.Distance offset_vector[3] = {cos(epsilon_rad)*offset, -sin(epsilon_rad)*offset, 0};

          final parameter SI.Position p2_offset[3] = {p2[1]+cos(epsilon_rad)*offset, p2[2]+sin(epsilon_rad)*offset, 0};
          final parameter SI.Distance r[3] = {p4[1] - p2_offset[1], p2_offset[2] - p4[2], 0}
            "Front Fork length (without front supsension)";

        // TAB: Intertia Tensor - Front Suspension
          parameter SI.Mass mFS = 1 "mass of front suspension";
           final parameter SI.Distance CoM_FS[3] = {p5[1] - p2_offset[1], p2_offset[2] - p5[2], 0};

          parameter SI.Inertia I_FS_11=0.001
            "|Inertia tensor of the Front Suspension|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_FS_22=0.001
            "|Inertia tensor of the Front Suspension|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_FS_33=0.001
            "|Inertia tensor of the Front Suspension|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_FS_21=0
            "|Inertia tensor of the Front Suspension|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_FS_31=0
            "|Inertia tensor of the Front Suspension|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_FS_32=0
            "|Inertia tensor of the Front Suspension|| (3,2) element of inertia tensor";

          parameter SI.Mass mFF = 1 "mass of front frame";
          // Since the CoM of the Front Frame is rigidly attached to p2 the difference is calculated w.r.t p2
          // final parameter SI.Distance CoM_FF[3] = {w - p3[1], p3[2] - R_fw, 0};
          final parameter SI.Distance CoM_FF[3] = {p2_offset[1] - p3[1], p3[2] - p2_offset[2], 0};

        // TAB: Intertia Tensor - Front Frame
          parameter SI.Inertia I_FF_11=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_FF_22=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_FF_33=0.001
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_FF_21=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_FF_31=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_FF_32=0
            "|Inertia tensor of the Front Frame (without Front Suspension)|| (3,2) element of inertia tensor";

        // TAB: Initial Conditions
          parameter CO.NonSIunits.Angle_deg init_steerAngle = 0
            "|Initial Conditions||initial steer angle";

          // Animation
        public
          parameter SI.Angle handlebarAngle = 65
            "|Animation || angle of the handlebar";
        protected
          final parameter SI.Angle handlebarAngleRad = SI.Conversions.from_deg(handlebarAngle);
        public
          parameter MB.Types.Color HandleBarColor = {155,155,155}
            "|Animation || Color of the HandleBar";
          parameter MB.Types.Color HandleColor = {55,55,55}
            "|Animation || Color of the HandleBar";

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            ForkPipe1_Right(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection=Steering.n,
            r_shape={0,0,0.11},
            length=0.2,
            width=0.05,
            height=0.05,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            ForkPipe1_Left(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection=Steering.n,
            r_shape={0,0,-0.11},
            length=0.2,
            width=0.05,
            height=0.05,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape ForkPipe2(
            shapeType="cylinder",
            color=HandleBarColor,
            lengthDirection={0,0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,-0.17},
            length=0.34,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleRight(
            shapeType="cylinder",
            color=HandleColor,
            lengthDirection={0.3,0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,0.17},
            length=0.2,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape HandleLeft(
            shapeType="cylinder",
            color=HandleColor,
            lengthDirection={-0.3,-0,1},
            width=0.05,
            height=0.1,
            r_shape=Steering.n*0.2+{0,0,-0.17},
            length=-0.2,
            r=FixedTranslation_Offset.frame_a.P.x,
            R=MB.Frames.Orientation(T=FixedTranslation_Offset.frame_a.P.R,w=zeros(3)));

          MultiBondLib.Mechanics3D.Interfaces.Frame_b SteeringAxis
            annotation (extent=[36,18; 64,62]);
          annotation (Diagram(
              Line(points=[100,-50; 100,-50], style(color=83, rgbcolor={255,85,
                      255})),
              Line(points=[66,-50; 80,-50],   style(color=83, rgbcolor={255,85,
                      255})),
        Rectangle(extent=[80,-40; 100,-60], style(color=83, rgbcolor={255,85,255})),
        Text(
        extent=[80,-40; 100,-60],
        style(color=83, rgbcolor={255,85,255}),
        string="Connected?")), Icon(
              Text(extent=[-152,50; -54,-26], string="%name"),
              Rectangle(extent=[40,-84; 26,100], style(
                  color=2,
                  rgbcolor={0,255,0},
                  gradient=1,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[80,88; 40,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95})),
              Rectangle(extent=[-26,80; 26,0],  style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=3,
                  rgbfillColor={0,0,255})),
              Text(
                extent=[-20,-90; 20,-50],
                string="a",
                style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=1,
                  fillColor=42,
                  rgbfillColor={127,0,0})),
              Text(
                extent=[-18,20; 22,60],
                style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=1,
                  fillColor=42,
                  rgbfillColor={127,0,0}),
                string="b"),
              Rectangle(extent=[-26,-84; -40,100], style(
                  color=2,
                  rgbcolor={0,255,0},
                  gradient=1,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[26,88; -26,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Rectangle(extent=[-40,88; -80,100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=10)),
              Line(points=[-52,-8; -40,-14], style(color=2, rgbcolor={0,255,0})),
              Line(points=[-52,-8; -26,2], style(color=2, rgbcolor={0,255,0})),
              Line(points=[-26,-20; -14,-24], style(color=2, rgbcolor={0,255,0})),
              Line(points=[-14,-24; -52,-38; -40,-44], style(color=2, rgbcolor=
                      {0,255,0})),
              Line(points=[-26,-50; -16,-54; -52,-68; -40,-74], style(color=2,
                    rgbcolor={0,255,0})),
              Line(points=[14,-8; 40,2], style(color=2, rgbcolor={0,255,0})),
              Line(points=[14,-8; 26,-14], style(color=2, rgbcolor={0,255,0})),
              Line(points=[40,-20; 52,-24], style(color=2, rgbcolor={0,255,0})),
              Line(points=[52,-24; 14,-38; 26,-44], style(color=2, rgbcolor={0,
                      255,0})),
              Line(points=[40,-50; 50,-54; 14,-68; 26,-74], style(color=2,
                    rgbcolor={0,255,0}))),
            Coordsys(scale=0.2, extent=[-100,-100; 100,100]));

          MultiBondLib.Mechanics3D.Parts.FixedTranslation FixedTranslation(
                               r=CoM_FF, animation=false)
                                                   annotation (extent=[-100,10;
                -80,30],
              rotation=90);
          MultiBondLib.Mechanics3D.Parts.SimpleBody Mass(
            sphereDiameter=0.1,
            animation=true,
            m=mFF,
            I_11=I_FF_11,
            I_22=I_FF_22,
            I_33=I_FF_33,
            I_21=I_FF_21,
            I_31=I_FF_31,
            I_32=I_FF_32)
                 annotation (extent=[-100,50; -80,70],rotation=90);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute Steering(
            cylinderLength=0.10,
            cylinderDiameter=0.07,
            cylinderColor={100,100,100},
            n=n,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
            enforceStates=true,
            phi_start=init_steerAngle,
            animation=true)
            annotation (extent=[-10,44; 10,64]);
          BondLib.Mechanical.Rotational.Passive.Damper damper(d=ds)
            annotation (extent=[-10,24; 10,44],  rotation=180);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation
            FixedTranslation_Offset(
              animation=true, r=offset_vector)     annotation (extent=[-80,10;
                -60,30],
              rotation=90);
          MultiBondLib.Mechanics3D.Interfaces.Frame_a RevoltueAxis
            annotation (extent=[-30,-115; 30,-85], rotation=90);
          BondLib.Mechanical.Rotational.Sources.Torque SteeringTorque
            annotation (extent=[18,-20; 38,0],   rotation=90);
          Modelica.Blocks.Interfaces.RealInput T_Steering
            annotation (extent=[-16,80; 16,110], rotation=270);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute TwistAxis(n=ntw,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            animation=false,
            enforceStates=true)
            annotation (extent=[-50,44; -30,64]);
          BondLib.Mechanical.Rotational.Passive.Damper damper1(d=dtw)
            annotation (extent=[-50,24; -30,44],rotation=180);
          BondLib.Mechanical.Rotational.Passive.Spring spring(c=ctw)
            annotation (extent=[-50,2; -30,22],  rotation=180);
          BondLib.Mechanical.Rotational.Sensors.AngleSensor angleSensor
            annotation (extent=[0,8; 20,28],  rotation=270);
          Modelica.Blocks.Interfaces.RealOutput y
            annotation (extent=[-10,-20; 10,0], rotation=270);
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (extent=[100,-90; 80,-70], rotation=0);
          Modelica.Blocks.Logical.Switch switch1
            annotation (extent=[60,-60; 40,-40]);
          FrontSuspensions.FrontSuspensionUSD_Ind frontSuspension(
            s_rel0=s_rel0,
            r=r,
            n=n,
            m=mFS,
            I_11=I_FS_11,
            I_22=I_FS_22,
            I_33=I_FS_33,
            I_21=I_FS_21,
            I_31=I_FS_31,
            I_32=I_FS_32,
            CoM_FS=CoM_FS,
            bias=bias,
            spring_table=spring_table,
            damper_table=damper_table)
                          annotation (extent=[-80,-30; -60,-10],rotation=90);
          MultiBondLib.Mechanics3D.Joints.Revolute FWRevolute(
            phi(stateSelect=StateSelect.always),
            phi_start=0,
            animation=true,
            cylinderDiameter=0.08,
            cylinderColor={255,0,0},
            initType=Modelica.Mechanics.MultiBody.Types.Init.Position,
            cylinderLength=0.2,
            enforceStates=true)
            annotation (extent=[-80,-60; -60,-40], rotation=90);
        equation
         if cardinality(T_Steering) <= 1 then
            T_Steering = 0;
            switch1.u2 = false;
          else
            switch1.u2 = true;
          end if;
          connect(SteeringAxis, SteeringAxis) annotation (points=[50,40; 50,40],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Mass.frame_a,FixedTranslation. frame_b)            annotation (
              points=[-90,49; -90,31], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=10,
              rgbfillColor={95,95,95}));
          connect(damper.flange_a,Steering. axis) annotation (points=[10,34; 10,
                47; 7,47],
                       style(color=0, rgbcolor={0,0,0}));
          connect(damper.flange_b,Steering. bearing) annotation (points=[-10,34;
                -10,47; -7,47],
                         style(color=0, rgbcolor={0,0,0}));
          connect(SteeringTorque.flange_b, damper.flange_a) annotation (points=[28,0; 28,
                34; 10,34],                    style(color=0, rgbcolor={0,0,0}));
          connect(damper1.flange_b, TwistAxis.bearing) annotation (points=[-50,34;
                -50,47; -47,47], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(damper1.flange_a, TwistAxis.axis) annotation (points=[-30,34;
                -30,47; -33,47], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(TwistAxis.frame_b, Steering.frame_a) annotation (points=[-29,54;
                -11,54],style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(TwistAxis.frame_a, FixedTranslation_Offset.frame_b) annotation (
             points=[-51,54; -70,54; -70,31], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillPattern=1));
          connect(spring.flange_b, damper1.flange_b) annotation (points=[-50,12;
                -50,34], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(spring.flange_a, damper1.flange_a) annotation (points=[-30,12;
                -30,34], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(angleSensor.flange_a, damper.flange_a) annotation (points=[10,28;
                10,31; 10,31; 10,34],     style(color=0, rgbcolor={0,0,0}));
          connect(angleSensor.phi, y) annotation (points=[10,8; 10,4; 0,4; 0,
                -10],
              style(color=74, rgbcolor={0,0,127}));
          connect(y, y) annotation (points=[0,-10; 0,-10], style(color=74,
                rgbcolor={0,0,127}));
          connect(const.y, switch1.u3) annotation (points=[79,-80; 72,-80; 72,-58;
                62,-58], style(color=74, rgbcolor={0,0,127}));
          connect(T_Steering, switch1.u1) annotation (points=[0,95; 0,72; 72,72;
                72,-42; 62,-42], style(color=74, rgbcolor={0,0,127}));
          connect(switch1.y, SteeringTorque.tau) annotation (points=[39,-50; 28,
                -50; 28,-21], style(color=74, rgbcolor={0,0,127}));
          connect(Steering.frame_b, SteeringAxis) annotation (points=[11,54; 22,
                54; 22,40; 50,40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(frontSuspension.FrontWheel, FWRevolute.frame_b) annotation (
              points=[-70,-30.8; -70,-39], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
          connect(frontSuspension.SteeringAxis, FixedTranslation_Offset.frame_a)
            annotation (points=[-70,-9.2; -70,9], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
          connect(FixedTranslation.frame_a, frontSuspension.SteeringAxis)
            annotation (points=[-90,9; -90,0; -70,0; -70,-9.2], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
          connect(FWRevolute.frame_a, RevoltueAxis) annotation (points=[-70,-61;
                -70,-72; 0,-72; 0,-100], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=1,
              fillColor=3,
              rgbfillColor={0,0,255}));
        end FrontFrameUSD_Ind;

        package FrontSuspensions
          model FrontSuspensionClassic
            "Telescopic Motorcycle Front Suspension including an elasto-gap"

            import SI = Modelica.SIunits;
            import MB = Modelica.Mechanics.MultiBody;

            parameter Real c(
              final unit="N/m",
              final min=0) = 1 "Spring constant of the front suspension";

            parameter Real d(
              final unit="N/(m/s)",
              final min=0) = 0 "Damping constant of the front suspension";

            parameter SI.Distance s_rel0=0 "Unstretched spring length";
            parameter SI.Distance bias = 0 "Pre-load of the spring";

            parameter SI.Distance r[3] = {1,0,0} "Unsprung length";
            parameter SI.Position n[3] = {1,0,0}
              "direction of front suspension (joint axis)";

            parameter SI.Mass m = 1 "mass of front suspension";

            parameter SI.Position CoM_FS[3] = {0,0,0}
              "Center of mass front frame";

            parameter SI.Inertia I_11=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (1,1) element of inertia tensor";

            parameter SI.Inertia I_22=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,2) element of inertia tensor";

            parameter SI.Inertia I_33=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,3) element of inertia tensor";

            parameter SI.Inertia I_21=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,1) element of inertia tensor";

            parameter SI.Inertia I_31=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,1) element of inertia tensor";

            parameter SI.Inertia I_32=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,2) element of inertia tensor";

          // Animation
          public
            SI.Distance s;
            SI.Distance d_spring[3];

            parameter MB.Types.Color springColor = {0,0,205}
              "|Animation || Color of the Front Suspension";
            parameter MB.Types.Color HandleBarColor = {155,155,155}
              "|Animation || Color of the HandleBar";

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWPipeLeft(
              shapeType="cylinder",
              color=HandleBarColor,
              width=0.05,
              height=0.05,
              lengthDirection=actuatedPrismatic.n,
              r_shape=-{0,0,0.11},
              length=-(FrontFrame.length + s),
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspLeft(
              shapeType="spring",
              color=springColor,
              width=0.06,
              height=0.025,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,-0.11},
              length=s*0.6,
              r=FrontWheel.P.x,
              extra = 6,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWPipeRight(
              shapeType="cylinder",
              color=HandleBarColor,
              width=0.05,
              height=0.05,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,0.11},
              length=-(FrontFrame.length + s),
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspRight(
              shapeType="spring",
              color=springColor,
              width=0.06,
              height=0.025,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,0.11},
              length=s*0.6,
              r=FrontWheel.P.x,
              extra = 6,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

           Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FrontPlate(
              shapeType="box",
              color=HandleBarColor,
              width=0.02,
              height=0.2,
              lengthDirection=actuatedPrismatic.n,
              r_shape={-0.025,0.01,0},
              length=-0.25,
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            MultiBondLib.Mechanics3D.Interfaces.Frame_a FrontWheel
              annotation (extent=[-122,-22; -94,22]);
            MultiBondLib.Mechanics3D.Interfaces.Frame_b SteeringAxis
              annotation (extent=[94,-22; 122,22]);
            annotation (Diagram, Icon(
                Rectangle(extent=[-96,14; 96,-14],  style(
                    color=0,
                    rgbcolor={0,0,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Text(extent=[-114,106; 116,48], string="%name"),
                Text(
                  extent=[-104,10; -64,-10],
                  string="a",
                  style(color=1, rgbcolor={255,0,0})),
                Text(
                  extent=[62,10; 102,-10],
                  string="b",
                  style(color=1, rgbcolor={255,0,0})),
                Line(points=[-74,60; -44,-60; -32,-14], style(
                    color=45,
                    rgbcolor={255,128,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[-26,14; -14,60; 16,-60; 28,-14], style(
                    color=45,
                    rgbcolor={255,128,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[34,14; 46,60; 76,-60], style(
                    color=45,
                    rgbcolor={255,128,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[-74,60; -74,14], style(
                    color=45,
                    rgbcolor={255,128,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[76,-60; 76,-14], style(
                    color=45,
                    rgbcolor={255,128,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95}))));
            MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontFrame(                r=r,
                animation=false)                     annotation (extent=[20,-50; 40,
                  -30]);
            MultiBondLib.Mechanics3D.Joints.ActuatedPrismatic actuatedPrismatic(
              s_offset=0,
              boxColor={155,0,0},
              n=n,
              s_start=s_rel0,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
              animation=false)    annotation (extent=[-40,-50; -20,-30],
                                                                      rotation=0);
            BondLib.Mechanical.Translational.Passive.Spring spring(               c=
                 c, s_rel0=s_rel0 + bias)
              annotation (extent=[-40,-2; -20,18], rotation=0);
            BondLib.Mechanical.Translational.Passive.Damper damper(d=d)
              annotation (extent=[-40,-24; -20,-4],rotation=0);
            ElastoGap elastoGap(
              s_rel0=s_rel0,
              c=1e5,
              d=1e4)               annotation (extent=[-40,20; -20,40],
                                                                      rotation=180);
            ElastoGap elastoGap1(
              s_rel0=s_rel0,
              c=1e5,
              d=1e4)               annotation (extent=[-40,40; -20,60],
                                                                      rotation=0);
            MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontSuspensionCoM(
                animation=false, r=CoM_FS)           annotation (extent=[50,10;
                  70,30],
                rotation=270);
            MultiBondLib.Mechanics3D.Parts.SimpleBody FrontSuspensionMass(
              sphereDiameter=0.1,
              m=m,
              I_11=I_11,
              I_22=I_22,
              I_33=I_33,
              I_21=I_21,
              I_31=I_31,
              I_32=I_32,
              animation=true)
                   annotation (extent=[50,42; 70,62],   rotation=90);
          equation
            d_spring = actuatedPrismatic.frame_b.P.x - actuatedPrismatic.frame_a.P.x;
            s = sqrt(d_spring*d_spring);
            connect(SteeringAxis, SteeringAxis) annotation (points=[108,0; 108,0],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(spring.flange_a, damper.flange_a)  annotation (points=[-40,8;
                  -40,-14],style(color=58, rgbcolor={0,127,0}));
            connect(spring.flange_b, damper.flange_b)  annotation (points=[-20.1,8;
                  -20,8; -20,-14; -20.1,-14],    style(color=58, rgbcolor={0,127,0}));
            connect(actuatedPrismatic.bearing, damper.flange_a) annotation (points=[-36,-33;
                  -40,-33; -40,-14],       style(color=58, rgbcolor={0,127,0}));
            connect(actuatedPrismatic.axis, damper.flange_b) annotation (points=[-23,-33;
                  -20.1,-33; -20.1,-14],    style(color=58, rgbcolor={0,127,0}));
            connect(FrontFrame.frame_a, actuatedPrismatic.frame_b) annotation (points=[19,-40;
                  -19,-40],       style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=46,
                rgbfillColor={198,133,43},
                fillPattern=1));
            connect(FrontFrame.frame_b, SteeringAxis) annotation (points=[41,-40;
                  60,-40; 60,0; 108,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=46,
                rgbfillColor={198,133,43},
                fillPattern=1));
            connect(actuatedPrismatic.frame_a, FrontWheel) annotation (points=[-41,-40;
                  -60,-40; -60,0; -108,0],      style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=46,
                rgbfillColor={198,133,43},
                fillPattern=1));
            connect(elastoGap.flange_b, spring.flange_a) annotation (points=[-40,30;
                  -40,8], style(color=58, rgbcolor={0,127,0}));
            connect(elastoGap.flange_a, spring.flange_b) annotation (points=[-20,30;
                  -20.1,30; -20.1,8],
                                    style(color=58, rgbcolor={0,127,0}));
            connect(elastoGap1.flange_a, elastoGap.flange_b) annotation (points=[-40,50;
                  -40,30],         style(
                color=58,
                rgbcolor={0,127,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172}));
            connect(elastoGap1.flange_b, elastoGap.flange_a) annotation (points=[-20,50;
                  -20,30],     style(
                color=58,
                rgbcolor={0,127,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172}));
            connect(FrontSuspensionCoM.frame_a, FrontSuspensionMass.frame_a)
              annotation (points=[60,31; 60,41], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(FrontSuspensionCoM.frame_b, SteeringAxis) annotation (
                points=[60,9; 60,0; 108,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
          end FrontSuspensionClassic;

          model FrontSuspensionClassicPreload
            "Telescopic Motorcycle Front Suspension including an elasto-gap and a preload force"

            import SI = Modelica.SIunits;
            import MB = Modelica.Mechanics.MultiBody;

            parameter Real c(
              final unit="N/m",
              final min=0) = 1 "Spring constant of the front suspension";

            parameter Real d(
              final unit="N/(m/s)",
              final min=0) = 0 "Damping constant of the front suspension";

            parameter SI.Distance s_rel0=0 "Unstretched spring length";
            parameter SI.Force preload = 0 "Front suspension preload";
            parameter SI.Distance dmax = 0.03
              "Displacement of lower suspension from nominal to give rebound stop contace";
            parameter SI.Distance dmin = 0.07
              "Corresponding bump displacement for bump stop contace";

            parameter SI.Distance r[3] = {1,0,0} "Unsprung length";
            parameter SI.Position n[3] = {1,0,0}
              "direction of front suspension (joint axis)";

            parameter SI.Mass m = 1 "mass of front suspension";

            parameter SI.Position CoM_FS[3] = {0,0,0}
              "Center of mass front frame";

            parameter SI.Inertia I_11=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (1,1) element of inertia tensor";

            parameter SI.Inertia I_22=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,2) element of inertia tensor";

            parameter SI.Inertia I_33=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,3) element of inertia tensor";

            parameter SI.Inertia I_21=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,1) element of inertia tensor";

            parameter SI.Inertia I_31=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,1) element of inertia tensor";

            parameter SI.Inertia I_32=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,2) element of inertia tensor";

          // Animation
          public
            SI.Distance s;
            SI.Distance d_spring[3];

            parameter MB.Types.Color springColor = {0,0,205}
              "|Animation || Color of the Front Suspension";
            parameter MB.Types.Color HandleBarColor = {155,155,155}
              "|Animation || Color of the HandleBar";

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWPipeLeft(
              shapeType="cylinder",
              color=HandleBarColor,
              width=0.05,
              height=0.05,
              lengthDirection=actuatedPrismatic.n,
              r_shape=-{0,0,0.11},
              length=-(FrontFrame.length + s),
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspLeft(
              shapeType="spring",
              color=springColor,
              width=0.06,
              height=0.02,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,-0.11},
              length=s,
              r=FrontWheel.P.x,
              extra = 6,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWPipeRight(
              shapeType="cylinder",
              color=HandleBarColor,
              width=0.05,
              height=0.05,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,0.11},
              length=-(FrontFrame.length + s),
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspRight(
              shapeType="spring",
              color=springColor,
              width=0.06,
              height=0.02,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,0.11},
              length=s,
              r=FrontWheel.P.x,
              extra = 6,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

           Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FrontPlate(
              shapeType="box",
              color=HandleBarColor,
              width=0.02,
              height=0.2,
              lengthDirection=actuatedPrismatic.n,
              r_shape={-0.025,0.01,0},
              length=-0.25,
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

           // Animation of the preload force
            parameter MB.Types.Color arrowColor = {0,0, 255} "|Visualisation|";
            parameter Real arrowDiameter = 0.02 "|Visualisation|";

            MotorcycleLib.Utilities.Arrow normalForce(
              each r=actuatedPrismatic.frame_b.P.x,
              each r_tail=zeros(3),
              each r_head=actuatedPrismatic.n,
              each diameter=arrowDiameter,
              each color=arrowColor,
              each specularCoefficient=0,
              each R=MB.Frames.Orientation(T=actuatedPrismatic.frame_b.P.R, w=
                  zeros(3)));

            MultiBondLib.Mechanics3D.Interfaces.Frame_a FrontWheel
              annotation (extent=[-122,-22; -94,22]);
            MultiBondLib.Mechanics3D.Interfaces.Frame_b SteeringAxis
              annotation (extent=[94,-22; 122,22]);
            annotation (Diagram, Icon(
                Rectangle(extent=[-96,14; 96,-14],  style(
                    color=0,
                    rgbcolor={0,0,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Text(extent=[-114,106; 116,48], string="%name"),
                Text(
                  extent=[-104,10; -64,-10],
                  string="a",
                  style(color=1, rgbcolor={255,0,0})),
                Text(
                  extent=[62,10; 102,-10],
                  string="b",
                  style(color=1, rgbcolor={255,0,0})),
                Line(points=[-74,60; -44,-60; -32,-14], style(
                    color=78,
                    rgbcolor={127,0,127},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[-26,14; -14,60; 16,-60; 28,-14], style(
                    color=78,
                    rgbcolor={127,0,127},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[34,14; 46,60; 76,-60], style(
                    color=78,
                    rgbcolor={127,0,127},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[-74,60; -74,14], style(
                    color=78,
                    rgbcolor={127,0,127},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[76,-60; 76,-14], style(
                    color=78,
                    rgbcolor={127,0,127},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95}))));
            MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontFrame(                r=r,
                animation=false)                     annotation (extent=[20,-50; 40,
                  -30]);
            MultiBondLib.Mechanics3D.Joints.ActuatedPrismatic actuatedPrismatic(
              s_offset=0,
              boxColor={155,0,0},
              n=n,
              s_start=s_rel0,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
              animation=false)    annotation (extent=[-20,-50; 0,-30],rotation=0);
            BondLib.Mechanical.Translational.Passive.Spring spring(               c=
                 c, s_rel0=s_rel0)
              annotation (extent=[-20,-2; 0,18],   rotation=0);
            BondLib.Mechanical.Translational.Passive.Damper damper(d=d)
              annotation (extent=[-20,-24; 0,-4],  rotation=0);
            MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontSuspensionCoM(
                animation=false, r=CoM_FS)           annotation (extent=[50,10;
                  70,30],
                rotation=270);
            MultiBondLib.Mechanics3D.Parts.SimpleBody FrontSuspensionMass(
              sphereDiameter=0.1,
              m=m,
              I_11=I_11,
              I_22=I_22,
              I_33=I_33,
              I_21=I_21,
              I_31=I_31,
              I_32=I_32,
              animation=true)
                   annotation (extent=[50,42; 70,62],   rotation=90);
            ElastoGap elastoGap_bump(
              d=1e4,
              s_rel0=s_rel0 + dmin,
              c=1e5)               annotation (extent=[-20,20; 0,40], rotation=180);
            ElastoGap elastoGap_rebound(
              d=1e4,
              s_rel0=s_rel0 + dmax,
              c=1e5)               annotation (extent=[-20,40; 0,60], rotation=0);
            Modelica.Blocks.Sources.Constant const(k=preload)
              annotation (extent=[-60,-80; -40,-60]);
            BondLib.Mechanical.Translational.Sources.Force force
              annotation (extent=[-10,-80; 10,-60], rotation=0);
          equation
            d_spring = actuatedPrismatic.frame_b.P.x - actuatedPrismatic.frame_a.P.x;
            s = sqrt(d_spring*d_spring);
            connect(SteeringAxis, SteeringAxis) annotation (points=[108,0; 108,0],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(spring.flange_a, damper.flange_a)  annotation (points=[-20,8;
                  -20,-14],style(color=58, rgbcolor={0,127,0}));
            connect(spring.flange_b, damper.flange_b)  annotation (points=[-0.1,8;
                  0,8; 0,-14; -0.1,-14],         style(color=58, rgbcolor={0,127,0}));
            connect(actuatedPrismatic.bearing, damper.flange_a) annotation (points=[-16,-33;
                  -20,-33; -20,-14],       style(color=58, rgbcolor={0,127,0}));
            connect(actuatedPrismatic.axis, damper.flange_b) annotation (points=[-3,-33;
                  -0.1,-33; -0.1,-14],      style(color=58, rgbcolor={0,127,0}));
            connect(FrontFrame.frame_a, actuatedPrismatic.frame_b) annotation (points=[
                  19,-40; 1,-40], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=46,
                rgbfillColor={198,133,43},
                fillPattern=1));
            connect(FrontFrame.frame_b, SteeringAxis) annotation (points=[41,-40;
                  60,-40; 60,0; 108,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=46,
                rgbfillColor={198,133,43},
                fillPattern=1));
            connect(actuatedPrismatic.frame_a, FrontWheel) annotation (points=[-21,-40;
                  -60,-40; -60,0; -108,0],      style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=46,
                rgbfillColor={198,133,43},
                fillPattern=1));
            connect(elastoGap_bump.flange_b, spring.flange_a)
                                                         annotation (points=[-20,30;
                  -20,8], style(color=58, rgbcolor={0,127,0}));
            connect(elastoGap_bump.flange_a, spring.flange_b)
                                                         annotation (points=[0,30;
                  -0.1,30; -0.1,8], style(color=58, rgbcolor={0,127,0}));
            connect(elastoGap_rebound.flange_a, elastoGap_bump.flange_b)
                                                             annotation (points=[-20,50;
                  -20,30],         style(
                color=58,
                rgbcolor={0,127,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172}));
            connect(elastoGap_rebound.flange_b, elastoGap_bump.flange_a)
                                                             annotation (points=[0,50; 0,
                  30],         style(
                color=58,
                rgbcolor={0,127,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172}));
            connect(force.flange_b, damper.flange_b) annotation (points=[10,-70;
                  10,-14; -0.1,-14], style(color=58, rgbcolor={0,127,0}));
            connect(force.f, const.y) annotation (points=[-9,-70; -39,-70],
                style(color=74, rgbcolor={0,0,127}));
            connect(FrontSuspensionCoM.frame_b, SteeringAxis) annotation (
                points=[60,9; 60,0; 108,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(FrontSuspensionCoM.frame_a, FrontSuspensionMass.frame_a)
              annotation (points=[60,31; 60,41], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
          end FrontSuspensionClassicPreload;

          model FrontSuspensionClassic_Ind
            "Telescopic Motorcycle Front Suspension based on table data to simulate real damper and spring characteristics"

            import SI = Modelica.SIunits;
            import MB = Modelica.Mechanics.MultiBody;

            parameter Real spring_table[:,:] = [0,0; 1,1]
              "Spring characteristics of the front suspension";
            parameter Real damper_table[:,:] = [0,0; 1,1]
              "Damper characteristics of the front suspension";

            parameter SI.Distance s_rel0=0 "Unstretched spring length";
            parameter SI.Distance bias = 0 "Pre-load of the spring";

            parameter SI.Distance r[3] = {1,0,0} "Unsprung length";
            parameter SI.Position n[3] = {1,0,0}
              "direction of front suspension (joint axis)";

            parameter SI.Mass m = 1 "mass of front suspension";

            parameter SI.Position CoM_FS[3] = {0,0,0}
              "Center of mass front frame";

            parameter SI.Inertia I_11=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (1,1) element of inertia tensor";

            parameter SI.Inertia I_22=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,2) element of inertia tensor";

            parameter SI.Inertia I_33=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,3) element of inertia tensor";

            parameter SI.Inertia I_21=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,1) element of inertia tensor";

            parameter SI.Inertia I_31=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,1) element of inertia tensor";

            parameter SI.Inertia I_32=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,2) element of inertia tensor";

          // Animation
          public
            SI.Distance s;
            SI.Distance d_spring[3];

            parameter MB.Types.Color springColor = {0,0,205}
              "|Animation || Color of the Front Suspension";
            parameter MB.Types.Color HandleBarColor = {155,155,155}
              "|Animation || Color of the HandleBar";

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWPipeLeft(
              shapeType="cylinder",
              color=HandleBarColor,
              width=0.05,
              height=0.05,
              lengthDirection=actuatedPrismatic.n,
              r_shape=-{0,0,0.11},
              length=-(FrontFrame.length + s),
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspLeft(
              shapeType="spring",
              color=springColor,
              width=0.06,
              height=0.025,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,-0.11},
              length=s*0.6,
              r=FrontWheel.P.x,
              extra = 6,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWPipeRight(
              shapeType="cylinder",
              color=HandleBarColor,
              width=0.05,
              height=0.05,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,0.11},
              length=-(FrontFrame.length + s),
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspRight(
              shapeType="spring",
              color=springColor,
              width=0.06,
              height=0.025,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,0.11},
              length=s*0.6,
              r=FrontWheel.P.x,
              extra = 6,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

           Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FrontPlate(
              shapeType="box",
              color=HandleBarColor,
              width=0.02,
              height=0.2,
              lengthDirection=actuatedPrismatic.n,
              r_shape={-0.025,0.01,0},
              length=-0.25,
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            MultiBondLib.Mechanics3D.Interfaces.Frame_a FrontWheel
              annotation (extent=[-122,-22; -94,22]);
            MultiBondLib.Mechanics3D.Interfaces.Frame_b SteeringAxis
              annotation (extent=[94,-22; 122,22]);
            annotation (Diagram, Icon(
                Rectangle(extent=[-96,14; 96,-14],  style(
                    color=0,
                    rgbcolor={0,0,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Text(extent=[-114,106; 116,48], string="%name"),
                Text(
                  extent=[-104,10; -64,-10],
                  string="a",
                  style(color=1, rgbcolor={255,0,0})),
                Text(
                  extent=[62,10; 102,-10],
                  string="b",
                  style(color=1, rgbcolor={255,0,0})),
                Line(points=[-74,60; -44,-60; -32,-14], style(
                    color=2,
                    rgbcolor={0,255,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[-26,14; -14,60; 16,-60; 28,-14], style(
                    color=2,
                    rgbcolor={0,255,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[34,14; 46,60; 76,-60], style(
                    color=2,
                    rgbcolor={0,255,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[-74,60; -74,14], style(
                    color=2,
                    rgbcolor={0,255,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[76,-60; 76,-14], style(
                    color=2,
                    rgbcolor={0,255,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95}))));
            MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontFrame(                r=r,
                animation=false)                     annotation (extent=[20,-50;
                  40,-30]);
            MultiBondLib.Mechanics3D.Joints.ActuatedPrismatic actuatedPrismatic(
              s_offset=0,
              boxColor={155,0,0},
              n=n,
              s_start=s_rel0,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
              animation=false)    annotation (extent=[-40,-50; -20,-30],
                                                                      rotation=0);
            Utilities.CharacteristicSpring characteristicSpring(s_rel0=s_rel0
                   + bias, spring_table=spring_table)
              annotation (extent=[-40,0; -20,20]);
            Utilities.CharacteristicDamper characteristicDamper(damper_table=
                  damper_table) annotation (extent=[-40,-22; -20,-2]);
            MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontSuspensionCoM1
              ( animation=false, r=CoM_FS)           annotation (extent=[50,10;
                  70,30],
                rotation=270);
            MultiBondLib.Mechanics3D.Parts.SimpleBody FrontSuspensionMass1(
              sphereDiameter=0.1,
              m=m,
              I_11=I_11,
              I_22=I_22,
              I_33=I_33,
              I_21=I_21,
              I_31=I_31,
              I_32=I_32,
              animation=true)
                   annotation (extent=[50,42; 70,62],   rotation=90);
          equation
            d_spring = actuatedPrismatic.frame_b.P.x - actuatedPrismatic.frame_a.P.x;
            s = sqrt(d_spring*d_spring);
            connect(SteeringAxis, SteeringAxis) annotation (points=[108,0; 108,0],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(FrontFrame.frame_a, actuatedPrismatic.frame_b) annotation (points=[19,-40;
                  -19,-40],       style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=46,
                rgbfillColor={198,133,43},
                fillPattern=1));
            connect(FrontFrame.frame_b, SteeringAxis) annotation (points=[41,-40;
                  60,-40; 60,0; 108,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=46,
                rgbfillColor={198,133,43},
                fillPattern=1));
            connect(actuatedPrismatic.frame_a, FrontWheel) annotation (points=[-41,-40;
                  -60,-40; -60,0; -108,0],      style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2,
                fillColor=46,
                rgbfillColor={198,133,43},
                fillPattern=1));
            connect(characteristicSpring.flange_a, characteristicDamper.flange_a)
              annotation (points=[-40,10; -40,-12], style(color=58, rgbcolor={0,
                    127,0}));
            connect(characteristicDamper.flange_a, actuatedPrismatic.bearing)
              annotation (points=[-40,-12; -40,-33; -36,-33], style(color=58,
                  rgbcolor={0,127,0}));
            connect(characteristicSpring.flange_b, characteristicDamper.flange_b)
              annotation (points=[-20.1,10; -20,-2; -20.1,-2; -20.1,-12],
                style(color=58, rgbcolor={0,127,0}));
            connect(characteristicDamper.flange_b, actuatedPrismatic.axis)
              annotation (points=[-20.1,-12; -20,-12; -20,-33; -23,-33],
                                                                   style(color=
                    58, rgbcolor={0,127,0}));
            connect(FrontSuspensionCoM1.frame_a, FrontSuspensionMass1.frame_a)
              annotation (points=[60,31; 60,41], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(FrontSuspensionCoM1.frame_b, SteeringAxis) annotation (
                points=[60,9; 60,0; 108,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
          end FrontSuspensionClassic_Ind;

          model FrontSuspensionUSD
            "Upside down Telescopic Motorcycle Front Suspension  including an elasto-gap "

            import SI = Modelica.SIunits;
            import MB = Modelica.Mechanics.MultiBody;

            parameter Real c(
              final unit="N/m",
              final min=0) = 1 "Spring constant of the front suspension";

            parameter Real d(
              final unit="N/(m/s)",
              final min=0) = 0 "Damping constant of the front suspension";

            parameter SI.Distance s_rel0=0 "Unstretched spring length";
            parameter SI.Distance bias = 0 "Pre-load of the spring";

            parameter SI.Distance r[3] = {1,0,0} "Unsprung length";
            parameter SI.Position n[3] = {1,0,0}
              "direction of front suspension (joint axis)";

            parameter SI.Mass m = 1 "mass of front suspension";

            parameter SI.Position CoM_FS[3] = {0,0,0}
              "Center of mass front frame";

            parameter SI.Inertia I_11=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (1,1) element of inertia tensor";

            parameter SI.Inertia I_22=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,2) element of inertia tensor";

            parameter SI.Inertia I_33=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,3) element of inertia tensor";

            parameter SI.Inertia I_21=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,1) element of inertia tensor";

            parameter SI.Inertia I_31=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,1) element of inertia tensor";

            parameter SI.Inertia I_32=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,2) element of inertia tensor";

          // Animation
          public
            SI.Distance s;
            SI.Distance d_spring[3];

            parameter MB.Types.Color springColor = {0,0,205}
              "|Animation || Color of the Front Suspension";
            parameter MB.Types.Color HandleBarColor = {155,155,155}
              "|Animation || Color of the HandleBar";

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWPipeLeft(
              shapeType="cylinder",
              color=HandleBarColor,
              width=0.05,
              height=0.05,
              lengthDirection=-actuatedPrismatic.n,
              r_shape=-{0,0,0.11},
              length=FrontFrame.length + s,
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspLeft(
              shapeType="spring",
              color=springColor,
              width=0.06,
              height=0.025,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,-0.11},
              length=-s,
              r=SteeringAxis.P.x,
              extra = 4,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWPipeRight(
              shapeType="cylinder",
              color=HandleBarColor,
              width=0.05,
              height=0.05,
              lengthDirection=-actuatedPrismatic.n,
              r_shape={0,0,0.11},
              length=FrontFrame.length + s,
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspRight(
              shapeType="spring",
              color=springColor,
              width=0.06,
              height=0.025,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,0.11},
              length=-s,
              r=SteeringAxis.P.x,
              extra = 4,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FrontPlate(
              shapeType="box",
              color=HandleBarColor,
              width=0.02,
              height=0.2,
              lengthDirection=actuatedPrismatic.n,
              r_shape={-0.025,0.01,0},
              length=0.1,
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            MultiBondLib.Mechanics3D.Interfaces.Frame_a FrontWheel
              annotation (extent=[-122,-22; -94,22]);
            MultiBondLib.Mechanics3D.Interfaces.Frame_b SteeringAxis
              annotation (extent=[94,-22; 122,22]);
            annotation (Diagram, Icon(
                Rectangle(extent=[-96,14; 96,-14],  style(
                    color=0,
                    rgbcolor={0,0,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Text(extent=[-114,106; 116,48], string="%name"),
                Text(
                  extent=[-104,10; -64,-10],
                  string="a",
                  style(color=1, rgbcolor={255,0,0})),
                Text(
                  extent=[62,10; 102,-10],
                  string="b",
                  style(color=1, rgbcolor={255,0,0})),
                Line(points=[-74,60; -44,-60; -32,-14], style(
                    color=45,
                    rgbcolor={255,128,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[-26,14; -14,60; 16,-60; 28,-14], style(
                    color=45,
                    rgbcolor={255,128,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[34,14; 46,60; 76,-60], style(
                    color=45,
                    rgbcolor={255,128,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[-74,60; -74,14], style(
                    color=45,
                    rgbcolor={255,128,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[76,-60; 76,-14], style(
                    color=45,
                    rgbcolor={255,128,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95}))));
            MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontFrame(                r=r,
                animation=false)                     annotation (extent=[-40,-50;
                  -20,-30]);
            MultiBondLib.Mechanics3D.Joints.ActuatedPrismatic actuatedPrismatic(
              s_offset=0,
              boxColor={155,0,0},
              n=n,
              s_start=s_rel0,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
              animation=false)    annotation (extent=[0,-50; 20,-30], rotation=0);
            BondLib.Mechanical.Translational.Passive.Spring spring(               c=
                 c, s_rel0=s_rel0 + bias)
              annotation (extent=[0,-2; 20,18],    rotation=0);
            BondLib.Mechanical.Translational.Passive.Damper damper(d=d)
              annotation (extent=[0,-24; 20,-4],   rotation=0);
            ElastoGap elastoGap(
              s_rel0=s_rel0,
              c=1e5,
              d=1e4)               annotation (extent=[0,20; 20,40],  rotation=180);
            ElastoGap elastoGap1(
              s_rel0=s_rel0,
              c=1e5,
              d=1e4)               annotation (extent=[0,40; 20,60],  rotation=0);
            MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontSuspensionCoM1
              ( animation=false, r=CoM_FS)           annotation (extent=[50,10;
                  70,30],
                rotation=270);
            MultiBondLib.Mechanics3D.Parts.SimpleBody FrontSuspensionMass1(
              sphereDiameter=0.1,
              m=m,
              I_11=I_11,
              I_22=I_22,
              I_33=I_33,
              I_21=I_21,
              I_31=I_31,
              I_32=I_32,
              animation=true)
                   annotation (extent=[50,42; 70,62],   rotation=90);
          equation
            d_spring = actuatedPrismatic.frame_b.P.x - actuatedPrismatic.frame_a.P.x;
            s = sqrt(d_spring*d_spring);
            connect(SteeringAxis, SteeringAxis) annotation (points=[108,0; 108,0],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(spring.flange_a, damper.flange_a)  annotation (points=[0,8; 0,
                  -14],    style(color=58, rgbcolor={0,127,0}));
            connect(spring.flange_b, damper.flange_b)  annotation (points=[19.9,8;
                  20,8; 20,-14; 19.9,-14],       style(color=58, rgbcolor={0,127,0}));
            connect(actuatedPrismatic.bearing, damper.flange_a) annotation (points=[4,-33; 0,
                  -33; 0,-14],             style(color=58, rgbcolor={0,127,0}));
            connect(actuatedPrismatic.axis, damper.flange_b) annotation (points=[17,-33;
                  19.9,-33; 19.9,-14],      style(color=58, rgbcolor={0,127,0}));
            connect(elastoGap.flange_b, spring.flange_a) annotation (points=[0,30; 0,
                  8],     style(color=58, rgbcolor={0,127,0}));
            connect(elastoGap.flange_a, spring.flange_b) annotation (points=[20,30;
                  19.9,30; 19.9,8], style(color=58, rgbcolor={0,127,0}));
            connect(FrontFrame.frame_b, actuatedPrismatic.frame_a) annotation (
                points=[-19,-40; -1,-40],
                                        style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(actuatedPrismatic.frame_b, SteeringAxis) annotation (points=[21,-40;
                  60,-40; 60,0; 108,0],      style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(FrontFrame.frame_a, FrontWheel) annotation (points=[-41,-40;
                  -60,-40; -60,0; -108,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(elastoGap1.flange_a, elastoGap.flange_b) annotation (points=[0,50; 0,
                  30],           style(
                color=58,
                rgbcolor={0,127,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172}));
            connect(elastoGap1.flange_b, elastoGap.flange_a) annotation (points=[20,50;
                  20,30],        style(
                color=58,
                rgbcolor={0,127,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172}));
            connect(FrontSuspensionCoM1.frame_a, FrontSuspensionMass1.frame_a)
              annotation (points=[60,31; 60,41], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(FrontSuspensionCoM1.frame_b, SteeringAxis) annotation (
                points=[60,9; 60,0; 108,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
          end FrontSuspensionUSD;

          model FrontSuspensionUSD_Ind
            "Upside down Telescopic Motorcycle Front Suspension based on table data to simulate real damper and spring characteristics"

            import SI = Modelica.SIunits;
            import MB = Modelica.Mechanics.MultiBody;

            parameter Real spring_table[:,:] = [0,0; 1,1]
              "Spring characteristics of the front suspension";
            parameter Real damper_table[:,:] = [0,0; 1,1]
              "Damper characteristics of the front suspension";

            parameter SI.Distance s_rel0=0 "Unstretched spring length";
            parameter SI.Distance bias = 0 "Pre-load of the spring";

            parameter SI.Distance r[3] = {1,0,0} "Unsprung length";
            parameter SI.Position n[3] = {1,0,0}
              "direction of front suspension (joint axis)";

            parameter SI.Mass m = 1 "mass of front suspension";

            parameter SI.Position CoM_FS[3] = {0,0,0}
              "Center of mass front frame";

            parameter SI.Inertia I_11=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (1,1) element of inertia tensor";

            parameter SI.Inertia I_22=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,2) element of inertia tensor";

            parameter SI.Inertia I_33=0.001
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,3) element of inertia tensor";

            parameter SI.Inertia I_21=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,1) element of inertia tensor";

            parameter SI.Inertia I_31=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,1) element of inertia tensor";

            parameter SI.Inertia I_32=0
              "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,2) element of inertia tensor";

          // Animation
          public
            SI.Distance s;
            SI.Distance d_spring[3];

            parameter MB.Types.Color springColor = {0,0,205}
              "|Animation || Color of the Front Suspension";
            parameter MB.Types.Color HandleBarColor = {155,155,155}
              "|Animation || Color of the HandleBar";

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWPipeLeft(
              shapeType="cylinder",
              color=HandleBarColor,
              width=0.05,
              height=0.05,
              lengthDirection=-actuatedPrismatic.n,
              r_shape=-{0,0,0.11},
              length=FrontFrame.length + s,
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspLeft(
              shapeType="spring",
              color=springColor,
              width=0.06,
              height=0.025,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,-0.11},
              length=-s,
              r=SteeringAxis.P.x,
              extra = 4,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWPipeRight(
              shapeType="cylinder",
              color=HandleBarColor,
              width=0.05,
              height=0.05,
              lengthDirection=-actuatedPrismatic.n,
              r_shape={0,0,0.11},
              length=FrontFrame.length + s,
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FWSuspRight(
              shapeType="spring",
              color=springColor,
              width=0.06,
              height=0.025,
              lengthDirection=actuatedPrismatic.n,
              r_shape={0,0,0.11},
              length=-s,
              r=SteeringAxis.P.x,
              extra = 4,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape FrontPlate(
              shapeType="box",
              color=HandleBarColor,
              width=0.02,
              height=0.2,
              lengthDirection=actuatedPrismatic.n,
              r_shape={-0.025,0.01,0},
              length=0.1,
              r=SteeringAxis.P.x,
              R=MB.Frames.Orientation(T=SteeringAxis.P.R,w=zeros(3)));

            MultiBondLib.Mechanics3D.Interfaces.Frame_a FrontWheel
              annotation (extent=[-122,-22; -94,22]);
            MultiBondLib.Mechanics3D.Interfaces.Frame_b SteeringAxis
              annotation (extent=[94,-22; 122,22]);
            annotation (Diagram, Icon(
                Rectangle(extent=[-96,14; 96,-14],  style(
                    color=0,
                    rgbcolor={0,0,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Text(extent=[-114,106; 116,48], string="%name"),
                Text(
                  extent=[-104,10; -64,-10],
                  string="a",
                  style(color=1, rgbcolor={255,0,0})),
                Text(
                  extent=[62,10; 102,-10],
                  string="b",
                  style(color=1, rgbcolor={255,0,0})),
                Line(points=[-74,60; -44,-60; -32,-14], style(
                    color=2,
                    rgbcolor={0,255,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[-26,14; -14,60; 16,-60; 28,-14], style(
                    color=2,
                    rgbcolor={0,255,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[34,14; 46,60; 76,-60], style(
                    color=2,
                    rgbcolor={0,255,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[-74,60; -74,14], style(
                    color=2,
                    rgbcolor={0,255,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95})),
                Line(points=[76,-60; 76,-14], style(
                    color=2,
                    rgbcolor={0,255,0},
                    gradient=2,
                    fillColor=10,
                    rgbfillColor={95,95,95}))));
            MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontFrame(                r=r,
                animation=false)                     annotation (extent=[-40,-50;
                  -20,-30]);
            MultiBondLib.Mechanics3D.Joints.ActuatedPrismatic actuatedPrismatic(
              s_offset=0,
              boxColor={155,0,0},
              n=n,
              s_start=s_rel0,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
              animation=false)    annotation (extent=[0,-50; 20,-30], rotation=0);
            Utilities.CharacteristicSpring characteristicSpring(s_rel0=s_rel0
                   + bias, spring_table=spring_table)
              annotation (extent=[0,0; 20,20]);
            Utilities.CharacteristicDamper characteristicDamper(damper_table=
                  damper_table) annotation (extent=[0,-20; 20,0]);
            MultiBondLib.Mechanics3D.Parts.FixedTranslation FrontSuspensionCoM1
              ( animation=false, r=CoM_FS)           annotation (extent=[50,10;
                  70,30],
                rotation=270);
            MultiBondLib.Mechanics3D.Parts.SimpleBody FrontSuspensionMass1(
              sphereDiameter=0.1,
              m=m,
              I_11=I_11,
              I_22=I_22,
              I_33=I_33,
              I_21=I_21,
              I_31=I_31,
              I_32=I_32,
              animation=true)
                   annotation (extent=[50,42; 70,62],   rotation=90);
          equation
            d_spring = actuatedPrismatic.frame_b.P.x - actuatedPrismatic.frame_a.P.x;
            s = sqrt(d_spring*d_spring);
            connect(SteeringAxis, SteeringAxis) annotation (points=[108,0; 108,0],
                style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(FrontFrame.frame_b, actuatedPrismatic.frame_a) annotation (
                points=[-19,-40; -1,-40],
                                        style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(actuatedPrismatic.frame_b, SteeringAxis) annotation (points=[21,-40;
                  60,-40; 60,0; 108,0],      style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(FrontFrame.frame_a, FrontWheel) annotation (points=[-41,-40;
                  -60,-40; -60,0; -108,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(characteristicSpring.flange_a, characteristicDamper.flange_a)
              annotation (points=[0,10; 0,-10],   style(color=58, rgbcolor={0,
                    127,0}));
            connect(characteristicDamper.flange_a, actuatedPrismatic.bearing)
              annotation (points=[0,-10; 0,-33; 4,-33],    style(color=58,
                  rgbcolor={0,127,0}));
            connect(characteristicSpring.flange_b, characteristicDamper.flange_b)
              annotation (points=[19.9,10; 20,10; 20,-10; 19.9,-10], style(
                  color=58, rgbcolor={0,127,0}));
            connect(characteristicDamper.flange_b, actuatedPrismatic.axis)
              annotation (points=[19.9,-10; 20,-10; 20,-33; 17,-33], style(
                  color=58, rgbcolor={0,127,0}));
            connect(FrontSuspensionCoM1.frame_a, FrontSuspensionMass1.frame_a)
              annotation (points=[60,31; 60,41], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(FrontSuspensionCoM1.frame_b, SteeringAxis) annotation (
                points=[60,9; 60,0; 108,0], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
          end FrontSuspensionUSD_Ind;
        end FrontSuspensions;
      end FrontFrames;

      package SwingingArms "Several different swinging arms are provided"
        model SwingingArm_classic "Basic Model of a Swinging Arm"

          import SI = Modelica.SIunits;
          import PI = Modelica.Constants.pi;
          import MB = Modelica.Mechanics.MultiBody;

          parameter Real c(
            final unit="N/m",
            final min=0) = 1 "Spring constant of the swinging arm suspension";

          parameter Real d(
            final unit="N/(m/s)",
            final min=0) = 0 "Damping constant of the swingning arm suspension";

          parameter SI.Mass mSA = 1 "Mass of swinging arm";

          parameter SI.Position R_rw = 1 "Rear wheel radius";
          final parameter SI.Distance p7[3] = {0, R_rw, 0};

          parameter SI.Position p11[3] = {1, 1, 0}
            "Attachment point swinging arm to rear frame";

          parameter SI.Position p12[3] = {1, 1, 0}
            "Attachment point rear spring to swinging arm";

          parameter SI.Position p13[3] = {1, 1, 0}
            "Attachment point rear spring to rear frame";

          parameter SI.Position p14[3] = {0,0,0} "Center of mass swinging arm";
          final parameter SI.Distance CoM_SA[3] = {-p14[1], p14[2] - R_rw, 0};

          final parameter SI.Distance s_rel0 = sqrt( (p13[1]-p12[1])*(p13[1]-p12[1]) + (p13[2]-p12[2])*(p13[2]-p12[2]))
            "Unstretched spring length";

          parameter SI.Distance bias = 0 "Pre-load of the spring";

          final parameter SI.Distance r[3] = {p11[1]-p7[1], p11[2]-p7[2], 0}
            "Swinging arm length";

          final parameter SI.Distance rs[3] = {p7[1]-p12[1], p12[2]-p7[2],0};
          final parameter SI.Distance rRS[3] = {p13[1]-p11[1],p11[2]-p13[2],0};

          // conditional declaration needed for the direction of the swinging arm suspension
          final parameter SI.Angle alpha = if p13[1]-p12[1] == 0 then PI/2 else Modelica.Math.atan((p13[2]-p12[2])/(p13[1]-p12[1]));

          final parameter SI.Position n[3] = {cos(alpha), sin(alpha), 0}
            "Direction of swinging arm suspension (joint axis)";

          parameter SI.Inertia I_11=0.001
            "|Inertia tensor|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_22=0.001
            "|Inertia tensor|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_33=0.001
            "|Inertia tensor|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_21=0
            "|Inertia tensor|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_31=0
            "|Inertia tensor|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_32=0
            "|Inertia tensor|| (3,2) element of inertia tensor";

        // Animation
        public
          SI.Distance s;
          SI.Distance d_spring[3];

          parameter MB.Types.Color FrameColor = {255,165,0}
            "|Animation || Color of the Rear Frame";
          parameter MB.Types.Color FrameColor2 = {255,127,0}
            "|Animation || Color of the Rear Frame's lower parts";
          parameter MB.Types.Color springColor = {0,0,205}
            "|Animation || Color of the Front Suspension";

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW12Right(
             lengthDirection= {-1,0,0} "Vector in length direction",
             length=fixedTranslation.r[1] "Length of visual object",
             shapeType="cylinder",
             color=FrameColor2,
             width=0.06 "Width of visual object",
             height=0.04 "Height of visual object",
             r_shape={0,0,0.1},
             r=fixedTranslation.frame_b.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW12Left(
             lengthDirection= {-1,0,0} "Vector in length direction",
             length=fixedTranslation.r[1] "Length of visual object",
             shapeType="cylinder",
             color=FrameColor2,
             width=0.06 "Width of visual object",
             height=0.04 "Height of visual object",
             r_shape={0,0,-0.1},
             r=fixedTranslation.frame_b.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspLeft(
            shapeType="spring",
            color=springColor,
            width=0.06,
            height=0.025,
            lengthDirection=rearSuspension.actuatedPrismatic.n,
            r_shape={0,0,-0.11},
            length=s,
            r=RWRevolute2.frame_b.P.x,
            extra = 6,
            R=MB.Frames.Orientation(T=RWRevolute2.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspRight(
            shapeType="spring",
            color=springColor,
            width=0.06,
            height=0.025,
            lengthDirection=rearSuspension.actuatedPrismatic.n,
            r_shape={0,0,0.11},
            length=s,
            r=RWRevolute2.frame_b.P.x,
            extra = 6,
            R=MB.Frames.Orientation(T=RWRevolute2.frame_b.P.R,w=zeros(3)));

          MultiBondLib.Mechanics3D.Interfaces.Frame_a RearFrameCon1
            annotation (extent=[-128,-62; -100,-18]);
          MultiBondLib.Mechanics3D.Interfaces.Frame_b RearWheel
            annotation (extent=[100,-62; 128,-18]);
          annotation (Diagram, Icon(
              Polygon(points=[-28,92; 12,-26; 20,-26; -20,92; -24,92; -28,92],
                                                                         style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=0,
                  rgbfillColor={0,0,0})),
              Rectangle(extent=[-100,-26; 100,-54],
                                                  style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95})),
              Text(extent=[-100,-60; 60,-100],string="%name"),
              Text(
                extent=[-104,-30; -64,-50],
                string="a",
                style(color=1, rgbcolor={255,0,0})),
              Text(
                extent=[62,-30; 102,-50],
                string="b",
                style(color=1, rgbcolor={255,0,0})),
              Line(points=[-50,82; 12,82; -10,64],style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[-18,58; -40,40; 26,40; 4,22],style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[-4,16; -26,-2; 36,-2],
                                               style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[80,-100; 66,-80; 60,-60; 60,-20; 66,0; 80,20; 80,20],
                  style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillPattern=1)),
              Polygon(points=[82,12; 74,24; 92,26; 82,12],   style(
                  color=0,
                  fillColor=0,
                  fillPattern=1))),
            Coordsys(scale=0.15));
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation(r=r,
              animation=false)
            annotation (extent=[-28,-70; -8,-50]);
          MultiBondLib.Mechanics3D.Joints.CutJoints.PlanarRevolute
            planarRevolute(
              n={0,0,1},
            cylinderDiameter=0.08,
            animation=true,
            cylinderColor={255,0,0},
            cylinderLength=0.24)
            annotation (extent=[-70,-50; -50,-30]);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation SwingingArmCoM(
              animation=false, r=CoM_SA)           annotation (extent=[30,20;
                50,40],
              rotation=90);
          MultiBondLib.Mechanics3D.Parts.SimpleBody SwingingArmMass(
            sphereDiameter=0.1,
            animation=true,
            m=mSA,
            I_11=I_11,
            I_22=I_22,
            I_33=I_33,
            I_21=I_21,
            I_31=I_31,
            I_32=I_32)
                 annotation (extent=[30,60; 50,80],   rotation=90);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute RWRevolute(
            phi_start=0,
            animation=true,
            cylinderDiameter=0.08,
            cylinderColor={255,0,0},
            w_start=0,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            cylinderLength=0.2,
            enforceStates=true)  annotation (extent=[60,-50; 80,-30], rotation=0);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation
            fixedTranslation_Spring(
              r=rs, animation=false)
            annotation (extent=[0,-50; 20,-30], rotation=90);
          BondLib.Mechanical.Rotational.Interfaces.Flange_a flange_a
            annotation (extent=[90,-90; 110,-70]);
          BondLib.Mechanical.Rotational.Interfaces.Flange_b flange_b
            annotation (extent=[90,-10; 110,10]);
          MultiBondLib.Mechanics3D.Joints.Revolute RWRevolute2(
            cylinderDiameter=0.08,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            enforceStates=false,
            cylinderLength=0.2,
            cylinderColor={0,128,0},
            phi(stateSelect=StateSelect.never))
            annotation (extent=[0,-20; 20,0],   rotation=90);
          MultiBondLib.Mechanics3D.Joints.Revolute RWRevolute1(
            cylinderDiameter=0.08,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            enforceStates=false,
            cylinderLength=0.2,
            cylinderColor={255,0,0},
            phi(stateSelect=StateSelect.never))
            annotation (extent=[-8,50; 12,70],  rotation=90);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslationRS(r=
                rRS, animation=false)
            annotation (extent=[-90,20; -70,40],
                                               rotation=270);
          RearSuspensions.RearSuspension rearSuspension(
            c=c,
            d=d,
            s_rel0=s_rel0,
            bias=bias,
            n=n) annotation (extent=[-10,8; 20,38]);
        equation
          d_spring = rearSuspension.actuatedPrismatic.frame_b.P.x - rearSuspension.actuatedPrismatic.frame_a.P.x;
          s = sqrt(d_spring*d_spring);
          connect(RearWheel, RearWheel) annotation (points=[114,-40; 114,-40],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(planarRevolute.frame_a, RearFrameCon1) annotation (points=[-71,-40;
                -114,-40],      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(fixedTranslation.frame_a, planarRevolute.frame_b) annotation (
              points=[-29,-60; -40,-60; -40,-40; -49,-40],
                                         style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SwingingArmMass.frame_a, SwingingArmCoM.frame_b)   annotation (
              points=[40,59; 40,41],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=10,
              rgbfillColor={95,95,95}));
          connect(RWRevolute.frame_b, RearWheel) annotation (points=[81,-40; 114,
                -40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute.frame_a, fixedTranslation.frame_b) annotation (
              points=[59,-40; 40,-40; 40,-60; -7,-60],
                                        style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute.frame_a, SwingingArmCoM.frame_a) annotation (points=[59,-40;
                40,-40; 40,19],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(flange_b, flange_b) annotation (points=[100,0; 100,0], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(RWRevolute.bearing, flange_b) annotation (points=[63,-47; 54,
                -47; 54,0; 100,0], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(fixedTranslation_Spring.frame_a, RWRevolute.frame_a)
            annotation (points=[10,-51; 10,-60; 40,-60; 40,-40; 59,-40],
                              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute2.frame_a, fixedTranslation_Spring.frame_b)
            annotation (points=[10,-21; 10,-29],       style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute.axis, flange_a) annotation (points=[77,-47; 77,-80;
                100,-80], style(color=0, rgbcolor={0,0,0}));
          connect(fixedTranslationRS.frame_b, RearFrameCon1) annotation (points=[
                -80,19; -80,-40; -114,-40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=45,
              rgbfillColor={255,128,0},
              fillPattern=1));
          connect(fixedTranslationRS.frame_a, RWRevolute1.frame_b) annotation (
              points=[-80,41; -80,80; 2,80; 2,71],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=45,
              rgbfillColor={255,128,0},
              fillPattern=1));
          connect(RWRevolute2.frame_b, rearSuspension.frame_b) annotation (
              points=[10,1; 10,12.5; 9.5,12.5], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=70,
              rgbfillColor={45,96,172}));
          connect(RWRevolute1.frame_a, rearSuspension.frame_a) annotation (
              points=[2,49; 2,41.25; 2,41.25; 2,33.5], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=70,
              rgbfillColor={45,96,172}));
        end SwingingArm_classic;

        model SwingingArm_classic_Ind "Basic Model of a Swinging Arm"

          import SI = Modelica.SIunits;
          import PI = Modelica.Constants.pi;
          import MB = Modelica.Mechanics.MultiBody;

          parameter Real spring_table[:,:] = [0,0; 1,1]
            "Spring characteristics of the front suspension";
          parameter Real damper_table[:,:] = [0,0; 1,1]
            "Damper characteristics of the front suspension";

          parameter SI.Mass mSA = 1 "Mass of swinging arm";

          parameter SI.Position R_rw = 1 "Rear wheel radius";
          final parameter SI.Distance p7[3] = {0, R_rw, 0};

          parameter SI.Position p11[3] = {1, 1, 0}
            "Attachment point swinging arm to rear frame";

          parameter SI.Position p12[3] = {1, 1, 0}
            "Attachment point rear spring to swinging arm";

          parameter SI.Position p13[3] = {1, 1, 0}
            "Attachment point rear spring to rear frame";

          parameter SI.Position p14[3] = {0,0,0} "Center of mass swinging arm";
          final parameter SI.Distance CoM_SA[3] = {-p14[1], p14[2] - R_rw, 0};

          final parameter SI.Distance s_rel0 = sqrt( (p13[1]-p12[1])*(p13[1]-p12[1]) + (p13[2]-p12[2])*(p13[2]-p12[2]))
            "Unstretched spring length";

          parameter SI.Distance bias = 0 "Pre-load of the spring";

          final parameter SI.Distance r[3] = {p11[1]-p7[1], p11[2]-p7[2], 0}
            "Swinging arm length";

          final parameter SI.Distance rs[3] = {p7[1]-p12[1], p12[2]-p7[2],0};
          final parameter SI.Distance rRS[3] = {p13[1]-p11[1],p11[2]-p13[2],0};

          // conditional declaration needed for the direction of the swinging arm suspension
          final parameter SI.Angle alpha = if p13[1]-p12[1] == 0 then PI/2 else Modelica.Math.atan((p13[2]-p12[2])/(p13[1]-p12[1]));

          final parameter SI.Position n[3] = {cos(alpha), sin(alpha), 0}
            "Direction of swinging arm suspension (joint axis)";

          parameter SI.Inertia I_11=0.001
            "|Inertia tensor|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_22=0.001
            "|Inertia tensor|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_33=0.001
            "|Inertia tensor|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_21=0
            "|Inertia tensor|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_31=0
            "|Inertia tensor|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_32=0
            "|Inertia tensor|| (3,2) element of inertia tensor";

        // Animation
        public
          SI.Distance s;
          SI.Distance d_spring[3];

          parameter MB.Types.Color FrameColor = {255,165,0}
            "|Animation || Color of the Rear Frame";
          parameter MB.Types.Color FrameColor2 = {255,127,0}
            "|Animation || Color of the Rear Frame's lower parts";
          parameter MB.Types.Color springColor = {0,0,205}
            "|Animation || Color of the Front Suspension";

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW12Right(
             lengthDirection= {-1,0,0} "Vector in length direction",
             length=fixedTranslation.r[1] "Length of visual object",
             shapeType="cylinder",
             color=FrameColor2,
             width=0.06 "Width of visual object",
             height=0.04 "Height of visual object",
             r_shape={0,0,0.1},
             r=fixedTranslation.frame_b.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW12Left(
             lengthDirection= {-1,0,0} "Vector in length direction",
             length=fixedTranslation.r[1] "Length of visual object",
             shapeType="cylinder",
             color=FrameColor2,
             width=0.06 "Width of visual object",
             height=0.04 "Height of visual object",
             r_shape={0,0,-0.1},
             r=fixedTranslation.frame_b.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspLeft(
            shapeType="spring",
            color=springColor,
            width=0.06,
            height=0.025,
            lengthDirection=rearSuspension.actuatedPrismatic.n,
            r_shape={0,0,-0.11},
            length=s,
            r=RWRevolute2.frame_b.P.x,
            extra = 6,
            R=MB.Frames.Orientation(T=RWRevolute2.frame_b.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspRight(
            shapeType="spring",
            color=springColor,
            width=0.06,
            height=0.025,
            lengthDirection=rearSuspension.actuatedPrismatic.n,
            r_shape={0,0,0.11},
            length=s,
            r=RWRevolute2.frame_b.P.x,
            extra = 6,
            R=MB.Frames.Orientation(T=RWRevolute2.frame_b.P.R,w=zeros(3)));

          MultiBondLib.Mechanics3D.Interfaces.Frame_a RearFrameCon1
            annotation (extent=[-128,-62; -100,-18]);
          MultiBondLib.Mechanics3D.Interfaces.Frame_b RearWheel
            annotation (extent=[100,-62; 128,-18]);
          annotation (Diagram, Icon(
              Polygon(points=[-28,92; 12,-26; 20,-26; -20,92; -24,92; -28,92],
                                                                         style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=0,
                  rgbfillColor={0,0,0})),
              Rectangle(extent=[-100,-26; 100,-54],
                                                  style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=10,
                  rgbfillColor={95,95,95})),
              Text(extent=[-100,-60; 60,-100],string="%name"),
              Text(
                extent=[-104,-30; -64,-50],
                string="a",
                style(color=1, rgbcolor={255,0,0})),
              Text(
                extent=[62,-30; 102,-50],
                string="b",
                style(color=1, rgbcolor={255,0,0})),
              Line(points=[-50,82; 12,82; -10,64], style(
                  color=2,
                  rgbcolor={0,255,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[-18,58; -40,40; 26,40; 4,22], style(
                  color=2,
                  rgbcolor={0,255,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[-4,16; -26,-2; 36,-2], style(
                  color=2,
                  rgbcolor={0,255,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[80,-100; 66,-80; 60,-60; 60,-20; 66,0; 80,20; 80,20],
                  style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillPattern=1)),
              Polygon(points=[82,12; 74,24; 92,26; 82,12],   style(
                  color=0,
                  fillColor=0,
                  fillPattern=1))),
            Coordsys(scale=0.15));
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation(r=r,
              animation=false)
            annotation (extent=[-28,-70; -8,-50]);
          MultiBondLib.Mechanics3D.Joints.CutJoints.PlanarRevolute
            planarRevolute(
              n={0,0,1},
            cylinderDiameter=0.08,
            animation=true,
            cylinderColor={255,0,0},
            cylinderLength=0.24)
            annotation (extent=[-70,-50; -50,-30]);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation SwingingArmCoM(
              animation=false, r=CoM_SA)           annotation (extent=[30,20;
                50,40],
              rotation=90);
          MultiBondLib.Mechanics3D.Parts.SimpleBody SwingingArmMass(
            sphereDiameter=0.1,
            animation=true,
            m=mSA,
            I_11=I_11,
            I_22=I_22,
            I_33=I_33,
            I_21=I_21,
            I_31=I_31,
            I_32=I_32)
                 annotation (extent=[30,60; 50,80],   rotation=90);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute RWRevolute(
            phi_start=0,
            animation=true,
            cylinderDiameter=0.08,
            cylinderColor={255,0,0},
            w_start=0,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            cylinderLength=0.2,
            enforceStates=true)  annotation (extent=[60,-50; 80,-30], rotation=0);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation
            fixedTranslation_Spring(
              r=rs, animation=false)
            annotation (extent=[0,-50; 20,-30], rotation=90);
          BondLib.Mechanical.Rotational.Interfaces.Flange_a flange_a
            annotation (extent=[90,-90; 110,-70]);
          BondLib.Mechanical.Rotational.Interfaces.Flange_b flange_b
            annotation (extent=[90,-10; 110,10]);
          MultiBondLib.Mechanics3D.Joints.Revolute RWRevolute2(
            cylinderDiameter=0.08,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            enforceStates=false,
            cylinderLength=0.2,
            cylinderColor={0,128,0},
            phi(stateSelect=StateSelect.never))
            annotation (extent=[0,-20; 20,0],   rotation=90);
          MultiBondLib.Mechanics3D.Joints.Revolute RWRevolute1(
            cylinderDiameter=0.08,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            enforceStates=false,
            cylinderLength=0.2,
            cylinderColor={255,0,0},
            phi(stateSelect=StateSelect.never))
            annotation (extent=[-8,50; 12,70],  rotation=90);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslationRS(r=
                rRS, animation=false)
            annotation (extent=[-90,20; -70,40],
                                               rotation=270);
          RearSuspensions.RearSuspension_Ind rearSuspension(
            s_rel0=s_rel0,
            bias=bias,
            n=n,
            spring_table=spring_table,
            damper_table=damper_table)
                 annotation (extent=[-10,8; 20,38]);
        equation
          d_spring = rearSuspension.actuatedPrismatic.frame_b.P.x - rearSuspension.actuatedPrismatic.frame_a.P.x;
          s = sqrt(d_spring*d_spring);
          connect(RearWheel, RearWheel) annotation (points=[114,-40; 114,-40],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(planarRevolute.frame_a, RearFrameCon1) annotation (points=[-71,-40;
                -114,-40],      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(fixedTranslation.frame_a, planarRevolute.frame_b) annotation (
              points=[-29,-60; -40,-60; -40,-40; -49,-40],
                                         style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SwingingArmMass.frame_a, SwingingArmCoM.frame_b)   annotation (
              points=[40,59; 40,41],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=10,
              rgbfillColor={95,95,95}));
          connect(RWRevolute.frame_b, RearWheel) annotation (points=[81,-40; 114,
                -40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute.frame_a, fixedTranslation.frame_b) annotation (
              points=[59,-40; 40,-40; 40,-60; -7,-60],
                                        style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute.frame_a, SwingingArmCoM.frame_a) annotation (points=[59,-40;
                40,-40; 40,19],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(flange_b, flange_b) annotation (points=[100,0; 100,0], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(RWRevolute.bearing, flange_b) annotation (points=[63,-47; 54,
                -47; 54,0; 100,0], style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(fixedTranslation_Spring.frame_a, RWRevolute.frame_a)
            annotation (points=[10,-51; 10,-60; 40,-60; 40,-40; 59,-40],
                              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute2.frame_a, fixedTranslation_Spring.frame_b)
            annotation (points=[10,-21; 10,-29],       style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute.axis, flange_a) annotation (points=[77,-47; 77,-80;
                100,-80], style(color=0, rgbcolor={0,0,0}));
          connect(fixedTranslationRS.frame_b, RearFrameCon1) annotation (points=[
                -80,19; -80,-40; -114,-40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=45,
              rgbfillColor={255,128,0},
              fillPattern=1));
          connect(fixedTranslationRS.frame_a, RWRevolute1.frame_b) annotation (
              points=[-80,41; -80,80; 2,80; 2,71],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=45,
              rgbfillColor={255,128,0},
              fillPattern=1));
          connect(RWRevolute2.frame_b, rearSuspension.frame_b) annotation (
              points=[10,1; 10,12.5; 9.5,12.5], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=70,
              rgbfillColor={45,96,172}));
          connect(RWRevolute1.frame_a, rearSuspension.frame_a) annotation (
              points=[2,49; 2,41.25; 2,41.25; 2,33.5], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=70,
              rgbfillColor={45,96,172}));
        end SwingingArm_classic_Ind;

        model SwingingArm_Rocker
          "Rocker Model of a Swinging Arm including a monoshock suspension"

          import SI = Modelica.SIunits;
          import PI = Modelica.Constants.pi;
          import MB = Modelica.Mechanics.MultiBody;

          parameter Real c(
            final unit="N/m",
            final min=0) = 1 "Spring constant of the swinging arm suspension";

          parameter Real d(
            final unit="N/(m/s)",
            final min=0) = 0 "Damping constant of the swingning arm suspension";

          parameter SI.Mass mSA = 1 "Mass of swinging arm";

          parameter SI.Position R_rw = 1 "Rear wheel radius";
          final parameter SI.Distance p7[3] = {0, R_rw, 0};

          parameter SI.Position p11[3] = {1, 1, 0}
            "Attachment point swinging arm to rear frame";

          //parameter SI.Position p12[3] = {1, 1, 0}
          //  "Attachment point rear spring to swinging arm";

          parameter SI.Position p13[3] = {1, 1, 0}
            "Attachment point rear spring to rear frame";

          parameter SI.Position p14[3] = {0,0,0} "Center of mass swinging arm";

          parameter SI.Position p19[3] = {1,1,0}
            "Attachment point rocker arm to rear frame";

          parameter SI.Position p20[3] = {1,1,0}
            "Attachment point rear spring to swinging arm";

          parameter SI.Position p21[3] = {1,1,0}
            "Attachment point rear spring to swinging arm";

          parameter SI.Position p22[3] = {1,1,0}
            "Attachment point swinging arm";

          final parameter SI.Distance CoM_SA[3] = {-p14[1], p14[2] - R_rw, 0};

          final parameter SI.Distance s_rel0 = sqrt( (p13[1]-p21[1])*(p13[1]-p21[1]) + (p13[2]-p21[2])*(p13[2]-p21[2]))
            "Unstretched spring length";

          parameter SI.Distance bias = 0 "Pre-load of the spring";

          final parameter SI.Distance r[3] = {p11[1]-p7[1], p7[2]-p11[2], 0}
            "Swinging arm length";

          final parameter SI.Distance rRS[3] = {p13[1]-p11[1],p11[2]-p13[2],0}
            "monoshock suspension to rear frame";
          final parameter SI.Distance rRA[3] = {p19[1]-p11[1],p11[2]-p19[2],0}
            "Attachment rocker to rear frame";

          final parameter SI.Distance l1[3] = {p19[1]-p20[1], p20[2]-p19[2],0};
          final parameter SI.Distance l2[3] = {p22[1]-p20[1], p20[2]-p22[2],0};
          final parameter SI.Distance l3[3] = {p11[1]-p22[1], p22[2]-p11[2],0};
          final parameter SI.Distance l4[3] = {p20[1]-p21[1], p21[2]-p20[2],0};

          // conditional declaration needed for the direction of the swinging arm suspension
          final parameter SI.Angle alpha = if p13[1]-p21[1] == 0 then PI/2 else Modelica.Math.atan((p13[2]-p21[2])/(p13[1]-p21[1]));

          final parameter SI.Position n[3] = {cos(alpha), sin(alpha), 0}
            "Direction of swinging arm suspension (joint axis)";

          parameter SI.Inertia I_11=0.001
            "|Inertia tensor|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_22=0.001
            "|Inertia tensor|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_33=0.001
            "|Inertia tensor|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_21=0
            "|Inertia tensor|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_31=0
            "|Inertia tensor|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_32=0
            "|Inertia tensor|| (3,2) element of inertia tensor";

        // Animation
          SI.Distance s;
          SI.Distance d_spring[3];

        public
          parameter MB.Types.Color FrameColor = {255,165,0}
            "|Animation || Color of the Rear Frame";
          parameter MB.Types.Color FrameColor2 = {255,127,0}
            "|Animation || Color of the Rear Frame's lower parts";
            parameter MB.Types.Color springColor = {0,230,0}
            "|Animation || Color of the Front Suspension";

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SA_TOP_Right(
             lengthDirection= fixedTranslation.r "Vector in length direction",
             length=fixedTranslation.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.07 "Width of visual object",
             height=0.03 "Height of visual object",
             r_shape={0,0,0.1},
             r=fixedTranslation.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SA_TOP2_Right(
             lengthDirection= {0.12,1,0} "Vector in length direction",
             length=0.06 "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.03 "Height of visual object",
             r_shape={0,0,0.1},
             r=SA_Revolute4.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=SA_Revolute4.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SA_TOP_Left(
             lengthDirection= fixedTranslation.r "Vector in length direction",
             length=fixedTranslation.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.07 "Width of visual object",
             height=0.03 "Height of visual object",
             r_shape={0,0,-0.1},
             r=fixedTranslation.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SA_TOP2_Left(
             lengthDirection= {0.12,1,0} "Vector in length direction",
             length=0.06 "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.03 "Height of visual object",
             r_shape={0,0,-0.1},
             r=SA_Revolute4.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=SA_Revolute4.frame_a.P.R,w=zeros(3)));
        /*
  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SpringMount_TOP(
     lengthDirection= {0.12,1,0} "Vector in length direction",
     length=0.06 "Length of visual object",
     shapeType="beam",
     color={20,20,20},
     specularCoefficient=0.7,
     width=0.05 "Width of visual object",
     height=0.03 "Height of visual object",
     r_shape={0,0,-0.1},
     r=SA_Revolute4.frame_a.P.x "Origin of visual object",
     R=MB.Frames.Orientation(T=SA_Revolute4.frame_a.P.R,w=zeros(3)));
*/

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p19r(
             lengthDirection= fixedTranslation5.r "Vector in length direction",
             length=fixedTranslation5.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,0.06},
             r=fixedTranslation5.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation5.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p20r(
             lengthDirection= fixedTranslation4.r "Vector in length direction",
             length=fixedTranslation4.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,0.06},
             r=fixedTranslation4.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation4.frame_a.P.R,w=zeros(3)));
          /*
  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p21r(
     lengthDirection= SA_Revolute3.frame_b.P.x - Spring_LowerRevolute.frame_a.P.x
      "Vector in length direction",
     length=sqrt((p19[1]-p21[1])^2 + (p21[2]-p19[2])^2)
      "Length of visual object",
     shapeType="beam",
     color={20,20,20},
     specularCoefficient=0.7,
     width=0.05 "Width of visual object",
     height=0.01 "Height of visual object",
     r_shape={0,0,0.06},
     r=Spring_LowerRevolute.frame_a.P.x "Origin of visual object",
     R=MB.Frames.Orientation(T=zeros(3,3),w=zeros(3)));
  */
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p22r(
             lengthDirection= fixedTranslation3.r "Vector in length direction",
             length=fixedTranslation3.length "Length of visual object",
             shapeType="beam",
             color=FrameColor2,
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,0.07},
             r=fixedTranslation3.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation3.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p19l(
             lengthDirection= fixedTranslation5.r "Vector in length direction",
             length=fixedTranslation5.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,-0.06},
             r=fixedTranslation5.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation5.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p20l(
             lengthDirection= fixedTranslation4.r "Vector in length direction",
             length=fixedTranslation4.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,-0.06},
             r=fixedTranslation4.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation4.frame_a.P.R,w=zeros(3)));
          /*
  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p21l(
     lengthDirection= SA_Revolute3.frame_b.P.x - Spring_LowerRevolute.frame_a.P.x
      "Vector in length direction",
     length=sqrt((p19[1]-p21[1])^2 + (p21[2]-p19[2])^2)
      "Length of visual object",
     shapeType="beam",
     color={20,20,20},
     specularCoefficient=0.7,
     width=0.05 "Width of visual object",
     height=0.01 "Height of visual object",
     r_shape={0,0,-0.06},
     r=Spring_LowerRevolute.frame_a.P.x "Origin of visual object",
     R=MB.Frames.Orientation(T=zeros(3,3),w=zeros(3)));
  */
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p22l(
             lengthDirection= fixedTranslation3.r "Vector in length direction",
             length=fixedTranslation3.length "Length of visual object",
             shapeType="beam",
             color=FrameColor2,
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,-0.07},
             r=fixedTranslation3.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation3.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            MonoshockSuspension(
            shapeType="spring",
            color=springColor,
            width=0.05,
            height=0.025,
            lengthDirection=rearSuspension.actuatedPrismatic.n,
            r_shape={0,s*0.1,0},
            length=s*0.8,
            r=Spring_LowerRevolute.frame_b.P.x,
            extra = 6,
            R=MB.Frames.Orientation(T=Spring_LowerRevolute.frame_b.P.R,w=zeros(3)));

          MultiBondLib.Mechanics3D.Interfaces.Frame_a RearFrameCon1
            annotation (extent=[-128,-22; -100,22]);
          MultiBondLib.Mechanics3D.Interfaces.Frame_b RearWheel
            annotation (extent=[100,-22; 128,22]);
          annotation (Diagram, Icon(
              Text(extent=[-80,-110; 80,-150],string="%name"),
              Polygon(points=[-78,98; -20,-68; -12,-68; -70,98; -70,98; -78,98],
                                                                         style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=0,
                  rgbfillColor={0,0,0})),
              Line(points=[-97,84; -35,84; -57,66], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=3,
                  rgbfillColor={0,0,255},
                  fillPattern=1)),
              Line(points=[-50,18; -72,0; -6,0; -28,-18], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=3,
                  rgbfillColor={0,0,255},
                  fillPattern=1)),
              Line(points=[-36,-24; -58,-42; 4,-42], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=3,
                  rgbfillColor={0,0,255},
                  fillPattern=1)),
              Line(points=[-65,60; -87,42; -21,42; -43,24], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=3,
                  rgbfillColor={0,0,255},
                  fillPattern=1)),
              Rectangle(extent=[-100,14; 100,-14], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Ellipse(extent=[-80,105; -68,93], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=1,
                  rgbfillColor={255,0,0},
                  fillPattern=1)),
              Ellipse(extent=[-6,-7; 6,-19], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=1,
                  rgbfillColor={255,0,0},
                  fillPattern=1)),
              Text(
                extent=[60,10; 100,-10],
                string="b",
                style(color=1, rgbcolor={255,0,0})),
              Text(
                extent=[-100,10; -60,-10],
                string="a",
                style(color=1, rgbcolor={255,0,0})),
              Polygon(points=[-100,-52; -18,-60; -14,-62; -12,-66; -14,-70; -16,
                    -72; -58,-90; -62,-90; -102,-62; -104,-60; -104,-56; -104,
                    -54; -100,-52], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={135,135,135},
                  fillPattern=1)),
              Ellipse(extent=[-23,-60; -11,-72], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=1,
                  rgbfillColor={255,0,0},
                  fillPattern=1)),
              Ellipse(extent=[-66,-79; -54,-91], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=1,
                  rgbfillColor={255,0,0},
                  fillPattern=1)),
              Ellipse(extent=[-106,-51; -94,-63], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=1,
                  rgbfillColor={255,0,0},
                  fillPattern=1)),
              Line(points=[0,-12; -60,-84], style(
                  color=0,
                  rgbcolor={0,0,0},
                  thickness=2,
                  fillColor=42,
                  rgbfillColor={127,0,0}))),
            Coordsys(scale=0.15, extent=[-100,-110; 100,110]));
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation(r=r,
              animation=false)
            annotation (extent=[-40,-10; -20,10]);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation SwingingArmCoM(
                               r=CoM_SA, animation=false)
                                                   annotation (extent=[30,-40; 50,-20],
              rotation=270);
          MultiBondLib.Mechanics3D.Parts.SimpleBody SwingingArmMass(
            sphereDiameter=0.1,
            animation=true,
            m=mSA,
            I_11=I_11,
            I_22=I_22,
            I_33=I_33,
            I_21=I_21,
            I_31=I_31,
            I_32=I_32)
                 annotation (extent=[30,-72; 50,-52], rotation=270);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute RWRevolute(
            phi_start=0,
            animation=true,
            cylinderDiameter=0.08,
            cylinderColor={255,0,0},
            w_start=0,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            cylinderLength=0.2,
            enforceStates=true)  annotation (extent=[60,-10; 80,10],  rotation=0);
          BondLib.Mechanical.Rotational.Interfaces.Flange_a flange_a
            annotation (extent=[90,-52; 110,-32]);
          BondLib.Mechanical.Rotational.Interfaces.Flange_b flange_b
            annotation (extent=[90,28; 110,48]);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation1(r=l3,
              animation=false)
                              annotation (extent=[-40,-22; -20,-2], rotation=0);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation3(r=l2,
              animation=false)
            annotation (extent=[-20,-72; 0,-52], rotation=270);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation5(r=l1,
              animation=false)
            annotation (extent=[-50,-91; -30,-71], rotation=270);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation4(r=l4,
              animation=false)
            annotation (extent=[10,-90; 30,-70], rotation=90);
          MultiBondLib.Mechanics3D.Joints.CutJoints.PlanarRevolute
            Spring_UpperRevolute(
            cylinderDiameter=0.04,
            cylinderColor={255,0,0},
            cylinderLength=0.12)
            annotation (extent=[2,70; 22,90],   rotation=90);
          MultiBondLib.Mechanics3D.Joints.Revolute Spring_LowerRevolute(
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            enforceStates=false,
            phi(stateSelect=StateSelect.never),
            cylinderDiameter=0.04,
            cylinderColor={255,0,0},
            cylinderLength=0.12)
            annotation (extent=[10,10; 30,30],  rotation=90);
          MultiBondLib.Mechanics3D.Joints.Revolute SA_Revolute4(
            n={0,0,1},
            animation=true,
            cylinderColor={255,0,0},
            cylinderDiameter=0.04,
            cylinderLength=0.2)
            annotation (extent=[-20,-42; 0,-22], rotation=270);
          MultiBondLib.Mechanics3D.Joints.Revolute SA_Revolute(
            n={0,0,1},
            animation=true,
            cylinderColor={255,0,0},
            cylinderLength=0.24,
            cylinderDiameter=0.08)
            annotation (extent=[-80,-10; -60,10], rotation=0);
          MultiBondLib.Mechanics3D.Joints.Revolute SA_Revolute2(
            n={0,0,1},
            animation=true,
            cylinderColor={255,0,0},
            cylinderDiameter=0.04,
            cylinderLength=0.16)
            annotation (extent=[-20,-104; 0,-84], rotation=270);
          MultiBondLib.Mechanics3D.Joints.CutJoints.PlanarRevolute SA_Revolute3
            (
            n={0,0,1},
            animation=true,
            cylinderColor={255,0,0},
            cylinderDiameter=0.04,
            cylinderLength=0.12)
            annotation (extent=[-80,-70; -60,-50], rotation=0);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslationRS(r=
                rRS,
            shapeType="beam",
            width=0.1,
            height=0.03,
            color={255,127,0},
            animation=false)
            annotation (extent=[-100,40; -80,60],
                                               rotation=270);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslationRA(
            r=rRA,
            animation=true,
            shapeType="beam",
            width=0.1,
            height=0.03,
            color={255,127,0})
            annotation (extent=[-100,-40; -80,-20],
                                               rotation=90);
          RearSuspensions.RearSuspension rearSuspension(
            c=c,
            d=d,
            s_rel0=s_rel0,
            bias=bias,
            n=n)
            annotation (extent=[0,36; 30,68]);
        equation

          d_spring = rearSuspension.actuatedPrismatic.frame_b.P.x - rearSuspension.actuatedPrismatic.frame_a.P.x;
          s = sqrt(d_spring*d_spring);
          connect(RearWheel, RearWheel) annotation (points=[114,0; 114,0],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SwingingArmMass.frame_a, SwingingArmCoM.frame_b)   annotation (
              points=[40,-51; 40,-41], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=10,
              rgbfillColor={95,95,95}));
          connect(RWRevolute.frame_b, RearWheel) annotation (points=[81,0; 114,0],
                      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute.frame_a, fixedTranslation.frame_b) annotation (
              points=[59,0; -19,0],     style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute.frame_a, SwingingArmCoM.frame_a) annotation (points=[59,0; 40,
                0; 40,-19],              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(flange_b, flange_b) annotation (points=[100,38; 100,38],
                                                                         style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(RWRevolute.bearing, flange_b) annotation (points=[63,-7; 54,-7;
                54,38; 100,38],    style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(RWRevolute.axis, flange_a) annotation (points=[77,-7; 77,-42;
                100,-42], style(color=0, rgbcolor={0,0,0}));
          connect(fixedTranslation1.frame_a, fixedTranslation.frame_a)
            annotation (points=[-41,-12; -50,-12; -50,0; -41,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Spring_LowerRevolute.frame_a, fixedTranslation4.frame_b)
            annotation (points=[20,9; 20,-69],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(fixedTranslation1.frame_b, SA_Revolute4.frame_a)
                                                                  annotation (
              points=[-19,-12; -10,-12; -10,-21], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute4.frame_b, fixedTranslation3.frame_a)
                                                                  annotation (
              points=[-10,-43; -10,-45; -10,-45; -10,-47; -10,-51; -10,-51],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute.frame_a, RearFrameCon1)  annotation (points=[-81,0;
                -114,0],                 style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute.frame_b, fixedTranslation.frame_a)  annotation (
              points=[-59,0; -41,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute2.frame_a, fixedTranslation3.frame_b) annotation (
              points=[-10,-83; -10,-80.5; -10,-80.5; -10,-78; -10,-73; -10,-73],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute2.frame_b, fixedTranslation4.frame_a) annotation (
              points=[-10,-105; -10,-110; 20,-110; 20,-91], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute2.frame_b, fixedTranslation5.frame_b) annotation (
              points=[-10,-105; -10,-110; -40,-110; -40,-92], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute3.frame_b, fixedTranslation5.frame_a) annotation (
              points=[-59,-60; -40,-60; -40,-70], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(fixedTranslationRS.frame_b, RearFrameCon1) annotation (points=[
                -90,39; -90,0; -114,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(fixedTranslationRS.frame_a, Spring_UpperRevolute.frame_b)
            annotation (points=[-90,61; -90,100; 12,100; 12,91], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(fixedTranslationRA.frame_b, RearFrameCon1) annotation (points=[
                -90,-19; -90,0; -114,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute3.frame_a, fixedTranslationRA.frame_a) annotation (
              points=[-81,-60; -90,-60; -90,-41], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Spring_LowerRevolute.frame_b, rearSuspension.frame_b) annotation (
              points=[20,31; 20,40.8; 19.5,40.8], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=70,
              rgbfillColor={45,96,172}));
          connect(Spring_UpperRevolute.frame_a, rearSuspension.frame_a) annotation (
              points=[12,69; 12,63.2],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=70,
              rgbfillColor={45,96,172}));
        end SwingingArm_Rocker;

        model SwingingArm_Rocker_Ind
          "Rocker Model of a Swinging Arm including a monoshock suspension"

          import SI = Modelica.SIunits;
          import PI = Modelica.Constants.pi;
          import MB = Modelica.Mechanics.MultiBody;

          parameter Real spring_table[:,:] = [0,0; 1,1]
            "Spring characteristics of the front suspension";
          parameter Real damper_table[:,:] = [0,0; 1,1]
            "Damper characteristics of the front suspension";

          parameter SI.Mass mSA = 1 "Mass of swinging arm";

          parameter SI.Position R_rw = 1 "Rear wheel radius";
          final parameter SI.Distance p7[3] = {0, R_rw, 0};

          parameter SI.Position p11[3] = {1, 1, 0}
            "Attachment point swinging arm to rear frame";

          //parameter SI.Position p12[3] = {1, 1, 0}
          //  "Attachment point rear spring to swinging arm";

          parameter SI.Position p13[3] = {1, 1, 0}
            "Attachment point rear spring to rear frame";

          parameter SI.Position p14[3] = {0,0,0} "Center of mass swinging arm";

          parameter SI.Position p19[3] = {1,1,0}
            "Attachment point rocker arm to rear frame";

          parameter SI.Position p20[3] = {1,1,0}
            "Attachment point rear spring to swinging arm";

          parameter SI.Position p21[3] = {1,1,0}
            "Attachment point rear spring to swinging arm";

          parameter SI.Position p22[3] = {1,1,0}
            "Attachment point swinging arm";

          final parameter SI.Distance CoM_SA[3] = {-p14[1], p14[2] - R_rw, 0};

          final parameter SI.Distance s_rel0 = sqrt( (p13[1]-p21[1])*(p13[1]-p21[1]) + (p13[2]-p21[2])*(p13[2]-p21[2]))
            "Unstretched spring length";

          parameter SI.Distance bias = 0 "Pre-load of the spring";

          final parameter SI.Distance r[3] = {p11[1]-p7[1], p7[2]-p11[2], 0}
            "Swinging arm length";

          final parameter SI.Distance rRS[3] = {p13[1]-p11[1],p11[2]-p13[2],0}
            "monoshock suspension to rear frame";
          final parameter SI.Distance rRA[3] = {p19[1]-p11[1],p11[2]-p19[2],0}
            "Attachment rocker to rear frame";

          final parameter SI.Distance l1[3] = {p19[1]-p20[1], p20[2]-p19[2],0};
          final parameter SI.Distance l2[3] = {p22[1]-p20[1], p20[2]-p22[2],0};
          final parameter SI.Distance l3[3] = {p11[1]-p22[1], p22[2]-p11[2],0};
          final parameter SI.Distance l4[3] = {p20[1]-p21[1], p21[2]-p20[2],0};

          // conditional declaration needed for the direction of the swinging arm suspension
          final parameter SI.Angle alpha = if p13[1]-p21[1] == 0 then PI/2 else Modelica.Math.atan((p13[2]-p21[2])/(p13[1]-p21[1]));

          final parameter SI.Position n[3] = {cos(alpha), sin(alpha), 0}
            "Direction of swinging arm suspension (joint axis)";

          parameter SI.Inertia I_11=0.001
            "|Inertia tensor|| (1,1) element of inertia tensor";

          parameter SI.Inertia I_22=0.001
            "|Inertia tensor|| (2,2) element of inertia tensor";

          parameter SI.Inertia I_33=0.001
            "|Inertia tensor|| (3,3) element of inertia tensor";

          parameter SI.Inertia I_21=0
            "|Inertia tensor|| (2,1) element of inertia tensor";

          parameter SI.Inertia I_31=0
            "|Inertia tensor|| (3,1) element of inertia tensor";

          parameter SI.Inertia I_32=0
            "|Inertia tensor|| (3,2) element of inertia tensor";

        // Animation
          SI.Distance s;
          SI.Distance d_spring[3];

        public
          parameter MB.Types.Color FrameColor = {255,165,0}
            "|Animation || Color of the Rear Frame";
          parameter MB.Types.Color FrameColor2 = {255,127,0}
            "|Animation || Color of the Rear Frame's lower parts";
            parameter MB.Types.Color springColor = {0,230,0}
            "|Animation || Color of the Front Suspension";

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SA_TOP_Right(
             lengthDirection= fixedTranslation.r "Vector in length direction",
             length=fixedTranslation.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.07 "Width of visual object",
             height=0.03 "Height of visual object",
             r_shape={0,0,0.1},
             r=fixedTranslation.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SA_TOP2_Right(
             lengthDirection= {0.12,1,0} "Vector in length direction",
             length=0.06 "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.03 "Height of visual object",
             r_shape={0,0,0.1},
             r=SA_Revolute4.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=SA_Revolute4.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SA_TOP_Left(
             lengthDirection= fixedTranslation.r "Vector in length direction",
             length=fixedTranslation.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.07 "Width of visual object",
             height=0.03 "Height of visual object",
             r_shape={0,0,-0.1},
             r=fixedTranslation.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SA_TOP2_Left(
             lengthDirection= {0.12,1,0} "Vector in length direction",
             length=0.06 "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.03 "Height of visual object",
             r_shape={0,0,-0.1},
             r=SA_Revolute4.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=SA_Revolute4.frame_a.P.R,w=zeros(3)));
        /*
  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape SpringMount_TOP(
     lengthDirection= {0.12,1,0} "Vector in length direction",
     length=0.06 "Length of visual object",
     shapeType="beam",
     color={20,20,20},
     specularCoefficient=0.7,
     width=0.05 "Width of visual object",
     height=0.03 "Height of visual object",
     r_shape={0,0,-0.1},
     r=SA_Revolute4.frame_a.P.x "Origin of visual object",
     R=MB.Frames.Orientation(T=SA_Revolute4.frame_a.P.R,w=zeros(3)));
*/

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p19r(
             lengthDirection= fixedTranslation5.r "Vector in length direction",
             length=fixedTranslation5.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,0.06},
             r=fixedTranslation5.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation5.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p20r(
             lengthDirection= fixedTranslation4.r "Vector in length direction",
             length=fixedTranslation4.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,0.06},
             r=fixedTranslation4.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation4.frame_a.P.R,w=zeros(3)));
          /*
  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p21r(
     lengthDirection= SA_Revolute3.frame_b.P.x - Spring_LowerRevolute.frame_a.P.x
      "Vector in length direction",
     length=sqrt((p19[1]-p21[1])^2 + (p21[2]-p19[2])^2)
      "Length of visual object",
     shapeType="beam",
     color={20,20,20},
     specularCoefficient=0.7,
     width=0.05 "Width of visual object",
     height=0.01 "Height of visual object",
     r_shape={0,0,0.06},
     r=Spring_LowerRevolute.frame_a.P.x "Origin of visual object",
     R=MB.Frames.Orientation(T=zeros(3,3),w=zeros(3)));
  */
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p22r(
             lengthDirection= fixedTranslation3.r "Vector in length direction",
             length=fixedTranslation3.length "Length of visual object",
             shapeType="beam",
             color=FrameColor2,
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,0.07},
             r=fixedTranslation3.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation3.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p19l(
             lengthDirection= fixedTranslation5.r "Vector in length direction",
             length=fixedTranslation5.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,-0.06},
             r=fixedTranslation5.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation5.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p20l(
             lengthDirection= fixedTranslation4.r "Vector in length direction",
             length=fixedTranslation4.length "Length of visual object",
             shapeType="beam",
             color={20,20,20},
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,-0.06},
             r=fixedTranslation4.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation4.frame_a.P.R,w=zeros(3)));
          /*
  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p21l(
     lengthDirection= SA_Revolute3.frame_b.P.x - Spring_LowerRevolute.frame_a.P.x
      "Vector in length direction",
     length=sqrt((p19[1]-p21[1])^2 + (p21[2]-p19[2])^2)
      "Length of visual object",
     shapeType="beam",
     color={20,20,20},
     specularCoefficient=0.7,
     width=0.05 "Width of visual object",
     height=0.01 "Height of visual object",
     r_shape={0,0,-0.06},
     r=Spring_LowerRevolute.frame_a.P.x "Origin of visual object",
     R=MB.Frames.Orientation(T=zeros(3,3),w=zeros(3)));
  */
          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Link_p22l(
             lengthDirection= fixedTranslation3.r "Vector in length direction",
             length=fixedTranslation3.length "Length of visual object",
             shapeType="beam",
             color=FrameColor2,
             specularCoefficient=0.7,
             width=0.05 "Width of visual object",
             height=0.01 "Height of visual object",
             r_shape={0,0,-0.07},
             r=fixedTranslation3.frame_a.P.x "Origin of visual object",
             R=MB.Frames.Orientation(T=fixedTranslation3.frame_a.P.R,w=zeros(3)));

          Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
            MonoshockSuspension(
            shapeType="spring",
            color=springColor,
            width=0.05,
            height=0.025,
            lengthDirection=rearSuspension.actuatedPrismatic.n,
            r_shape={0,s*0.1,0},
            length=s*0.8,
            r=Spring_LowerRevolute.frame_b.P.x,
            extra = 6,
            R=MB.Frames.Orientation(T=Spring_LowerRevolute.frame_b.P.R,w=zeros(3)));

          MultiBondLib.Mechanics3D.Interfaces.Frame_a RearFrameCon1
            annotation (extent=[-128,-22; -100,22]);
          MultiBondLib.Mechanics3D.Interfaces.Frame_b RearWheel
            annotation (extent=[100,-22; 128,22]);
          annotation (Diagram, Icon(
              Text(extent=[-80,-110; 80,-150],string="%name"),
              Line(points=[0,-12; -60,-84], style(
                  color=0,
                  rgbcolor={0,0,0},
                  thickness=2)),
              Polygon(points=[-78,98; -20,-68; -12,-68; -70,98; -70,98; -78,98],
                                                                         style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=0,
                  rgbfillColor={0,0,0})),
              Line(points=[-97,84; -35,84; -57,66], style(
                  color=2,
                  rgbcolor={0,255,0},
                  fillColor=3,
                  rgbfillColor={0,0,255},
                  fillPattern=1)),
              Line(points=[-50,18; -72,0; -6,0; -28,-18], style(
                  color=2,
                  rgbcolor={0,255,0},
                  fillColor=3,
                  rgbfillColor={0,0,255},
                  fillPattern=1)),
              Line(points=[-36,-24; -58,-42; 4,-42], style(
                  color=2,
                  rgbcolor={0,255,0},
                  fillColor=3,
                  rgbfillColor={0,0,255},
                  fillPattern=1)),
              Line(points=[-65,60; -87,42; -21,42; -43,24], style(
                  color=2,
                  rgbcolor={0,255,0},
                  fillColor=3,
                  rgbfillColor={0,0,255},
                  fillPattern=1)),
              Rectangle(extent=[-100,14; 100,-14], style(
                  color=0,
                  rgbcolor={0,0,0},
                  gradient=2,
                  fillColor=9,
                  rgbfillColor={175,175,175})),
              Ellipse(extent=[-80,105; -68,93], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=1,
                  rgbfillColor={255,0,0},
                  fillPattern=1)),
              Ellipse(extent=[-6,-7; 6,-19], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=1,
                  rgbfillColor={255,0,0},
                  fillPattern=1)),
              Polygon(points=[-100,-60; -64,-88; -56,-88; -12,-68; -14,-62; -60,
                    -82; -100,-52; -100,-60], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={135,135,135},
                  fillPattern=1)),
              Ellipse(extent=[-23,-60; -11,-72], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=1,
                  rgbfillColor={255,0,0},
                  fillPattern=1)),
              Ellipse(extent=[-66,-79; -54,-91], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=1,
                  rgbfillColor={255,0,0},
                  fillPattern=1)),
              Ellipse(extent=[-106,-51; -94,-63], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=1,
                  rgbfillColor={255,0,0},
                  fillPattern=1)),
              Text(
                extent=[60,10; 100,-10],
                string="b",
                style(color=1, rgbcolor={255,0,0})),
              Text(
                extent=[-100,10; -60,-10],
                string="a",
                style(color=1, rgbcolor={255,0,0}))),
            Coordsys(scale=0.15, extent=[-100,-110; 100,110]));
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation(r=r,
              animation=true)
            annotation (extent=[-40,-10; -20,10]);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation SwingingArmCoM(
                               r=CoM_SA, animation=false)
                                                   annotation (extent=[30,-40; 50,-20],
              rotation=270);
          MultiBondLib.Mechanics3D.Parts.SimpleBody SwingingArmMass(
            sphereDiameter=0.1,
            animation=true,
            m=mSA,
            I_11=I_11,
            I_22=I_22,
            I_33=I_33,
            I_21=I_21,
            I_31=I_31,
            I_32=I_32)
                 annotation (extent=[30,-72; 50,-52], rotation=270);
          MultiBondLib.Mechanics3D.Joints.ActuatedRevolute RWRevolute(
            phi_start=0,
            animation=true,
            cylinderDiameter=0.08,
            cylinderColor={255,0,0},
            w_start=0,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            cylinderLength=0.2,
            enforceStates=true)  annotation (extent=[60,-10; 80,10],  rotation=0);
          BondLib.Mechanical.Rotational.Interfaces.Flange_a flange_a
            annotation (extent=[90,-52; 110,-32]);
          BondLib.Mechanical.Rotational.Interfaces.Flange_b flange_b
            annotation (extent=[90,28; 110,48]);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation1(r=l3,
              animation=false)
                              annotation (extent=[-40,-22; -20,-2], rotation=0);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation3(r=l2)
            annotation (extent=[-20,-72; 0,-52], rotation=270);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation5(r=l1)
            annotation (extent=[-50,-91; -30,-71], rotation=270);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation4(r=l4)
            annotation (extent=[10,-90; 30,-70], rotation=90);
          MultiBondLib.Mechanics3D.Joints.CutJoints.PlanarRevolute
            Spring_UpperRevolute(
            cylinderDiameter=0.04,
            cylinderColor={255,0,0},
            cylinderLength=0.12)
            annotation (extent=[2,70; 22,90],   rotation=90);
          MultiBondLib.Mechanics3D.Joints.Revolute Spring_LowerRevolute(
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            enforceStates=false,
            phi(stateSelect=StateSelect.never),
            cylinderDiameter=0.04,
            cylinderColor={255,0,0},
            cylinderLength=0.12)
            annotation (extent=[10,10; 30,30],  rotation=90);
          MultiBondLib.Mechanics3D.Joints.Revolute SA_Revolute4(
            n={0,0,1},
            animation=true,
            cylinderColor={255,0,0},
            cylinderDiameter=0.04,
            cylinderLength=0.12)
            annotation (extent=[-20,-42; 0,-22], rotation=270);
          MultiBondLib.Mechanics3D.Joints.Revolute SA_Revolute(
            n={0,0,1},
            animation=true,
            cylinderColor={255,0,0},
            cylinderLength=0.24,
            cylinderDiameter=0.08)
            annotation (extent=[-80,-10; -60,10], rotation=0);
          MultiBondLib.Mechanics3D.Joints.Revolute SA_Revolute2(
            n={0,0,1},
            animation=true,
            cylinderColor={255,0,0},
            cylinderDiameter=0.04,
            cylinderLength=0.12)
            annotation (extent=[-20,-104; 0,-84], rotation=270);
          MultiBondLib.Mechanics3D.Joints.CutJoints.PlanarRevolute SA_Revolute3
            (
            n={0,0,1},
            animation=true,
            cylinderColor={255,0,0},
            cylinderDiameter=0.04,
            cylinderLength=0.12)
            annotation (extent=[-80,-70; -60,-50], rotation=0);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslationRS(r=
                rRS, animation=true,
            shapeType="beam",
            width=0.1,
            height=0.03,
            color={255,127,0})
            annotation (extent=[-100,40; -80,60],
                                               rotation=270);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslationRA(
            r=rRA,
            animation=true,
            shapeType="beam",
            width=0.1,
            height=0.03,
            color={255,127,0})
            annotation (extent=[-100,-40; -80,-20],
                                               rotation=90);
          RearSuspensions.RearSuspension_Ind rearSuspension(
            s_rel0=s_rel0,
            bias=bias,
            n=n)
            annotation (extent=[0,36; 30,68]);
        equation

          d_spring = rearSuspension.actuatedPrismatic.frame_b.P.x - rearSuspension.actuatedPrismatic.frame_a.P.x;
          s = sqrt(d_spring*d_spring);
          connect(RearWheel, RearWheel) annotation (points=[114,0; 114,0],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SwingingArmMass.frame_a, SwingingArmCoM.frame_b)   annotation (
              points=[40,-51; 40,-41], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=10,
              rgbfillColor={95,95,95}));
          connect(RWRevolute.frame_b, RearWheel) annotation (points=[81,0; 114,0],
                      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute.frame_a, fixedTranslation.frame_b) annotation (
              points=[59,0; -19,0],     style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RWRevolute.frame_a, SwingingArmCoM.frame_a) annotation (points=[59,0; 40,
                0; 40,-19],              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(flange_b, flange_b) annotation (points=[100,38; 100,38],
                                                                         style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(RWRevolute.bearing, flange_b) annotation (points=[63,-7; 54,-7;
                54,38; 100,38],    style(
              color=0,
              rgbcolor={0,0,0},
              fillPattern=1));
          connect(RWRevolute.axis, flange_a) annotation (points=[77,-7; 77,-42;
                100,-42], style(color=0, rgbcolor={0,0,0}));
          connect(fixedTranslation1.frame_a, fixedTranslation.frame_a)
            annotation (points=[-41,-12; -50,-12; -50,0; -41,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Spring_LowerRevolute.frame_a, fixedTranslation4.frame_b)
            annotation (points=[20,9; 20,-69],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(fixedTranslation1.frame_b, SA_Revolute4.frame_a)
                                                                  annotation (
              points=[-19,-12; -10,-12; -10,-21], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute4.frame_b, fixedTranslation3.frame_a)
                                                                  annotation (
              points=[-10,-43; -10,-45; -10,-45; -10,-47; -10,-51; -10,-51],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute.frame_a, RearFrameCon1)  annotation (points=[-81,0;
                -114,0],                 style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute.frame_b, fixedTranslation.frame_a)  annotation (
              points=[-59,0; -41,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute2.frame_a, fixedTranslation3.frame_b) annotation (
              points=[-10,-83; -10,-80.5; -10,-80.5; -10,-78; -10,-73; -10,-73],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute2.frame_b, fixedTranslation4.frame_a) annotation (
              points=[-10,-105; -10,-110; 20,-110; 20,-91], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute2.frame_b, fixedTranslation5.frame_b) annotation (
              points=[-10,-105; -10,-110; -40,-110; -40,-92], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute3.frame_b, fixedTranslation5.frame_a) annotation (
              points=[-59,-60; -40,-60; -40,-70], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(fixedTranslationRS.frame_b, RearFrameCon1) annotation (points=[
                -90,39; -90,0; -114,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(fixedTranslationRS.frame_a, Spring_UpperRevolute.frame_b)
            annotation (points=[-90,61; -90,100; 12,100; 12,91], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(fixedTranslationRA.frame_b, RearFrameCon1) annotation (points=[
                -90,-19; -90,0; -114,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SA_Revolute3.frame_a, fixedTranslationRA.frame_a) annotation (
              points=[-81,-60; -90,-60; -90,-41], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Spring_LowerRevolute.frame_b, rearSuspension.frame_b) annotation (
              points=[20,31; 20,40.8; 19.5,40.8], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=70,
              rgbfillColor={45,96,172}));
          connect(Spring_UpperRevolute.frame_a, rearSuspension.frame_a) annotation (
              points=[12,69; 12,63.2],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=70,
              rgbfillColor={45,96,172}));
        end SwingingArm_Rocker_Ind;

        package RearSuspensions
          model RearSuspension

            import SI = Modelica.SIunits;

            parameter Real c(
              final unit="N/m",
              final min=0) = 1 "Spring constant of the swinging arm suspension";

            parameter Real d(
              final unit="N/(m/s)",
              final min=0) = 0
              "Damping constant of the swingning arm suspension";

            parameter SI.Distance s_rel0 = 0 "Unstretched spring length";

            parameter SI.Distance bias = 0 "Pre-load of the spring";

            parameter SI.Position n[3] = {0,0,1}
              "Direction of swinging arm suspension";

            MultiBondLib.Mechanics3D.Joints.ActuatedPrismatic actuatedPrismatic(
              n=n,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
              s_start=s_rel0,
              animation=false,
              enforceStates=true)
              annotation (extent=[20,0; 40,20],   rotation=90);
            BondLib.Mechanical.Translational.Passive.Spring spring(               c=
                 c, s_rel0=s_rel0 + bias)
                    annotation (extent=[0,1; 20,21],     rotation=90);
            BondLib.Mechanical.Translational.Passive.Damper damper(d=d)
              annotation (extent=[-20,1; 0,21],    rotation=90);
            ElastoGap elastoGap(
              s_rel0=s_rel0,
              c=1e4,
              d=1e3)               annotation (extent=[-40,1; -20,21],rotation=270);
            ElastoGap elastoGap1(
              s_rel0=s_rel0,
              c=1e6,
              d=1e5)               annotation (extent=[-60,1; -40,21],rotation=90);
            MultiBondLib.Mechanics3D.Interfaces.Frame_a frame_a
              annotation (extent=[-40,60; 0,80], rotation=90);
            MultiBondLib.Mechanics3D.Interfaces.Frame_b frame_b
              annotation (extent=[10,-80; 50,-60], rotation=90);
          equation
            connect(damper.flange_b,spring. flange_b) annotation (points=[-10,20.9;
                  10,20.9],  style(color=58, rgbcolor={0,127,0}));
            connect(damper.flange_a,spring. flange_a) annotation (points=[-10,1;
                  10,1],   style(color=58, rgbcolor={0,127,0}));
            connect(spring.flange_b,actuatedPrismatic. axis) annotation (points=[10,20.9;
                  23,20.9; 23,17],           style(color=58, rgbcolor={0,127,0}));
            connect(spring.flange_a,actuatedPrismatic. bearing) annotation (points=[10,1; 23,
                  1; 23,4],               style(color=58, rgbcolor={0,127,0}));
            connect(elastoGap.flange_a,damper. flange_b) annotation (points=[-30,21;
                  -33,21; -33,20.9; -10,20.9], style(color=58, rgbcolor={0,127,0}));
            connect(elastoGap.flange_b,damper. flange_a) annotation (points=[-30,1;
                  -10,1],  style(color=58, rgbcolor={0,127,0}));
            connect(elastoGap1.flange_b, elastoGap.flange_a) annotation (points=[-50,21;
                  -30,21],         style(
                color=58,
                rgbcolor={0,127,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172}));
            connect(elastoGap1.flange_a, elastoGap.flange_b) annotation (points=[-50,1;
                  -30,1],        style(
                color=58,
                rgbcolor={0,127,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172}));
            annotation (
              Icon(
                Polygon(points=[-24,70; 26,-70; 34,-70; -16,70; -24,70; -24,70],
                                                                           style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=0,
                    rgbfillColor={0,0,0})),
                Line(points=[-8,16; -28,0; 38,0; 18,-16], style(
                    color=45,
                    rgbcolor={255,128,0},
                    fillColor=10,
                    rgbfillColor={95,95,95},
                    fillPattern=1)),
                Line(points=[8,-24; -14,-42; 48,-42],
                                                 style(
                    color=45,
                    rgbcolor={255,128,0},
                    fillColor=10,
                    rgbfillColor={95,95,95},
                    fillPattern=1)),
                Line(points=[-38,42; 24,42; 2,24],  style(
                    color=45,
                    rgbcolor={255,128,0},
                    fillColor=10,
                    rgbfillColor={95,95,95},
                    fillPattern=1)),
                Text(
                  extent=[-80,-90; 80,-130],
                  style(
                    color=3,
                    rgbcolor={0,0,255},
                    gradient=2,
                    fillColor=70,
                    rgbfillColor={45,96,172}),
                  string="%name")),
              Diagram,
              Coordsys(scale=0.15));
            connect(actuatedPrismatic.frame_b, frame_a) annotation (points=[30,
                  21; 30,40; -20,40; -20,70], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(actuatedPrismatic.frame_a, frame_b) annotation (points=[30,
                  -1; 30,-70], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
          end RearSuspension;

          model RearSuspension_Ind

            import SI = Modelica.SIunits;

            parameter Real spring_table[:,:] = [0,0; 1,1]
              "Spring characteristics of the front suspension";
            parameter Real damper_table[:,:] = [0,0; 1,1]
              "Damper characteristics of the front suspension";

            parameter SI.Distance s_rel0 = 0 "Unstretched spring length";

            parameter SI.Distance bias = 0 "Pre-load of the spring";

            parameter SI.Position n[3] = {0,0,1}
              "Direction of swinging arm suspension";

            MultiBondLib.Mechanics3D.Joints.ActuatedPrismatic actuatedPrismatic(
              n=n,
              initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
              s_start=s_rel0,
              animation=false,
              enforceStates=true)
              annotation (extent=[20,0; 40,20],   rotation=90);
            MultiBondLib.Mechanics3D.Interfaces.Frame_a frame_a
              annotation (extent=[-40,60; 0,80], rotation=90);
            MultiBondLib.Mechanics3D.Interfaces.Frame_b frame_b
              annotation (extent=[10,-80; 50,-60], rotation=90);
            annotation (
              Icon(
                Polygon(points=[-24,70; 26,-70; 34,-70; -16,70; -24,70; -24,70],
                                                                           style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=0,
                    rgbfillColor={0,0,0})),
                Line(points=[-8,16; -28,0; 38,0; 18,-16], style(
                    color=2,
                    rgbcolor={0,255,0},
                    fillColor=10,
                    rgbfillColor={95,95,95},
                    fillPattern=1)),
                Line(points=[8,-24; -14,-42; 48,-42], style(
                    color=2,
                    rgbcolor={0,255,0},
                    fillColor=10,
                    rgbfillColor={95,95,95},
                    fillPattern=1)),
                Line(points=[-38,42; 24,42; 2,24], style(
                    color=2,
                    rgbcolor={0,255,0},
                    fillColor=10,
                    rgbfillColor={95,95,95},
                    fillPattern=1)),
                Text(
                  extent=[-80,-90; 80,-130],
                  style(
                    color=3,
                    rgbcolor={0,0,255},
                    gradient=2,
                    fillColor=70,
                    rgbfillColor={45,96,172}),
                  string="%name")),
              Diagram,
              Coordsys(scale=0.15));
            Utilities.CharacteristicSpring characteristicSpring(spring_table=
                  spring_table, s_rel0=s_rel0 + bias)
              annotation (extent=[-10,0; 10,20], rotation=90);
            Utilities.CharacteristicDamper characteristicDamper(damper_table=
                  damper_table) annotation (extent=[-30,0; -10,20], rotation=90);
          equation
            connect(actuatedPrismatic.frame_b, frame_a) annotation (points=[30,
                  21; 30,40; -20,40; -20,70], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(actuatedPrismatic.frame_a, frame_b) annotation (points=[30,
                  -1; 30,-70], style(
                color=0,
                rgbcolor={0,0,0},
                thickness=2));
            connect(characteristicSpring.flange_b, actuatedPrismatic.axis)
              annotation (points=[6.0618e-016,19.9; 23,19.9; 23,17], style(
                  color=58, rgbcolor={0,127,0}));
            connect(characteristicSpring.flange_a, actuatedPrismatic.bearing)
              annotation (points=[-6.12303e-016,0; 23,0; 23,4], style(color=58,
                  rgbcolor={0,127,0}));
            connect(characteristicDamper.flange_b, characteristicSpring.flange_b)
              annotation (points=[-20,19.9; 6.0618e-016,19.9], style(color=58,
                  rgbcolor={0,127,0}));
            connect(characteristicDamper.flange_a, characteristicSpring.flange_a)
              annotation (points=[-20,0; -6.12303e-016,0], style(color=58,
                  rgbcolor={0,127,0}));
          end RearSuspension_Ind;
        end RearSuspensions;
      end SwingingArms;

      model RearFrame
        import SI = Modelica.SIunits;
        import CO = Modelica.SIunits.Conversions;
        import MB = Modelica.Mechanics.MultiBody;

        parameter SI.Position R_rw = 1 "Rear wheel radius";

        parameter SI.Mass m = 1 "mass of rear frame";

        parameter SI.Position p1[3] = {1,1,0} "Center of preasure";
        parameter SI.Position p2[3] = {1,1,0}
          "Attachment point rear frame to steering axis";
        parameter SI.Position p8[3] = {1,1,0} "Center of mass rear frame";
        parameter SI.Position p9[3] = {1,1,0}
          "Attachment point rider to rear frame";
        parameter SI.Position p11[3] = {1,1,0}
          "Attachment point swinging arm to rear frame";

        final parameter SI.Distance ap[3] = {p9[1]-p11[1], R_rw - p9[2], 0};

        final parameter SI.Distance CoM_RF[3] = {p8[1]-p11[1], R_rw - p8[2],0};
        final parameter SI.Distance rSA[3] = {p2[1]-p11[1],p11[2]-p2[2],0}
          "Attachment rear frame to steering axis";

        final parameter SI.Distance CoP[3] = {p1[1]-p11[1], R_rw-p1[2],0};

      // TAB: Intertia Tensor of the Rear Frame - Rear Frame parameter
        parameter SI.Inertia I_11=0.001
          "|Inertia tensor|| (1,1) element of inertia tensor";

        parameter SI.Inertia I_22=0.001
          "|Inertia tensor|| (2,2) element of inertia tensor";

        parameter SI.Inertia I_33=0.001
          "|Inertia tensor|| (3,3) element of inertia tensor";

        parameter SI.Inertia I_21=0
          "|Inertia tensor|| (2,1) element of inertia tensor";

        parameter SI.Inertia I_31=0
          "|Inertia tensor|| (3,1) element of inertia tensor";

        parameter SI.Inertia I_32=0
          "|Inertia tensor|| (3,2) element of inertia tensor";

      // TAB: Advanced - State Selection
        parameter Boolean enforceStates =  false
          "|Advanced||enforce lean angle and lean rate as states - <true> in order to perform an eigenvalue analysis or a controller design";

        // Calculation of the lean angle
      protected
        Real eAxis[3] "unit vector aligned to wheel Axis in inertial frame";
      public
        Real leanAngle(stateSelect= if enforceStates then StateSelect.always else StateSelect.prefer);
        Real leanRate(stateSelect= if enforceStates then StateSelect.always else StateSelect.prefer)
          "Derivative of the lean angle";

        // Animation

        // x Coordinates of the nodes
        parameter SI.Position node1 = 0 "|Animation || xposition of node1";
      protected
        parameter SI.Position stabPos = node1 + 0.2
          "xposition of the stabilization pipe";
        parameter SI.Position node3 = stabPos + 0.25 "xposition of node3";
        parameter SI.Position node4 = node1 "xposition of node4";
        parameter SI.Position node5 = stabPos "xposition of node5";

        // The Rear Frame of the motorcycle is defined by 5 nodes
      protected
        final parameter SI.Position RFnode1[3] = {-node1,0,0};
        final parameter SI.Position RFnode2[3] = {-stabPos,0,0};
        final parameter SI.Position RFnode3[3] = {-node3,0,0};
        final parameter SI.Position RFnode4[3] = {-node4,p2[2]-p11[2]-0.1,0};
        final parameter SI.Position RFnode5[3] = {-node5,p2[2]-p11[2]+0.025,0};

      public
        parameter MB.Types.Color FrameColor = {255,165,0}
          "|Animation || Color of the Rear Frame";
        parameter MB.Types.Color FrameColor2 = {255,127,0}
          "|Animation || Color of the Rear Frame's lower parts";

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW12Right(
           lengthDirection= RFnode2 "Vector in length direction",
           length=stabPos - node1 "Length of visual object",
           shapeType="cylinder",
           color=FrameColor2,
           width=0.06 "Width of visual object",
           height=0.04 "Height of visual object",
           r_shape=RFnode1 + {0,0,0.1},
           r=SwingingArm.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW12Left(
           lengthDirection= RFnode2,
           length=stabPos - node1,
           shapeType="cylinder",
           color=FrameColor2,
           width=0.06,
           height=0.04,
           r_shape=RFnode1 + {0,0,-0.1},
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspRight(
           lengthDirection=RFnode2,
           length=sqrt(RFnode1*RFnode1),
           shapeType="cylinder",
           color=FrameColor,
           width=0.06,
           height=0.04,
           r_shape={0,0,0.1},
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RWSuspLeft(
           lengthDirection=RFnode2,
           length=sqrt(RFnode1*RFnode1),
           shapeType="cylinder",
           color=FrameColor,
           width=0.06,
           height=0.04,
           r_shape={0,0,-0.1},
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape StabPosPipe(
          shapeType="cylinder",
          color=FrameColor,
          widthDirection={1,0,0},
          r_shape=RFnode2+{0,0,-0.08},
          lengthDirection={0,0,1},
          width=0.08,
          height=0.08,
          length=0.16,
          r=SwingingArm.P.x,
          R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape VertPipeRight(
          shapeType="cylinder",
          color=FrameColor,
          r_shape=RFnode1 + {0,0,0.1},
          lengthDirection=RFnode4-RFnode1,
          width=0.06,
          height=0.04,
          length= RFnode4[2],
          r=SwingingArm.P.x,
          R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape VertPipeLeft(
          shapeType="cylinder",
          color=FrameColor,
          r_shape=RFnode1 + {0,0,-0.1},
          lengthDirection=RFnode4-RFnode1,
          width=0.06,
          height=0.04,
          length= RFnode4[2],
          r=SwingingArm.P.x,
          R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Node4Pipe(
          shapeType="cylinder",
          color=FrameColor,
          widthDirection={1,0,0},
          r_shape=RFnode4+{0,0,-0.08},
          lengthDirection={0,0,1},
          width=0.08,
          height=0.08,
          length=0.16,
          r=SwingingArm.P.x,
          R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape BackRight(
           lengthDirection= {1,0.25,0},
           length= p11[1]+0.1,
           shapeType="cylinder",
           color=FrameColor,
           width=0.06,
           height=0.04,
           r_shape=RFnode4 + {0,0,0.1},
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape BackLeft(
           lengthDirection= {1,0.25,0},
           length= p11[1]+0.1,
           shapeType="cylinder",
           color=FrameColor,
           width=0.06,
           height=0.04,
           r_shape=RFnode4 + {0,0,-0.1},
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW45Right(
           lengthDirection= RFnode4 - RFnode5,
           length=sqrt((RFnode5[1]-RFnode4[1])*(RFnode5[1]-RFnode4[1]) + (RFnode5[2]-RFnode4[2])*(RFnode5[2]-RFnode4[2])),
           shapeType="cylinder",
           color=FrameColor,
           width=0.06,
           height=0.04,
           r_shape=RFnode5 + {0,0,0.1},
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW45Left(
           lengthDirection= RFnode4 - RFnode5,
           length=sqrt((RFnode5[1]-RFnode4[1])*(RFnode5[1]-RFnode4[1]) + (RFnode5[2]-RFnode4[2])*(RFnode5[2]-RFnode4[2])),
           shapeType="cylinder",
           color=FrameColor,
           width=0.06,
           height=0.04,
           r_shape=RFnode5 + {0,0,-0.1},
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Node5Pipe(
          shapeType="cylinder",
          color=FrameColor,
          widthDirection={1,0,0},
          r_shape=RFnode5+{0,0,-0.08},
          lengthDirection={0,0,1},
          width=0.08,
          height=0.08,
          length=0.16,
          r=SwingingArm.P.x,
          R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Stabilizer(
          shapeType="cylinder",
          color=FrameColor,
          r_shape=RFnode2,
          lengthDirection=RFnode5 - RFnode2,
          width=0.06,
          height=0.04,
          length=RFnode5[2],
          r=SwingingArm.P.x,
          R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape Node3Pipe(
          shapeType="cylinder",
          color=FrameColor,
          widthDirection={1,0,0},
          r_shape=RFnode3+{0,0,-0.08},
          lengthDirection={0,0,1},
          width=0.08,
          height=0.08,
          length=0.16,
          r=SwingingArm.P.x,
          R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW23Right(
           lengthDirection= RFnode2 - RFnode3,
           length=node3 - stabPos,
           shapeType="cylinder",
           color=FrameColor2,
           width=0.06,
           height=0.04,
           r_shape=RFnode3 + {0,0,0.1},
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RW23Left(
           lengthDirection= RFnode2 - RFnode3,
           length=node3 - stabPos,
           shapeType="cylinder",
           color=FrameColor2,
           width=0.06,
           height=0.04,
           r_shape=RFnode3 + {0,0,-0.1},
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
          lowerframepipeRight(
           shapeType="cylinder",
           color=FrameColor2,
           r_shape=RFnode3+{0,0,0.1},
           width=0.04,
           height=0.06,
           lengthDirection=-fixedTranslationSA.r-RFnode3,
           widthDirection={0,0,1},
           length=sqrt((-fixedTranslationSA.r-RFnode3)*(-fixedTranslationSA.r-RFnode3)),
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
          lowerframepipeLeft(
           shapeType="cylinder",
           color=FrameColor2,
           r_shape=RFnode3+{0,0,-0.1},
           width=0.04,
           height=0.06,
           lengthDirection=-fixedTranslationSA.r-RFnode3,
           widthDirection={0,0,1},
           length=sqrt((-fixedTranslationSA.r-RFnode3)*(-fixedTranslationSA.r-RFnode3)),
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

         Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
          upperframepipeRight(
           shapeType="cylinder",
           color=FrameColor,
           width=0.04,
           height=0.06,
           widthDirection={0,0,1},
           r_shape=RFnode5+{0,0,0.1},
           lengthDirection=(-fixedTranslationSA.r-RFnode5),
           length=sqrt((-fixedTranslationSA.r-RFnode5)*(-fixedTranslationSA.r-RFnode5)),
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
          upperframepipeLeft(
           shapeType="cylinder",
           color=FrameColor,
           width=0.04,
           height=0.06,
           widthDirection={0,0,1},
           r_shape=RFnode5+{0,0,-0.1},
           lengthDirection=(-fixedTranslationSA.r-RFnode5),
           length=sqrt((-fixedTranslationSA.r-RFnode5)*(-fixedTranslationSA.r-RFnode5)),
           r=SwingingArm.P.x,
           R=MB.Frames.Orientation(T=SwingingArm.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape CoP_Point(
           shapeType="sphere",
           color={0,0,255},
           width=0.1,
           length=0.1,
           height=0.1,
           widthDirection={0,1,0},
           lengthDirection={1,0,0},
           r_shape=-{1,0,0}*0.1/2,
           r=CenterOfPressure.frame_a.P.x,
           R=MB.Frames.Orientation(T=CenterOfPressure.frame_a.P.R,w=zeros(3)));

        annotation (
          Icon(
            Polygon(points=[124,28; 64,4; 64,-6; 124,18; 124,28], style(
                pattern=0,
                gradient=1,
                fillColor=10,
                rgbfillColor={135,135,135})),
            Rectangle(extent=[54,-76; -56,-66], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=2,
                fillColor=10,
                rgbfillColor={135,135,135})),
            Polygon(points=[-106,80; -52,-66; -56,-76; -112,74; -106,80], style(
                pattern=0,
                gradient=1,
                fillColor=10,
                rgbfillColor={135,135,135})),
            Polygon(points=[-112,84; 54,4; 54,-6; -112,74; -112,84], style(
                pattern=0,
                fillColor=10,
                rgbfillColor={135,135,135})),
            Rectangle(extent=[64,-76; 54,4], style(
                pattern=0,
                gradient=1,
                fillColor=10,
                rgbfillColor={135,135,135})),
            Rectangle(extent=[50,-80; -60,-70], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172})),
            Polygon(points=[-110,76; -56,-70; -60,-80; -116,70; -110,76], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172})),
            Polygon(points=[-116,80; 50,0; 50,-10; -116,70; -116,80], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172})),
            Rectangle(extent=[60,-80; 50,0], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=1,
                fillColor=70,
                rgbfillColor={45,96,172})),
            Text(extent=[-50,-58; 48,-134],
              style(
                pattern=0,
                gradient=1,
                fillColor=70,
                rgbfillColor={45,96,172}),
              string="%name"),
            Polygon(points=[120,24; 60,0; 60,-10; 120,14; 120,24], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=2,
                fillColor=70,
                rgbfillColor={45,96,172})),
            Line(points=[120,70; 70,70; 18,18], style(color=0, rgbcolor={0,0,0})),
            Line(points=[82,-60; 66,-60; 62,-60],
                                                style(color=0, rgbcolor={0,0,0}))),
          Coordsys(extent=[-120,-100; 120,100], scale=0.25),
          Diagram(
            Line(points=[50,40; 80,40; 80,70; 120,70],   style(
                color=10,
                rgbcolor={95,95,95},
                pattern=2))));
        MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslationSA(
                            r=rSA, animation=false)
                                                 annotation (extent=[-86,-70;
              -66,-50]);
        MultiBondLib.Mechanics3D.Interfaces.Frame_b SwingingArm
          annotation (extent=[80,-80; 108,-40]);
        MultiBondLib.Mechanics3D.Interfaces.Frame_a SteeringAxis
          annotation (extent=[-144,60; -116,100]);
        MultiBondLib.Mechanics3D.Parts.SimpleBody RearMass(
          sphereDiameter=0.1,
          animation=true,
          m=m,
          I_11=I_11,
          I_22=I_22,
          I_33=I_33,
          I_21=I_21,
          I_31=I_31,
          I_32=I_32)
               annotation (extent=[40,70; 60,90], rotation=90);
        MultiBondLib.Mechanics3D.Parts.FixedTranslation RearFrameCoM(animation=
              false, r=CoM_RF)
                      annotation (extent=[40,-40; 60,-20],
                                                         rotation=270);
        MultiBondLib.Mechanics3D.Interfaces.Frame_a RiderUpperBody
          annotation (extent=[-20,14; 0,34],  rotation=90);
        MultiBondLib.Mechanics3D.Parts.FixedTranslation CenterOfPressure(
            animation=false, r=CoP)
                      annotation (extent=[-60,-40; -40,-20],
                                                         rotation=270);
        MultiBondLib.Mechanics3D.Interfaces.Frame_a Aerodynamics_CoP
          annotation (
          extent=[-60,-10; -40,10],
          rotation=90,
          style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=1,
            rgbfillColor={255,0,0}));
        MultiBondLib.Mechanics3D.Parts.FixedTranslation AttachmentPoint(r=ap,
            animation=false)                     annotation (extent=[-20,-40; 0,
              -20],
            rotation=270);
        Modelica.Blocks.Interfaces.RealOutput phi
          "lean (roll) angle of the rear frame"
          annotation (extent=[120,60; 140,80]);
        MultiBondLib.Mechanics3D.Interfaces.Frame_a CoM
          annotation (extent=[10,-34; 30,-14],rotation=90);
      equation
        // lean angle calculation - scalar product
        eAxis = transpose(RearFrameCoM.frame_a.P.R)*{0,0,1};
        leanAngle = -arcsin({0,1,0}*eAxis);
        phi = leanAngle;
        leanRate = der(leanAngle);

        connect(fixedTranslationSA.frame_a, SteeringAxis)
                                           annotation (points=[-87,-60; -100,
              -60; -100,80; -130,80],
                                style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=3,
            rgbfillColor={0,0,255},
            fillPattern=1));
        connect(fixedTranslationSA.frame_b, SwingingArm)
                                          annotation (points=[-65,-60; 13.5,-60;
              13.5,-60; 94,-60],
                               style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=3,
            rgbfillColor={0,0,255},
            fillPattern=1));
        connect(RearFrameCoM.frame_a, RearMass.frame_a) annotation (points=[50,-19;
              50,69],                   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=30,
            rgbfillColor={215,215,215},
            fillPattern=1));
        connect(RearFrameCoM.frame_b, SwingingArm) annotation (points=[50,-41;
              50,-60; 94,-60], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=30,
            rgbfillColor={215,215,215},
            fillPattern=1));
        connect(CenterOfPressure.frame_a, Aerodynamics_CoP) annotation (points=[-50,-19;
              -50,0],                               style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=30,
            rgbfillColor={215,215,215},
            fillPattern=1));
        connect(CenterOfPressure.frame_b, SwingingArm) annotation (points=[-50,-41;
              -50,-60; 94,-60],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=30,
            rgbfillColor={215,215,215},
            fillPattern=1));
        connect(SteeringAxis, SteeringAxis) annotation (points=[-130,80; -130,
              80],                   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=10,
            rgbfillColor={95,95,95},
            fillPattern=1));
        connect(AttachmentPoint.frame_b, SwingingArm) annotation (points=[-10,-41;
              -10,-60; 94,-60],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=3,
            rgbfillColor={0,0,255},
            fillPattern=1));
        connect(AttachmentPoint.frame_a, RiderUpperBody) annotation (points=[-10,-19;
              -10,2.5; -10,2.5; -10,24],          style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RearFrameCoM.frame_a, CoM) annotation (points=[50,-19; 50,0; 20,
              0; 20,-24], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end RearFrame;

      model RiderUpperBody "1 d.o.f. model of rider's upper body"

        import SI = Modelica.SIunits;
        import CO = Modelica.SIunits.Conversions;
        import MB = Modelica.Mechanics.MultiBody;

        parameter CO.NonSIunits.Angle_deg phi_start = 0 "Riders lean angle";
        final parameter SI.Angle phi_start_rad = CO.from_deg(phi_start);

        final parameter SI.Position n[3] = {1,0,0}
          "direction of revloute joint";

        parameter SI.Mass m = 1 "mass of front suspension";

        parameter Real c(
          final unit="N.m/rad",
          final min=0) = 1 "Rider stiffness";

        parameter Real d(
          final unit="N.m/(rad/s)",
          final min=0) = 0 "Rider damping constant";

        parameter SI.Position p9[3] = {1,1,0}
          "Attachment point rider to rear frame";
        parameter SI.Position p10[3] = {1,1,0} "Center of mass rider";
        final parameter SI.Distance CoM_R[3] = {p10[1]-p9[1],p10[2]-p9[2],0};

        parameter SI.Inertia I_11=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (1,1) element of inertia tensor";

        parameter SI.Inertia I_22=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,2) element of inertia tensor";

        parameter SI.Inertia I_33=0.001
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,3) element of inertia tensor";

        parameter SI.Inertia I_21=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,1) element of inertia tensor";

        parameter SI.Inertia I_31=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,1) element of inertia tensor";

        parameter SI.Inertia I_32=0
          "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,2) element of inertia tensor";

      // Animation
        final parameter SI.Position riderConnect[3] = {0.345, 0.9, 0};
        final parameter SI.Position riderHead[3] = {0.345, 1.4, 0};

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderBody(
           lengthDirection= {-0.2,1,0} "Vector in length direction",
           length=riderHead[2] - riderConnect[2] "Length of visual object",
           shapeType="beam",
           color={50, 155, 50},
           width=0.05 "Width of visual object",
           height=0.1 "Height of visual object",
           r_shape={0,0,0},
           r=revolute.frame_b.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=revolute.frame_b.P.R,w=zeros(3)))
          "Rotation of the part";

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderRightHand(
           lengthDirection= {-1,-1,0.2} "Vector in length direction",
           length=0.4 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.05 "Height of visual object",
           r_shape={0,0.5,0.08}- {0.1,0,0},
           r=revolute.frame_b.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=revolute.frame_b.P.R,w=zeros(3)))
          "Rotation of the part";

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderLeftHand(
           lengthDirection= {-1,-1,-0.2} "Vector in length direction",
           length=0.4 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.05 "Height of visual object",
           r_shape={0,0.5,-0.08} - {0.1,0,0},
           r=revolute.frame_b.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=revolute.frame_b.P.R,w=zeros(3)))
          "Rotation of the part";

       Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderHead(
           lengthDirection= {0,1,0} "Vector in length direction",
           length=0.25 "Length of visual object",
           shapeType="sphere",
           color={200,200,155},
           width=0.25 "Width of visual object",
           height=0.25 "Height of visual object",
           r_shape={0,0.5,0} - {0.12,0,0}
            "Offset - rider head is 0.5m above the rider body",
           r=revolute.frame_b.P.x "Same origin as the rider body",
           R=MB.Frames.Orientation(T=revolute.frame_b.P.R,w=zeros(3)));

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderRightLeg(
           lengthDirection= {-1,-0.75,0.3} "Vector in length direction",
           length=0.37 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.1 "Height of visual object",
           r_shape={0,0,0.1},
           r=revolute.frame_a.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=revolute.frame_a.P.R,w=zeros(3)))
          "Rotation of the part";

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderRightLeg2(
           lengthDirection= {0.7,-1,-0.3} "Vector in length direction",
           length=0.35 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.1 "Height of visual object",
           r_shape={-1,-0.75,0}*0.3 + {0,0,0.19},
           r=revolute.frame_a.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=revolute.frame_a.P.R,w=zeros(3)))
          "Rotation of the part";

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderLeftLeg(
           lengthDirection= {-1,-0.75,-0.3} "Vector in length direction",
           length=0.37 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.1 "Height of visual object",
           r_shape={0,0,-0.1},
           r=revolute.frame_a.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=revolute.frame_a.P.R,w=zeros(3)))
          "Rotation of the part";

        Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape RiderLeftLeg2(
           lengthDirection= {0.7,-1,0.3} "Vector in length direction",
           length=0.35 "Length of visual object",
           shapeType="beam",
           color={50, 50, 50},
           width=0.05 "Width of visual object",
           height=0.1 "Height of visual object",
           r_shape={-1,-0.75,0}*0.3 + {0,0,-0.19},
           r=revolute.frame_a.P.x "Origin of visual object",
           R=MB.Frames.Orientation(T=revolute.frame_a.P.R,w=zeros(3)))
          "Rotation of the part";

        annotation (Icon(
            Line(points=[100,0; 90,0], style(color=0, rgbcolor={0,0,0})),
            Rectangle(extent=[-32,-94; 50,-62], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=1,
                fillColor=46,
                rgbfillColor={198,133,43})),
            Polygon(points=[-96,-30; -74,-96; 90,-28; 92,22; 88,40; 80,54; 74,
                  62; 66,70; 50,82; 32,90; 14,94; -8,94; -28,90; -48,82; -68,68;
                  -80,56; -96,-30], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=45,
                rgbfillColor={255,128,0})),
            Polygon(points=[-74,-96; -68,-100; 82,-54; 90,-28; -74,-96], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=2,
                fillColor=0,
                rgbfillColor={0,0,0})),
            Text(extent=[-100,132; 100,92], string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=42,
                rgbfillColor={149,30,30})),
            Polygon(points=[-80,56; 64,24; 64,14; -96,-30; -80,56], style(
                color=7,
                rgbcolor={255,255,255},
                fillColor=42,
                rgbfillColor={127,0,0},
                fillPattern=8)),
            Text(
              extent=[102,-104; 54,-82],
              string="Lean Angle",
              style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=42,
                rgbfillColor={127,0,0},
                fillPattern=7))), Diagram(
      Rectangle(extent=[60,20; 80,0],     style(color=83, rgbcolor={255,85,255})),
      Text(
      extent=[60,20; 80,0],
      style(color=83, rgbcolor={255,85,255}),
      string="Connected?"),
            Line(points=[46,10; 60,10],     style(color=83, rgbcolor={255,85,
                    255})),
            Line(points=[46,256; 72,256],   style(color=83, rgbcolor={255,85,
                    255}))),
          Coordsys(scale=0.125));
        MultiBondLib.Mechanics3D.Parts.FixedTranslation RiderCoM(r=CoM_R,
            animation=false)                     annotation (extent=[-70,20;
              -50,40],
            rotation=90);
        MultiBondLib.Mechanics3D.Parts.SimpleBody RiderMass(
          m=m,
          I_11=I_11,
          I_22=I_22,
          I_33=I_33,
          I_21=I_21,
          I_31=I_31,
          I_32=I_32,
          animation=true,
          sphereDiameter=0.1,
          sphereColor={0,180,0})
               annotation (extent=[-70,50; -50,70], rotation=90);
        MultiBondLib.Mechanics3D.Interfaces.Frame_b RearFrame
          annotation (extent=[-10,-104; 30,-84], rotation=90);
        BondLib.Mechanical.Rotational.Passive.Damper damper(d=d)
          annotation (extent=[-18,-40; 2,-20], rotation=270);
        BondLib.Mechanical.Rotational.Passive.Spring spring(     phi_rel0=0, c=c)
          annotation (extent=[-38,-40; -18,-20],
                                               rotation=270);
        Modelica.Blocks.Interfaces.RealOutput leanAngle annotation (
          extent=[50,-90; 70,-70],
          rotation=0,
          style(color=0, rgbcolor={0,0,0}));
        MultiBondLib.Mechanics3D.Joints.ActuatedRevolute revolute(
          n=n,
          initType=Modelica.Mechanics.MultiBody.Types.Init.Velocity,
          cylinderColor={155,0,0},
          cylinderLength=0.1,
          cylinderDiameter=0.05,
          enforceStates=true)
          annotation (extent=[-70,-40; -50,-20],
                                               rotation=90);
        BondLib.Mechanical.Rotational.Sensors.RelAngleSensor relAngleSensor
          annotation (extent=[4,-40; 24,-20],rotation=90);
        Modelica.Blocks.Interfaces.RealInput T_RiderLean "rider lean torque"
          annotation (extent=[122,-12; 100,12],   rotation=0);
        Modelica.Blocks.Logical.Switch switch3
          annotation (extent=[40,0; 20,20]);
        BondLib.Mechanical.Rotational.Sources.Torque torque2
          annotation (extent=[0,0; -20,20],    rotation=0);
        Modelica.Blocks.Sources.Constant const(k=0)
          annotation (extent=[80,-50; 60,-30]);
      equation
        if cardinality(T_RiderLean) <= 1 then
          T_RiderLean = 0;
          switch3.u2 = false;
        else
          switch3.u2 = true;
        end if;
        connect(RearFrame, RearFrame) annotation (points=[10,-94; 12.5,-94;
              12.5,-94; 15,-94; 15,-94; 10,-94], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            gradient=2,
            fillColor=45,
            rgbfillColor={255,128,0}));
        connect(RiderCoM.frame_b, RiderMass.frame_a)           annotation (
            points=[-60,41; -60,49], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(damper.flange_a, spring.flange_a)
          annotation (points=[-8,-20; -28,-20],
                                            style(color=0, rgbcolor={0,0,0}));
        connect(damper.flange_b, spring.flange_b) annotation (points=[-8,-40;
              -28,-40], style(color=0, rgbcolor={0,0,0}));
        connect(revolute.frame_b, RiderCoM.frame_a)         annotation (points=[-60,-19;
              -60,19],    style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=1,
            rgbfillColor={255,0,0},
            fillPattern=1));
        connect(revolute.frame_a, RearFrame)         annotation (points=[-60,-41;
              -60,-68; 10,-68; 10,-94],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=1,
            rgbfillColor={255,0,0},
            fillPattern=1));
        connect(spring.flange_b, revolute.bearing)         annotation (points=[-28,-40;
              -40,-40; -40,-37; -53,-37],          style(
            color=0,
            rgbcolor={0,0,0},
            fillColor=1,
            rgbfillColor={255,0,0},
            fillPattern=1));
        connect(spring.flange_a, revolute.axis)         annotation (points=[-28,-20;
              -40,-20; -40,-23; -53,-23],style(
            color=0,
            rgbcolor={0,0,0},
            fillColor=1,
            rgbfillColor={255,0,0},
            fillPattern=1));
        connect(relAngleSensor.flange_b, damper.flange_a)
          annotation (points=[14,-20; -8,-20],
                                           style(color=0, rgbcolor={0,0,0}));
        connect(relAngleSensor.flange_a, damper.flange_b) annotation (points=[14,-40;
              -8,-40],         style(color=0, rgbcolor={0,0,0}));
        connect(relAngleSensor.phi_rel, leanAngle) annotation (points=[24,-30;
              40,-30; 40,-80; 60,-80], style(color=74, rgbcolor={0,0,127}));
        connect(switch3.y, torque2.tau) annotation (points=[19,10; 1,10], style(
              color=74, rgbcolor={0,0,127}));
        connect(torque2.flange_b, revolute.axis) annotation (points=[-20,10;
              -40,10; -40,-23; -53,-23], style(color=0, rgbcolor={0,0,0}));
        connect(const.y, switch3.u3) annotation (points=[59,-40; 54,-40; 54,2;
              42,2], style(color=74, rgbcolor={0,0,127}));
        connect(switch3.u1, T_RiderLean) annotation (points=[42,18; 54,18; 54,
              30; 90,30; 90,0; 111,0], style(color=74, rgbcolor={0,0,127}));
      end RiderUpperBody;

      annotation (Documentation(info="<html>

<p>
<img src=\"../Images/advancedParts.png\" width=\"531\" height=\"290\">
</p>

</html>"), Icon(
          Rectangle(extent=[-100,-100; 80,50],   style(fillColor=30,
                fillPattern=
                  1)),
          Ellipse(extent=[-36,-80; -84,-30], style(color=42, rgbcolor={127,0,0})),
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
                fillColor=30, fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
                fillColor=30, fillPattern=1)),
          Text(
            extent=[-120,125; 120,70],
            string="%name",
            style(color=3, rgbcolor={0,0,255})),
          Line(points=[-36,-10; -12,40; 12,-10; -36,-10], style(color=58,
                rgbcolor={0,127,0})),
          Line(points=[14,-30; 14,-80; 62,-80; 62,-30; 14,-30], style(color=3,
                rgbcolor={0,0,255}))));

      model Engine
        "Applies a torque to the rear wheel in order to keep the velocity constant"

        BondLib.Mechanical.Rotational.Sources.Torque torque
          annotation (extent=[-2,-18; 18,2],  rotation=90);
        BondLib.Mechanical.Rotational.Interfaces.Flange_a flange_a
          annotation (extent=[90,-90; 110,-70]);
        BondLib.Mechanical.Rotational.Interfaces.Flange_b flange_b
          annotation (extent=[90,10; 110,30]);
        annotation (
          Diagram,
          Icon(
            Line(points=[-10,-80; 90,-80], style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[100,80; 40,100],
              style(
                color=3,
                rgbcolor={0,0,255},
                gradient=2,
                fillColor=71,
                rgbfillColor={85,170,255}),
              string="%name"),
            Rectangle(extent=[-70,80; 10,60], style(
                color=10,
                rgbcolor={95,95,95},
                fillColor=10,
                rgbfillColor={95,95,95})),
        Polygon(points=[-70,-40; -60,-40; -50,-16; 30,-16; 40,-40; 50,-40; 50,
                  -48; -70,-48; -70,-40],           style(
            color=0,
            gradient=0,
            fillColor=0,
            fillPattern=1)),
            Rectangle(extent=[50,30; 70,10],   style(
                color=10,
                rgbcolor={95,95,95},
                gradient=2,
                fillColor=10,
                rgbfillColor={95,95,95})),
            Rectangle(extent=[-70,60; 50,-16],    style(
                color=3,
                rgbcolor={0,0,255},
                gradient=2,
                fillColor=69,
                rgbfillColor={0,128,255})),
            Line(points=[70,20; 102,20; 106,20], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=2,
                fillColor=71,
                rgbfillColor={85,170,255})),
            Line(points=[-10,-80; -10,-48], style(
                color=0,
                rgbcolor={0,0,0},
                gradient=2,
                fillColor=71,
                rgbfillColor={85,170,255}))),
          DymolaStoredErrors);
        Modelica.Blocks.Interfaces.RealInput u
          annotation (extent=[-110,0; -70,40]);
      equation
        connect(torque.flange_b, flange_b) annotation (points=[8,2; 8,20; 100,
              20], style(color=0, rgbcolor={0,0,0}));
        connect(torque.bearing, flange_a) annotation (points=[18,-8; 44,-8; 44,
              -80; 100,-80],
                        style(color=0, rgbcolor={0,0,0}));
        connect(flange_a, flange_a) annotation (points=[100,-80; 100,-80; 100,
              -80],
            style(color=0, rgbcolor={0,0,0}));
        connect(torque.tau, u) annotation (points=[8,-19; 8,-28; -30,-28; -30,
              20; -90,20], style(color=74, rgbcolor={0,0,127}));

      end Engine;

      model ElastoGap

        import SI = Modelica.SIunits;

        output SI.Force F = flange_a.f - flange_b.f;

        parameter SI.Position s_rel0=0 "unstretched spring length";
        parameter Real c(
          final unit="N/m",
          final min=0) = 1 "spring constant";
        parameter Real d(
          final unit="N/ (m/s)",
          final min=0) = 1 "damping constant";

        annotation (Icon(
            Line(points=[-98,0; -48,0], style(color=58, rgbcolor={0,127,0})),
            Line(points=[-48,34; -48,-46],   style(color=0, thickness=4)),
            Line(points=[8,40; 8,2],   style(color=0)),
            Line(points=[-2,0; 38,0; 38,44; -2,44],     style(color=0)),
            Line(points=[38,22; 72,22],   style(color=0)),
            Line(points=[-12,-38; -12,20],   style(color=0, thickness=4)),
            Line(points=[-12,22; 8,22],   style(color=0)),
            Line(points=[-12,-38; -2,-38],   style(color=0)),
            Line(points=[72,0; 98,0], style(color=58, rgbcolor={0,127,0})),
            Line(points=[72,22; 72,-42],   style(color=0)),
            Line(points=[-2,-38; 10,-28; 22,-48; 38,-28; 50,-48; 64,-28; 72,-40],
                        style(color=0)),
            Rectangle(extent=[8,44; 38,0],   style(
                color=0,
                fillColor=8,
                fillPattern=1)),
            Line(points=[-60,-90; 20,-90],   style(color=0, fillColor=10)),
            Polygon(points=[50,-90; 20,-80; 20,-100; 50,-90],     style(color=10,
                  fillColor=10)),
            Text(
              extent=[-100,100; 100,40],
              style(color=3, rgbcolor={0,0,255}),
              string="%name")), Diagram,
          DymolaStoredErrors);
        BondLib.Mechanical.Translational.Interfaces.Flange_a flange_a
          annotation (extent=[-110,-10; -90,10]);
        BondLib.Mechanical.Translational.Interfaces.Flange_b flange_b
          annotation (extent=[90,-10; 110,10]);
        BondLib.Mechanical.Translational.Passive.Damper damper(d=d)
          annotation (extent=[44,70; 64,90], rotation=0);
        BondLib.Mechanical.Translational.Passive.Spring spring(          c=c, s_rel0=
              s_rel0)
          annotation (extent=[44,50; 64,70], rotation=180);
        BondLib.Mechanical.Translational.Sensors.ForceSensor forceSensor
          annotation (extent=[-18,50; 2,70]);
        BondLib.Mechanical.Translational.Sensors.RelPositionSensor
          relPositionSensor annotation (extent=[-10,-88; 10,-68], rotation=180);
        BondLib.Mechanical.Translational.Sources.Force force
          annotation (extent=[60,-10; 80,10]);
        Modelica.Blocks.Logical.Switch switch1
          annotation (extent=[-10,8; 10,28],  rotation=270);
        Modelica.Blocks.Math.Gain gain(k=-1)
                                            annotation (extent=[20,-10; 40,10]);
        Modelica.Blocks.Sources.Constant const1(k=0)
          annotation (extent=[-28,74; -8,94],  rotation=0);
        Modelica.Blocks.Math.Gain gain1(k=1)
                                            annotation (extent=[-40,-10; -20,10],
            rotation=180);
        BondLib.Mechanical.Translational.Sources.Force force1
          annotation (extent=[-80,-10; -60,10], rotation=180);
        Modelica.Blocks.Sources.Constant const2(k=s_rel0)
          annotation (extent=[40,-36; 60,-16], rotation=180);
        Modelica.Blocks.Logical.Greater greater
          annotation (extent=[-38,-44; -18,-24], rotation=180);
      equation
        connect(force.flange_b, flange_b)
          annotation (points=[80,0; 100,0], style(color=58, rgbcolor={0,127,0}));
        connect(gain.y, force.f)
          annotation (points=[41,0; 61,0], style(color=74, rgbcolor={0,0,127}));
        connect(force1.flange_b, flange_a) annotation (points=[-80,1.22461e-015;
              -90,1.22461e-015; -90,0; -100,0],
                                            style(color=58, rgbcolor={0,127,0}));
        connect(force1.f, gain1.y) annotation (points=[-61,-1.10215e-015; -50,
              -1.10215e-015; -50,1.34707e-015; -41,1.34707e-015], style(color=74,
              rgbcolor={0,0,127}));
        connect(forceSensor.flange_a, force1.flange_b) annotation (points=[-18,60;
              -80,60; -80,1.22461e-015], style(color=58, rgbcolor={0,127,0}));
        connect(switch1.y, gain.u) annotation (points=[-2.0206e-015,7; 0,7; 0,0;
              18,0],
                  style(color=74, rgbcolor={0,0,127}));
        connect(gain1.u, switch1.y) annotation (points=[-18,-1.46953e-015;
              -2.0206e-015,-1.46953e-015; -2.0206e-015,7], style(color=74, rgbcolor=
               {0,0,127}));
        connect(greater.u2, const2.y)
          annotation (points=[-16,-26; 39,-26], style(color=74, rgbcolor={0,0,127}));
        connect(greater.y, switch1.u2) annotation (points=[-39,-34; -50,-34;
              -50,38; 2.20429e-015,38; 2.20429e-015,30],
                                                 style(color=5, rgbcolor={255,0,255}));
        connect(forceSensor.f, switch1.u3) annotation (points=[-8,50; -8,40; -8,
              30; -8,30],
                      style(color=74, rgbcolor={0,0,127}));
        connect(switch1.u1, const1.y) annotation (points=[8,30; 8,84; -7,84], style(
              color=74, rgbcolor={0,0,127}));
        connect(relPositionSensor.flange_b, force1.flange_b) annotation (points=[-9.9,-78;
              -80,-78; -80,1.22461e-015],      style(color=58, rgbcolor={0,127,0}));
        connect(relPositionSensor.flange_a, force.flange_b) annotation (points=[10,
              -78; 80,-78; 80,0], style(color=58, rgbcolor={0,127,0}));
        connect(damper.flange_a, forceSensor.flange_b) annotation (points=[44,80;
              28,80; 28,60; 1.9,60],
                                  style(color=58, rgbcolor={0,127,0}));
        connect(damper.flange_b, force.flange_b) annotation (points=[63.9,80; 80,80;
              80,0], style(color=58, rgbcolor={0,127,0}));
        connect(greater.u1, relPositionSensor.s_rel) annotation (points=[-16,-34;
              1.22461e-015,-34; 1.22461e-015,-68], style(color=74, rgbcolor={0,0,
                127}));
        connect(spring.flange_b, forceSensor.flange_b) annotation (points=[44.1,60;
              1.9,60],     style(color=58, rgbcolor={0,127,0}));
        connect(spring.flange_a, force.flange_b) annotation (points=[64,60; 80,60;
              80,0], style(color=58, rgbcolor={0,127,0}));
      end ElastoGap;

      package Utilities
        "modified spring and damper elements for specific element characterisics (use of records)"
        model CharacteristicSpring "Linear 1D translational spring"
          extends BondLib.Mechanical.Translational.Interfaces.OnePort;

          parameter Real spring_table[:,:] = [0,0; 1,1];

          parameter Modelica.SIunits.Distance s_rel0=0
            "Unstretched spring length";

        protected
          BondLib.Mechanical.Translational.Interfaces.Tr2BG Tr2BG
            annotation (extent=[-70,-10; -50,10]);
          BondLib.Mechanical.Translational.Interfaces.BG2Tr BG2Tr
            annotation (extent=[50,-10; 70,10]);
          BondLib.Bonds.eBond B1
                          annotation (extent=[-30,30; -10,50]);
          BondLib.Bonds.fBond B2
                          annotation (extent=[10,30; 30,50]);
          BondLib.Junctions.J0p3 j0p3_1
                                 annotation (extent=[-10,30; 10,50]);
          BondLib.Sources.mSe Fx
            annotation (extent=[-10,-10; 10,10], rotation=-90);
          BondLib.Bonds.fBond B3
                          annotation (extent=[-10,10; 10,30], rotation=
                90);
          Modelica.Blocks.Math.Add3 A1(k3=-1)
            annotation (extent=[-30,-70; -10,-50]);
          Modelica.Blocks.Sources.Constant C1(k=s_rel0)
            annotation (extent=[-92,-70; -72,-50]);
        public
          Modelica.Blocks.Tables.CombiTable1Ds combiTable1Ds(table=spring_table)
            annotation (extent=[-10,-40; 10,-20], rotation=90);
        equation
          connect(j0p3_1.BondCon1,B1. eBondCon1) annotation (points=[-10,40;
                -10,40],
                    style(color=8, rgbcolor={192,192,192}));
          connect(j0p3_1.BondCon2,B2. eBondCon1) annotation (points=[10,40; 10,
                40],
              style(color=8, rgbcolor={192,192,192}));
          connect(Tr2BG.BondCon1,B1. fBondCon1) annotation (points=[-50,0; -40,
                0; -40,40; -30,40], style(color=8, rgbcolor={192,192,192}));
          connect(BG2Tr.BondCon1,B2. fBondCon1) annotation (points=[50,0; 40,0;
                40,40; 30,40], style(color=8, rgbcolor={192,192,192}));
          connect(Fx.BondCon1,B3. eBondCon1) annotation (points=[-6.12303e-016,
                10; -6.12303e-016,10], style(color=8, rgbcolor={192,192,192}));
          connect(B3.fBondCon1,j0p3_1. BondCon3) annotation (points=[
                6.12303e-016,30; 0,30], style(color=8, rgbcolor={192,192,192}));
          connect(C1.y,A1. u2) annotation (points=[-71,-60; -32,-60], style(
                color=74, rgbcolor={0,0,127}));
          annotation (
            Diagram,
            Icon(
              Line(points=[-60,-90; 20,-90],   style(color=0, fillColor=10)),
              Polygon(points=[50,-90; 20,-80; 20,-100; 50,-90],     style(color=10,
                    fillColor=10)),
              Text(extent=[0,110; 0,50],   string="%name"),
              Line(points=[-90,0; -60,0; -44,-30; -16,30; 14,-30; 44,30; 60,0;
                    90,0],    style(color=0)),
              Text(
                extent=[-60,-26; 60,-86],
                string="F = f(x)",
                style(color=0, rgbcolor={0,0,0}))),
            Documentation(info="<html>
Wrapped 1D linear translational spring model.
</html>"));
          connect(Tr2BG.Tr, flange_a) annotation (points=[-70.1,-0.1; -85.05,
                -0.1; -85.05,0; -100,0], style(color=58, rgbcolor={0,127,0}));

          connect(BG2Tr.Tr, flange_b) annotation (points=[69.9,-0.1; 82.95,-0.1;
                82.95,0; 99,0], style(color=58, rgbcolor={0,127,0}));
          connect(combiTable1Ds.y[1], Fx.s) annotation (points=[7.21645e-016,
                -19; 7.21645e-016,-15.5; 5.51073e-016,-15.5; 5.51073e-016,-9],
              style(color=74, rgbcolor={0,0,127}));
          connect(combiTable1Ds.u, A1.y) annotation (points=[-7.34764e-016,-42;
                0,-42; 0,-60; -9,-60], style(color=74, rgbcolor={0,0,127}));
          connect(A1.u3, BG2Tr.s) annotation (points=[-32,-68; -40,-68; -40,-80;
                60,-80; 60,-10], style(color=74, rgbcolor={0,0,127}));
          connect(A1.u1, Tr2BG.s) annotation (points=[-32,-52; -60,-52; -60,-10],
              style(color=74, rgbcolor={0,0,127}));
        end CharacteristicSpring;
        annotation (Icon(
            Rectangle(extent=[-100,-100; 80,50], style(
                color=42,
                rgbcolor={127,0,0},
                fillColor=30,
                rgbfillColor={235,235,235},
                fillPattern=1)),
            Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
                color=42,
                rgbcolor={127,0,0},
                fillColor=30,
                rgbfillColor={235,235,235},
                fillPattern=1)),
            Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
                color=42,
                rgbcolor={127,0,0},
                fillColor=30,
                rgbfillColor={235,235,235},
                fillPattern=1)),
            Text(
              extent=[-85,35; 65,-85],
              string="Library",
              style(color=42, rgbcolor={127,0,0})),
            Text(
              extent=[-120,122; 120,73],
              string="%name",
              style(color=1))));
        model CharacteristicDamper "Linear 1D translational spring"
          extends BondLib.Mechanical.Translational.Interfaces.OnePort;

          parameter Real damper_table[:,:] = [0,0; 1,1];

        protected
          BondLib.Mechanical.Translational.Interfaces.Tr2BG Tr2BG
            annotation (extent=[-70,-10; -50,10]);
          BondLib.Mechanical.Translational.Interfaces.BG2Tr BG2Tr
            annotation (extent=[50,-10; 70,10]);
          BondLib.Bonds.eBond B1
                          annotation (extent=[-30,30; -10,50]);
          BondLib.Bonds.fBond B2
                          annotation (extent=[10,30; 30,50]);
          BondLib.Junctions.J0p3 j0p3_1
                                 annotation (extent=[-10,30; 10,50]);
          BondLib.Sources.mSe Fx
            annotation (extent=[-10,-10; 10,10], rotation=-90);
          BondLib.Bonds.fBond B3
                          annotation (extent=[-10,10; 10,30], rotation=
                90);
          Modelica.Blocks.Math.Feedback A1
            annotation (extent=[-40,-70; -20,-50]);
        public
          Modelica.Blocks.Tables.CombiTable1Ds combiTable1Ds(table=damper_table)
            annotation (extent=[-10,-40; 10,-20], rotation=90);
          Modelica.Blocks.Continuous.Der der1
            annotation (extent=[-70,-40; -50,-20], rotation=270);
          Modelica.Blocks.Continuous.Der der2
            annotation (extent=[50,-40; 70,-20], rotation=270);
        equation
          connect(j0p3_1.BondCon1,B1. eBondCon1) annotation (points=[-10,40;
                -10,40],
                    style(color=8, rgbcolor={192,192,192}));
          connect(j0p3_1.BondCon2,B2. eBondCon1) annotation (points=[10,40; 10,
                40],
              style(color=8, rgbcolor={192,192,192}));
          connect(Tr2BG.BondCon1,B1. fBondCon1) annotation (points=[-50,0; -40,
                0; -40,40; -30,40], style(color=8, rgbcolor={192,192,192}));
          connect(BG2Tr.BondCon1,B2. fBondCon1) annotation (points=[50,0; 40,0;
                40,40; 30,40], style(color=8, rgbcolor={192,192,192}));
          connect(Fx.BondCon1,B3. eBondCon1) annotation (points=[-6.12303e-016,
                10; -6.12303e-016,10], style(color=8, rgbcolor={192,192,192}));
          connect(B3.fBondCon1,j0p3_1. BondCon3) annotation (points=[
                6.12303e-016,30; 0,30], style(color=8, rgbcolor={192,192,192}));
          annotation (
            Diagram,
            Icon(
              Text(extent=[0,110; 0,50],   string="%name"),
              Line(points=[-90,0; -60,0],   style(color=0)),
              Line(points=[-60,-30; -60,30],   style(color=0)),
              Line(points=[-60,-30; 60,-30],   style(color=0)),
              Line(points=[-60,30; 60,30],   style(color=0)),
              Rectangle(extent=[-60,30; 30,-30],   style(color=0, fillColor=8)),
              Line(points=[30,0; 90,0],   style(color=0)),
              Line(points=[-60,-90; 20,-90],   style(color=0, fillColor=10)),
              Polygon(points=[50,-90; 20,-80; 20,-100; 50,-90],     style(color=10,
                    fillColor=10)),
              Text(
                extent=[-60,-26; 60,-86],
                style(color=0, rgbcolor={0,0,0}),
                string="F = f(v)")),
            Documentation(info="<html>
Wrapped 1D linear translational spring model.
</html>"));
          connect(Tr2BG.Tr, flange_a) annotation (points=[-70.1,-0.1; -85.05,
                -0.1; -85.05,0; -100,0], style(color=58, rgbcolor={0,127,0}));
          connect(BG2Tr.Tr, flange_b) annotation (points=[69.9,-0.1; 82.95,-0.1;
                82.95,0; 99,0], style(color=58, rgbcolor={0,127,0}));
          connect(combiTable1Ds.y[1], Fx.s) annotation (points=[7.21645e-016,
                -19; 7.21645e-016,-15.5; 5.51073e-016,-15.5; 5.51073e-016,-9],
              style(color=74, rgbcolor={0,0,127}));
          connect(combiTable1Ds.u, A1.y) annotation (points=[-7.34764e-016,-42;
                0,-42; 0,-60; -21,-60], style(color=74, rgbcolor={0,0,127}));
          connect(der1.u, Tr2BG.s) annotation (points=[-60,-18; -60,-10], style(
                color=74, rgbcolor={0,0,127}));
          connect(der1.y, A1.u1) annotation (points=[-60,-41; -60,-60; -38,-60],
              style(color=74, rgbcolor={0,0,127}));
          connect(der2.u, BG2Tr.s) annotation (points=[60,-18; 60,-10], style(
                color=74, rgbcolor={0,0,127}));
          connect(der2.y, A1.u2) annotation (points=[60,-41; 60,-80; -30,-80;
                -30,-68], style(color=74, rgbcolor={0,0,127}));
        end CharacteristicDamper;
      end Utilities;
    end Parts;

    annotation (Documentation(info="<html>

<p>
<img src=\"../Images/advancedMotorcycle_logo1a.png\" width=\"258\" height=\"214\">
</p>

<p>
<img src=\"../Images/advancedMotorcycle_logo3.png\" width=\"319\" height=\"173\">
</p>

A detailed description of the models can be found in:
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.BicycleMotorcycleModeling.AdvancedMotorcycle\">UsersGuide.Overview.BicycleMotorcycleModeling.AdvancedMotorcycle</a>]</span>



</html>"), Icon(
        Rectangle(extent=[-100,-100; 80,50], style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Ellipse(extent=[-44,-88; -96,-36],style(color=0, rgbcolor={0,0,0})),
        Line(points=[-70,-62; -44,10; -38,10; -34,10], style(color=0,
              rgbcolor={0,0,0})),
        Line(points=[50,-62; 14,-62; -24,-62; -50,-8; -2,-14; 18,-30],style(
              color=0, rgbcolor={0,0,0})),
        Line(points=[18,-30; 64,-16],
                                    style(color=0, rgbcolor={0,0,0})),
        Ellipse(extent=[-66,-66; -74,-58], style(color=0, rgbcolor={0,0,0})),
        Ellipse(extent=[76,-88; 24,-36],  style(color=0, rgbcolor={0,0,0})),
        Ellipse(extent=[54,-66; 46,-58],   style(color=0, rgbcolor={0,0,0})),
        Line(points=[18,-30; 18,-62], style(color=0, rgbcolor={0,0,0})),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
              fillColor=30, fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
              fillColor=30, fillPattern=1)),
        Text(
          extent=[-120,125; 120,70],
          string="%name",
          style(color=3, rgbcolor={0,0,255})),
        Text(
          extent=[-90,40; 70,10],
          string="Library",
          style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=0,
            rgbfillColor={0,0,0},
            fillPattern=1))));
    package Aerodynamics
      "computes the lift and drag forces acting on the vehicle"
      model LiftForce "Drag force in y-direction"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        // equation: 0.5*rho*v^2*A*CL

        parameter Real CL = 0.488 "Lift force coefficient";
        parameter SI.Area fA = 1 "Frontal Area of the motorcycle";
        parameter Real rho = 1.227 "air density";

        // Animation
        parameter MB.Types.Color arrowColor = {0,0, 255} "|Visualisation|";
        parameter Real arrowDiameter = 0.02 "|Visualisation|";

        MotorcycleLib.Utilities.Arrow normalForce(
          each r=frame_a.P.x,
          each r_tail=zeros(3),
          each r_head={0,1,0}*const_values.y*v,
          each diameter=arrowDiameter,
          each color=arrowColor,
          each specularCoefficient=0,
          each R=MB.Frames.Orientation(T=frame_a.P.R, w=zeros(3)));
                               // - {0,1,0}*const_values.y*v/10,

        MultiBondLib.Mechanics3D.Forces.BodyForce LiftForce
          annotation (extent=[40,-10; 60,10]);
        annotation (Icon(
            Rectangle(extent=[-100,100; 100,-100], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=7,
                rgbfillColor={255,255,255})),
                         Text(
              extent=[-100,100; 100,40],
              style(color=3, rgbcolor={0,0,255}),
              string="%name"),
            Polygon(points=[0,50; -46,4; -26,4; -24,4; -24,-56; 24,-56; 24,4;
                  46,4; 0,50], style(
                color=74,
                rgbcolor={0,0,127},
                fillColor=70,
                rgbfillColor={45,96,172}))),   Diagram(
                  Text(
              extent=[-18,52; 14,38],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="y-direction")));
        MultiBondLib.Mechanics3D.Interfaces.Frame_a frame_a
          annotation (extent=[90,-20; 110,20]);
        Modelica.Blocks.Sources.Constant const_values(k=0.5*rho*CL*fA)
                       annotation (extent=[-90,36; -70,56]);
        Modelica.Blocks.Sources.Constant const[2](k={0,0})
          annotation (extent=[-90,-30; -70,-10]);
        Modelica.Blocks.Interfaces.RealInput v
          annotation (extent=[-140,-20; -100,20]);
        Modelica.Blocks.Math.Product product
          annotation (extent=[-50,30; -30,50]);
      equation
        connect(LiftForce.frame_b, frame_a) annotation (points=[61,0; 100,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(const[1].y, LiftForce.force[1]) annotation (points=[-69,-20; 20,
              -20; 20,-0.666667; 39.6,-0.666667], style(color=74, rgbcolor={0,0,
                127}));
        connect(const[2].y, LiftForce.force[3]) annotation (points=[-69,-20; 20,
              -20; 20,0.666667; 39.6,0.666667], style(color=74, rgbcolor={0,0,
                127}));
        connect(product.y, LiftForce.force[2]) annotation (points=[-29,40; 20,
              40; 20,5.55112e-017; 39.6,5.55112e-017], style(color=74, rgbcolor=
               {0,0,127}));
        connect(const_values.y, product.u1) annotation (points=[-69,46; -52,46],
            style(color=74, rgbcolor={0,0,127}));
        connect(v, product.u2) annotation (points=[-120,0; -60,0; -60,34; -52,
              34], style(color=74, rgbcolor={0,0,127}));
      end LiftForce;

      model DragForce "Drag force in x-direction"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        // equation: 0.5*rho*v^2*A*CD

        parameter Real CD = 0.488 "Drag force coefficient";
        parameter SI.Area fA = 1 "Frontal Area of the motorcycle";
        parameter Real rho = 1.227 "air density";

        // Animation
        parameter MB.Types.Color arrowColor = {0, 0, 255} "|Visualisation|";
        parameter Real arrowDiameter = 0.02 "|Visualisation|";

        MotorcycleLib.Utilities.Arrow normalForce(
          each r=frame_a.P.x,
          each r_tail=zeros(3),
          each r_head={1,0,0}*const_values.y*v,
          each diameter=arrowDiameter,
          each color=arrowColor,
          each specularCoefficient=0,
          each R=MB.Frames.Orientation(T=frame_a.P.R, w=zeros(3)));
                                //- {0,1,0}*const_values.y*v,

        MultiBondLib.Mechanics3D.Forces.BodyForce DragForce
          annotation (extent=[40,-10; 60,10]);
        annotation (Icon(
            Rectangle(extent=[-100,100; 100,-100], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=7,
                rgbfillColor={255,255,255})),
                         Text(
              extent=[-100,100; 100,40],
              style(color=3, rgbcolor={0,0,255}),
              string="%name"),
            Polygon(points=[58,0; 12,46; 12,24; -48,24; -48,-24; 12,-24; 12,-24;
                  12,-46; 58,0], style(
                color=74,
                rgbcolor={0,0,127},
                fillColor=70,
                rgbfillColor={45,96,172}))),   Diagram(
                  Text(
              extent=[-18,52; 14,38],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="x-direction")));
        MultiBondLib.Mechanics3D.Interfaces.Frame_a frame_a
          annotation (extent=[90,-20; 110,20]);
        Modelica.Blocks.Sources.Constant const[2](k={0,0})
          annotation (extent=[-90,-30; -70,-10]);
        Modelica.Blocks.Sources.Constant const_values(k=0.5*rho*CD*fA)
                       annotation (extent=[-90,36; -70,56]);
        Modelica.Blocks.Math.Product product
          annotation (extent=[-50,30; -30,50]);
        Modelica.Blocks.Interfaces.RealInput v
          annotation (extent=[-140,-20; -100,20]);
      equation
        connect(DragForce.frame_b, frame_a) annotation (points=[61,0; 100,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(const[1].y,DragForce. force[2]) annotation (points=[-69,-20; 20,
              -20; 20,5.55112e-017; 39.6,5.55112e-017], style(color=74,
              rgbcolor={0,0,127}));
        connect(const[2].y,DragForce. force[3]) annotation (points=[-69,-20; 20,
              -20; 20,0.666667; 39.6,0.666667], style(color=74, rgbcolor={0,0,
                127}));
        connect(const_values.y, product.u1) annotation (points=[-69,46; -52,46],
            style(color=74, rgbcolor={0,0,127}));
        connect(v, product.u2) annotation (points=[-120,0; -60,0; -60,34; -52,
              34], style(color=74, rgbcolor={0,0,127}));
        connect(product.y,DragForce. force[1]) annotation (points=[-29,40; 20,
              40; 20,-0.666667; 39.6,-0.666667], style(color=74, rgbcolor={0,0,
                127}));
      end DragForce;

      model PitchingMoment "Pitching moment about the z-axis"
        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        // equation: 0.5*rho*v^2*A*CP*w

        parameter Real CP = 0.488 "Pitching moment coefficient";
        parameter SI.Area fA = 1 "Frontal Area of the motorcycle";
        parameter Real rho = 1.227 "air density";
        parameter SI.Distance w = 1 "Wheelbase";

        MultiBondLib.Mechanics3D.Forces.BodyTorque PitchingMoment
          annotation (extent=[40,-10; 60,10]);
        annotation (Icon(
            Rectangle(extent=[-100,100; 100,-100], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=7,
                rgbfillColor={255,255,255})),
                         Text(
              extent=[-100,100; 100,40],
              style(color=3, rgbcolor={0,0,255}),
              string="%name"),
            Ellipse(extent=[-50,70; 50,-70], style(color=3, rgbcolor={0,0,255})),
            Line(points=[-56,14; -88,22], style(color=0, rgbcolor={0,0,0})),
            Rectangle(extent=[60,20; 40,-20], style(
                pattern=0,
                fillColor=7,
                rgbfillColor={255,255,255})),
            Polygon(points=[34,34; 48,14; 52,38; 34,34], style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=3,
                rgbfillColor={0,0,255},
                fillPattern=1)),
            Line(points=[0,0; 80,-20], style(color=0, rgbcolor={0,0,0}))),
                                               Diagram(
                  Text(
              extent=[-18,52; 14,38],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="z-direction")));

        MultiBondLib.Mechanics3D.Interfaces.Frame_a frame_a
          annotation (extent=[90,-20; 110,20]);
        Modelica.Blocks.Sources.Constant const[2](k={0,0})
          annotation (extent=[-90,-30; -70,-10]);
        Modelica.Blocks.Sources.Constant const_values(k=0.5*rho*CP*fA*w)
                       annotation (extent=[-90,36; -70,56]);
        Modelica.Blocks.Math.Product product
          annotation (extent=[-50,30; -30,50]);
        Modelica.Blocks.Interfaces.RealInput v
          annotation (extent=[-140,-20; -100,20]);
      equation
        connect(PitchingMoment.frame_b, frame_a)
                                            annotation (points=[61,0; 100,0],
            style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(const_values.y, product.u1) annotation (points=[-69,46; -52,46],
            style(color=74, rgbcolor={0,0,127}));
        connect(v, product.u2) annotation (points=[-120,0; -60,0; -60,34; -52,
              34], style(color=74, rgbcolor={0,0,127}));
        connect(const[1].y, PitchingMoment.torque[1]) annotation (points=[-69,-20;
              20,-20; 20,-0.666667; 39.6,-0.666667],      style(color=74,
              rgbcolor={0,0,127}));
        connect(const[2].y, PitchingMoment.torque[2]) annotation (points=[-69,-20;
              20,-20; 20,5.55112e-017; 39.6,5.55112e-017],      style(color=74,
              rgbcolor={0,0,127}));
        connect(product.y, PitchingMoment.torque[3]) annotation (points=[-29,40;
              20,40; 20,0.666667; 39.6,0.666667], style(color=74, rgbcolor={0,0,
                127}));
      end PitchingMoment;
    end Aerodynamics;

    package StabilityAnalysis
      annotation (Icon(
          Rectangle(extent=[-100,-100; 80,50], style(
              color=45,
              rgbcolor={255,128,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
              color=45,
              rgbcolor={255,128,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
              color=45,
              rgbcolor={255,128,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Text(
            extent=[-85,35; 65,-85],
            string="Library",
            style(color=45, rgbcolor={255,128,0})),
          Text(
            extent=[-120,122; 120,73],
            string="%name",
            style(color=45, rgbcolor={255,128,0}))));
      function CalculateEigenvaluesAdvancedMotorcycle
        "Stability analysis of an uncontrolled bicycle, plots eigenvalues as a function of bicycle's forward velocity"

        /* Remark:
     The main problem of the eigenvalue analysis functions are the velocity dependent
     eigenvalues of the system matrix A. As a consequence, the indices of
     the eigenvalues, which are stored in a vector, are changing as well. Thus, one has to
     sort the eigenvalues in a proper manner, which is cumbersome. Since the system matrix
     A of the basic bicycle and motorcycle models includes solely one conjugated complex
     pole pair, an algorithm capable of sorting the eigenvalues was feasible. However, the
     system matrix of the advanced motorcycle includes at least 5 conjugated complex pole
     pairs. Thus, it is much more complicated to provide an appropriate algorithm which
     ensures that the indices are not changing.
  */

        extends Modelica.Icons.Function;

        input String modelName;
        input String independentVariableName;
        input Real startValue "lowest velocity";
        input Real endValue "highest velocity";
        input Integer number_of_values;

        input Real states[15] = {1,2, 3,4, 5,6, 7,8, 11,12, 13,14, 15, 16, 18}
          "|State Selection (state vector)| execute getStates in order to determine the names of the state variables";

        input Integer plotSignals = 0
          "|Signals to plot| 0 ... real and imaginary eigenvalues; 1 ... real eigenvalues; 2 ... imaginary eigenvalues";

      protected
        Boolean hd = LinearSystems.Internal.SetHideDymosim();
        Boolean OK=linearizeModel(modelName);
        Real[number_of_values] values = linspace(startValue, endValue, number_of_values);
        Real nxMat[1, 1] = readMatrix("dslin.mat", "nx", 1, 1);
        Integer ABCDsizes[2] = readMatrixSize("dslin.mat", "ABCD");
        Integer nx = integer(nxMat[1, 1]);
        Integer nu = ABCDsizes[2] - nx;
        Integer ny = ABCDsizes[1] - nx;

        LinearSystems.StateSpace ABCD(
          nx = nx,
          ny = ny,
          nu = nu);

        /* Matrix which includes the relevant statevariables to compute the Eingenvalues
     Simulation window: type importInitial() then linearize the model and open the function "dslin.mat"
     type xuyName to get the selceted StateVariables */
        Real Arelevant[15,15];
        Real EigenValuesi[15, 2] = fill(0, 15, 2);
        Real EV_history[15,number_of_values] = fill(0, 15, number_of_values);
        Real EV_history_imag[15,number_of_values] = fill(0, 15, number_of_values);
        Real EV_real[15];
        Real EV_imag[15];
        Real EV_sort[15];
        Real EV_sort_imag[15];

        Integer n;
        Integer k;
        Integer m;

        String stateNames[nx];
        Integer window = 0;
        Boolean status = animationOnline(loadInterval=  0.05);

      algorithm
        // plot settings
        window := createPlot(id=  1,
                             position=   {2, 3, 750, 450},
                             y=   fill("", 0),
                             heading=  "Eigenvalue Analysis",
                             range=  {(0.0), 18.0, 6.0, (-30.0)},
                             autoscale=  false,
                             autoerase=  false,
                             autoreplot=  true,
                             description=  false,
                             grid=  true,
                             color=  true,
                             online=  false,
                             legendLocation=  5,
                             legendHorizontal=  false,
                             leftTitle=  "Real, Imaginary Eigenvalues",
                             bottomTitle=  "Velocity [m/s]");

        ABCD := LinearSystems.linearize(modelName);
        EV_sort :={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
        for i in 1:number_of_values loop
          SetVariable(independentVariableName, values[i]);
          OK := linearizeModel(modelName);
          if OK then
            ABCD := LinearSystems.readStateSpace("dslin.mat");
            stateNames := ABCD.xNames;

            /* Select the relevant states for the stability analysis
         here: Arelevant = {steer angle, steer rate, lean angle, lean rate, rider lean angle, rider lean rate} */
            Arelevant := (ABCD.A)[states, states];
            EigenValuesi := Modelica.Math.Matrices.eigenValues(Arelevant);
            // Eigenvalues are stored in two separate vectors
            EV_real := EigenValuesi[:, 1];
            EV_imag := EigenValuesi[:, 2];

            // control variables
            k := 0;
            m := 1;

            n :=size(EV_imag, 1);

            /* Remark:
           Since the function Modelica.Math.Matrices.eigenValues() orders the Eigenvalues not always in the same way it is
           necessary to re-order the Eigenvalues stored in the Eigenvalue-Vector.
         Algorithm:
           1. check wheter the eigenvalues include imaginary parts
             -> if an imaginary part appears, store the values in the last row of the vector EV_sort and EV_sort_imag
             -> else store the eigenvalues in ascending order
           2. sort the values in ascending order
             -> if all elements of EV_imag are zero sort all rows
             -> else (if imaginary parts appear) sort the first four rows and leave the remaining rows unchanged
       */

            // Part 1
            for j in 1:n loop
              if EV_imag[j] <> 0 then
                EV_sort[n-k] := EV_real[j];
                // build also a new vector which stores the imaginary values <> 0
                EV_sort_imag[n-k] := EV_imag[j];
                k := k+1;
                //p := i;
              else
                EV_sort[m] := EV_real[j];
                EV_sort_imag[m] := EV_imag[j];
                m := m+1;
              end if;
            end for;

            // Part 2
            if EV_imag[1] == 0 and EV_imag[2] == 0 and EV_imag[3] == 0 and EV_imag[4] == 0 and EV_imag[5] == 0 and  EV_imag[6] == 0 and
               EV_imag[7] == 0 and EV_imag[8] == 0 and EV_imag[9] == 0 and EV_imag[10] == 0 and EV_imag[11] == 0 and  EV_imag[12] == 0 and
               EV_imag[13] == 0 and EV_imag[14] == 0 and EV_imag[15] == 0 then
               EV_history[:, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort);
               EV_history_imag[6:15, i] := EV_sort_imag[6:15];
            else
              EV_history[1:5, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort[1:5]);
              EV_history[6:15, i] := EV_sort[6:15];
              EV_history_imag[6:15,i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort_imag[6:15]);
            end if;

          end if;
        end for;

         if plotSignals == 0 then
           // plot the real eigenvalues
           plotArrays(x= values[1:number_of_values],
                     y= transpose(EV_history[:,1:number_of_values]),
                     title= "Eigenvalue Analysis",
                     style= {0});
                     //legend= {"castering mode", "rider's mode", "capsize mode", "rider's mode", "Re(weave mode)", "Re(weave mode)"},

           // plot the imaginary eigenvalues
           plotArrays(x= values[1:number_of_values],
                     y= transpose(EV_history_imag[6:15,1:number_of_values]),
                     title= "Eigenvalue Analysis",
                     style= {1});
                     //legend= {"Im(weave mode)", "Im(weave mode)"},
          elseif plotSignals == 1 then
            plotArrays(x= values[1:number_of_values],
                     y= transpose(EV_history[:,1:number_of_values]),
                     title= "Eigenvalue Analysis",
                     style= {0});
                     //legend= {"castering mode", "rider's mode", "capsize mode", "rider's mode", "Re(weave mode)", "Re(weave mode)"},
          else
            plotArrays(x= values[1:number_of_values],
                     y= transpose(EV_history_imag[6:15,1:number_of_values]),
                     title= "Eigenvalue Analysis",
                     style= {1});
                     //legend= {"Im(weave mode)", "Im(weave mode)"},
          end if;

        writeMatrix("stability.mat","eigenvalues",[values,transpose(EV_history[:,:])]);
        Advanced.HideDymosim := hd;

      end CalculateEigenvaluesAdvancedMotorcycle;
    end StabilityAnalysis;

  end AdvancedMotorcycle;

  package ControllerDesign
    "Several pole placement functions based on Ackermann's Formula in order to design a state-space controller"

    package RigidRider

      function place
        "calculates the feedback matrix of a state space system w.r.t. pole placement"

        import Modelica_LinearSystems.Math.Complex;
        import Modelica.Utilities.Streams;
        import SI = Modelica.SIunits;
        extends Modelica.Icons.Function;

        input String modelName;
        input String independentVariableName = "vs";

        input SI.Velocity v = 10 "Forward velocity of the motorcycle";

        input Real d = 10
          "|Input for Controller Design| Offset in order to shift the poles";
        //input Real offset_imag = 0
        //  "|Inputs for Controller Design| Imaginary part of the offset";

        input Real states[4] = {3, 4, 11, 13}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

        output Real F[1, 4] "State Feedback Matrix";

      protected
        Complex offset = Complex(re=d, im=0);

        Boolean hd = LinearSystems.Internal.SetHideDymosim();
        Boolean OK=linearizeModel(modelName);
        Real nxMat[1, 1] = readMatrix("dslin.mat", "nx", 1, 1);        // number of columns
        Integer ABCDsizes[2] = readMatrixSize("dslin.mat", "ABCD");
        Integer nx = integer(nxMat[1, 1]);
        Integer nu = ABCDsizes[2] - nx;
        Integer ny = ABCDsizes[1] - nx;

        LinearSystems.StateSpace ABCD(
          nx = nx,
          ny = ny,
          nu = nu);

        Real Arel[4,4];
        Real Brel[4,1];
        Real con[4,4];
        Real eig[4, 2] = fill(0, 4, 2);      // each element has the value 0
        Real t[1,4];
        Complex p[1,4];
        Complex h[1,4];
        Complex c[1,5];
        Real c_real[1,5];

      algorithm
        ABCD := LinearSystems.linearize(modelName);
        SetVariable(independentVariableName, v);

        OK := linearizeModel(modelName);
        if OK then
          ABCD := LinearSystems.readStateSpace("dslin.mat");

          // state selection to calculate the relevant matrices
          //states := {4, 9, 7, 8};
          //states := {3,4,11,13};
          Arel := (ABCD.A)[states, states];
          Brel := (ABCD.B)[states,:];

          // compute the controlability matrix
          con := [Brel, Arel*Brel, Arel^2*Brel, Arel^3*Brel];

          // store the last row of con in t
          t := [0, 0, 0, 1]*Modelica.Math.Matrices.inv(con);
          //t := [0, 0, 0, 1]/con;
          // calculate eigenvalues of Arel
          eig := Modelica.Math.Matrices.eigenValues(Arel);

          eiga := Complex(re=  eig[1,1], im=  eig[1,2]);
          eigb := Complex(re=  eig[2,1], im=  eig[2,2]);
          eigc := Complex(re=  eig[3,1], im=  eig[3,2]);
          eigd := Complex(re=  eig[4,1], im=  eig[4,2]);
          eig2 := [eiga, eigb, eigc, eigd];
          eig4 := Complex(re=  eig[:,1], im=  eig[:,2]);

          // pole placement according to a user defined offset (store values in a complex eigenvector)
          pa := Complex.'-'(eiga,offset);
          pb := Complex.'-'(eigb,offset);
          pc := Complex.'-'(eigc,offset);
          pd := Complex.'-'(eigd,offset);
          p := [pa, pb, pc, pd];

          // the following complex numbers c1 ... c5 (stored in c) and h1 ... h4 (stored in h) are used
          // to calculte the coefficients of Arel
          c1 := Complex(re=1, im=0);
          c2 := Complex(re=0, im=0);
          c3 := Complex(re=0, im=0);
          c4 := Complex(re=0, im=0);
          c5 := Complex(re=0, im=0);
          c := [c1, c2, c3, c4, c5];

          h1 := Complex(re=0, im=0);
          h2 := Complex(re=0, im=0);
          h3 := Complex(re=0, im=0);
          h4 := Complex(re=0, im=0);
          h := [h1, h2, h3, h4];

          // calculate the coefficients of Arel
          for i in 1:4 loop
            if i == 1 then
              h1 := Complex.'*'(pa, c1);
              c2 := Complex.'-'(c2, h1);
            elseif i == 2 then
              h1 := Complex.'*'(pb, c1);
              h2 := Complex.'*'(pb, c2);
              c2 := Complex.'-'(c2, h1);
              c3 := Complex.'-'(c3, h2);
            elseif i == 3 then
              h1 := Complex.'*'(pc, c1);
              h2 := Complex.'*'(pc, c2);
              h3 := Complex.'*'(pc, c3);
              c2 := Complex.'-'(c2, h1);
              c3 := Complex.'-'(c3, h2);
              c4 := Complex.'-'(c4, h3);
            else
              h1 := Complex.'*'(pd, c1);
              h2 := Complex.'*'(pd, c2);
              h3 := Complex.'*'(pd, c3);
              h4 := Complex.'*'(pd, c4);
              c2 := Complex.'-'(c2, h1);
              c3 := Complex.'-'(c3, h2);
              c4 := Complex.'-'(c4, h3);
              c5 := Complex.'-'(c5, h4);
            end if;
            h := [h1, h2, h3, h4];
            c := [c1, c2, c3, c4, c5];
          end for;
        end if;
        // remove the imaginary part of the coefficient vector c
        c_real := [c1.re, c2.re, c3.re, c4.re, c5.re];

        // calculate the state feedback matrix F
        Modelica.Utilities.Streams.print(" ");
        Modelica.Utilities.Streams.print("State Feedback Matrix F");
        F := t*[c_real[1, 5]*identity(4) + c_real[1, 4]*Arel + c_real[1, 3]*Arel^2 + c_real[1, 2]*Arel^3 + Arel^4];

      end place;

      function placeRange_offset
        "calculates a set of feedback matrices for a user selected velocity range of a state space system w.r.t. pole placement"

        import Modelica_LinearSystems.Math.Complex;
        import Modelica.Utilities.Streams;
        import SI = Modelica.SIunits;
        extends Modelica.Icons.Function;

        input String modelName;
        input String independentVariableName = "vs";
        input Real startValue = 5;
        input Real endValue = 30;
        input Integer number_of_values = 25;

        input Real d = 10
          "|Input for Controller Design| Offset in order to shift the poles";

        input Real states[4] = {3, 4, 11, 13}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

        input String filename = "place.mat"
          "|Store Settings| Filename to store the feedback matrix";

        output Real F[1, 4] "State Feedback Matrix";

      protected
        Boolean hd = LinearSystems.Internal.SetHideDymosim();
        Real[number_of_values] values = linspace(startValue, endValue, number_of_values);
        Complex offset = Complex(re=d, im=0);

        Real EV_history[4,number_of_values] = fill(0, 4, number_of_values);
        Real EV_history_imag[4,number_of_values] = fill(0, 4, number_of_values);
        Real EV_real[4];
        Real EV_imag[4];
        Real EV_sort[4];
        Real EV_sort_imag[4];

        Integer n;
        Integer k;
        Integer m;

        Real nxMat[1, 1] = readMatrix("dslin.mat", "nx", 1, 1);        // number of columns
        Integer ABCDsizes[2] = readMatrixSize("dslin.mat", "ABCD");
        Integer nx = integer(nxMat[1, 1]);
        Integer nu = ABCDsizes[2] - nx;
        Integer ny = ABCDsizes[1] - nx;

        LinearSystems.StateSpace ABCD(
          nx = nx,
          ny = ny,
          nu = nu);

        Real Arel[4,4];
        Real Brel[4,1];
        Real F_table[number_of_values, 4] = fill(0, number_of_values, 4);
        Real con[4,4];
        Real eig[4, 2] = fill(0, 4, 2);      // each element has the value 0
        Real t[1,4];
        Complex p[1,4];
        Complex h[1,4];
        Complex c[1,5];
        Real c_real[1,5];

      algorithm
        ABCD := LinearSystems.linearize(modelName);

        for i in 1:number_of_values loop
          SetVariable(independentVariableName, values[i]);
          OK := linearizeModel(modelName);
          if OK then
            ABCD := LinearSystems.readStateSpace("dslin.mat");
            // state selection to calculate the relevant matrices
            //states := {4, 9, 7, 8};
            Arel := (ABCD.A)[states, states];
            Brel := (ABCD.B)[states,:];

            // compute the controlability matrix
            con := [Brel, Arel*Brel, Arel^2*Brel, Arel^3*Brel];

            // store the last row of con in t
            t := [0, 0, 0, 1]*Modelica.Math.Matrices.inv(con);

            // calculate eigenvalues of Arel
            eig := Modelica.Math.Matrices.eigenValues(Arel);
            eig_test :=eig;
            // Eigenvalues are stored in two separate vectors
            EV_real := eig[:, 1];
            EV_imag := eig[:, 2];

            // control variables
            k := 0;
            m := 1;

            n :=size(EV_imag, 1);
            /* Remark:
           Since the function Modelica.Math.Matrices.eigenValues() orders the Eigenvalues not always in the same way it is
           necessary to re-order the Eigenvalues stored in the Eigenvalue-Vector EigenValuesi.
         Algorithm:
           1. check whether the eigenvalues include imaginary parts
             -> if an imaginary part appears, store the values in the last row of the vector EV_sort and EV_sort_imag
             -> else store the eigenvalues in ascending order
           2. sort the values in ascending order
             -> if all elements of EV_imag are zero sort all rows
             -> else (if imaginary parts appear) sort the first four rows and leave the remaining rows unchanged
       */

            // Part 1
            for j in 1:n loop
              if EV_imag[j] <> 0 then
                EV_sort[n-k] := EV_real[j];
                // build also a new vector which stores the imaginary values <> 0
                EV_sort_imag[n-k] := EV_imag[j];
                k := k+1;
                //p := i;
              else
                EV_sort[m] := EV_real[j];
                EV_sort_imag[m] := EV_imag[j];
                m := m+1;
              end if;
            end for;

            // Part 2
            if EV_imag[1] == 0 and EV_imag[2] == 0 and EV_imag[3] == 0 and EV_imag[4] == 0 then
               EV_history[:, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort);
               EV_history_imag[3:4, i] := EV_sort_imag[3:4];
            else
              EV_history[1:2, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort[1:2]);
              EV_history[3:4, i] := EV_sort[3:4];
              EV_history_imag[3:4,i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort_imag[3:4]);
            end if;

            eiga := Complex(re=  EV_history[1,i], im=  EV_history_imag[1,i]);
            eigb := Complex(re=  EV_history[2,i], im=  EV_history_imag[2,i]);
            eigc := Complex(re=  EV_history[3,i], im=  EV_history_imag[3,i]);
            eigd := Complex(re=  EV_history[4,i], im=  EV_history_imag[4,i]);
            eig2 := [eiga, eigb, eigc, eigd];

            // store eigenvalues such that F has correct coefficients
            eig3 := [eiga, eigd, eigc, eigb];
            eiga_s := eiga;
            eigb_s := eigd;
            eigc_s := eigc;
            eigd_s := eigb;

            // pole placement according to a user defined offset (store values in a complex eigenvector)
            pa := Complex.'-'(eiga_s,offset);
            pb := Complex.'-'(eigb_s,offset);
            pc := Complex.'-'(eigc_s,offset);
            pd := Complex.'-'(eigd_s,offset);
            p := [pa, pb, pc, pd];

            // the following complex numbers c1 ... c5 (stored in c) and h1 ... h4 (stored in h) are used
            // to calculte the coefficients of Arel
            c1 := Complex(re=1, im=0);
            c2 := Complex(re=0, im=0);
            c3 := Complex(re=0, im=0);
            c4 := Complex(re=0, im=0);
            c5 := Complex(re=0, im=0);
            c := [c1, c2, c3, c4, c5];

            h1 := Complex(re=0, im=0);
            h2 := Complex(re=0, im=0);
            h3 := Complex(re=0, im=0);
            h4 := Complex(re=0, im=0);
            h := [h1, h2, h3, h4];

            // calculate the coefficients of Arel
            for i in 1:4 loop
              if i == 1 then
                h1 := Complex.'*'(pa, c1);
                c2 := Complex.'-'(c2, h1);
              elseif i == 2 then
                h1 := Complex.'*'(pb, c1);
                h2 := Complex.'*'(pb, c2);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
              elseif i == 3 then
                h1 := Complex.'*'(pc, c1);
                h2 := Complex.'*'(pc, c2);
                h3 := Complex.'*'(pc, c3);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
                c4 := Complex.'-'(c4, h3);
              else
                h1 := Complex.'*'(pd, c1);
                h2 := Complex.'*'(pd, c2);
                h3 := Complex.'*'(pd, c3);
                h4 := Complex.'*'(pd, c4);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
                c4 := Complex.'-'(c4, h3);
                c5 := Complex.'-'(c5, h4);
              end if;
              h := [h1, h2, h3, h4];
              c := [c1, c2, c3, c4, c5];
            end for;

            // remove the imaginary part of the coefficient vector c
            c_real := [c1.re, c2.re, c3.re, c4.re, c5.re];

            // calculate the state feedback matrix F
            F := t*[c_real[1, 5]*identity(4) + c_real[1, 4]*Arel + c_real[1, 3]*Arel^2 + c_real[1, 2]*Arel^3 + Arel^4];
            F_table[i, :] := F[1,:];
          end if;
        end for;

        // store the state feedback matrices in a table
        writeMatrix(filename,"Ftable",[values,F_table[:,:]]);
        // DataFiles.readMATmatrix("place.mat", "F_table");

      end placeRange_offset;

      function placeRange_individual_vw_vc
        "calculates a set of feedback matrices for a user selected velocity range of a state space system w.r.t. pole placement"

        import Modelica_LinearSystems.Math.Complex;
        import Modelica.Utilities.Streams;
        import SI = Modelica.SIunits;
        extends Modelica.Icons.Function;

        input String modelName;
        input String independentVariableName = "vs";
        input Real startValue = 5;
        input Real endValue = 30;
        input Integer number_of_values = 25;

        input Real vw = 6.1 "|Stable Region| weave velocity";
        input Real vc = 10.3 "|Stable Region| capsize velocity";

        input Real dw = 0.5
          "|Input for Controller Design| Offset in order to shift the weave poles";
        input Real dc = 0.2
          "|Input for Controller Design| Offset in order to shift the capsize pole";

        input Real states[4] = {5,6,1,2}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

        input String filename = "place.mat"
          "|Store Settings| Filename to store the feedback matrix";

        output Real F[1, 4] "State Feedback Matrix";

      protected
        Boolean hd = LinearSystems.Internal.SetHideDymosim();
        Real[number_of_values] values = linspace(startValue, endValue, number_of_values);

        Real d;
        Complex offset;
        Real EV_history[4,number_of_values] = fill(0, 4, number_of_values);
        Real EV_history_imag[4,number_of_values] = fill(0, 4, number_of_values);
        Real EV_real[4];
        Real EV_imag[4];
        Real EV_sort[4];
        Real EV_sort_imag[4];

        Integer n;
        Integer k;
        Integer m;

        Real nxMat[1, 1] = readMatrix("dslin.mat", "nx", 1, 1);        // number of columns
        Integer ABCDsizes[2] = readMatrixSize("dslin.mat", "ABCD");
        Integer nx = integer(nxMat[1, 1]);
        Integer nu = ABCDsizes[2] - nx;
        Integer ny = ABCDsizes[1] - nx;

        LinearSystems.StateSpace ABCD(
          nx = nx,
          ny = ny,
          nu = nu);

        Real Arel[4,4];
        Real Brel[4,1];
        Real F_table[number_of_values, 4] = fill(0, number_of_values, 4);
        Real et[number_of_values, 4] = fill(0, number_of_values, 4);
        Real con[4,4];
        Real eig[4, 2] = fill(0, 4, 2);      // each element has the value 0
        Real t[1,4];
        Complex p[1,4];
        Complex h[1,4];
        Complex c[1,5];
        Real c_real[1,5];

      algorithm
        ABCD := LinearSystems.linearize(modelName);

        for i in 1:number_of_values loop
          SetVariable(independentVariableName, values[i]);
          OK := linearizeModel(modelName);
          if OK then
            ABCD := LinearSystems.readStateSpace("dslin.mat");
            // state selection to calculate the relevant matrices
            Arel := (ABCD.A)[states, states];
            Brel := (ABCD.B)[states,:];

            // compute the controlability matrix
            con := [Brel, Arel*Brel, Arel^2*Brel, Arel^3*Brel];

            // store the last row of con in t
            t := [0, 0, 0, 1]*Modelica.Math.Matrices.inv(con);

            // calculate eigenvalues of Arel
            eig := Modelica.Math.Matrices.eigenValues(Arel);

            // Eigenvalues are stored in two separate vectors
            EV_real := eig[:, 1];
            EV_imag := eig[:, 2];

            // control variables
            k := 0;
            m := 1;

            n :=size(EV_imag, 1);
            /* Remark:
           Since the function Modelica.Math.Matrices.eigenValues() orders the Eigenvalues not always in the same way it is
           necessary to re-order the Eigenvalues stored in the Eigenvalue-Vector EigenValuesi.
         Algorithm:
           1. check whether the eigenvalues include imaginary parts
             -> if an imaginary part appears, store the values in the last row of the vector EV_sort and EV_sort_imag
             -> else store the eigenvalues in ascending order
           2. sort the values in ascending order
             -> if all elements of EV_imag are zero sort all rows
             -> else (if imaginary parts appear) sort the first four rows and leave the remaining rows unchanged
       */

            // Part 1
            for j in 1:n loop
              if EV_imag[j] <> 0 then
                EV_sort[n-k] := EV_real[j];
                // build also a new vector which stores the imaginary values <> 0
                EV_sort_imag[n-k] := EV_imag[j];
                k := k+1;
                //p := i;
              else
                EV_sort[m] := EV_real[j];
                EV_sort_imag[m] := EV_imag[j];
                m := m+1;
              end if;
            end for;

            // Part 2
            if EV_imag[1] == 0 and EV_imag[2] == 0 and EV_imag[3] == 0 and EV_imag[4] == 0 then
               EV_history[:, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort);
               EV_history_imag[3:4, i] := EV_sort_imag[3:4];
            else
              EV_history[1:2, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort[1:2]);
              EV_history[3:4, i] := EV_sort[3:4];
              EV_history_imag[3:4,i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort_imag[3:4]);
            end if;

            eiga := Complex(re=  EV_history[1,i], im=  EV_history_imag[1,i]);
            eigb := Complex(re=  EV_history[2,i], im=  EV_history_imag[2,i]);
            eigc := Complex(re=  EV_history[3,i], im=  EV_history_imag[3,i]);
            eigd := Complex(re=  EV_history[4,i], im=  EV_history_imag[4,i]);
            eig2 := [eiga, eigb, eigc, eigd];

            // store eigenvalues such that F has correct coefficients
            eig3 := [eiga, eigd, eigc, eigb];
            eiga_s := eiga;
            eigb_s := eigd;
            eigc_s := eigc;
            eigd_s := eigb;

            /* Controller Design Algorithm
         if velocity < vi
            apply an offset just to the weave poles
            --> offset = -dw*eigenvalue (weave eigenvalue)
         if velocity > vi
            apply an offset just to the capsize pole
         end if
      */

            if values[i] < vw then
              d := dw*(vw - values[i]);
              offset := Complex(re=d, im=0);
              pa := eiga_s;
              pb := Complex.'-'(eigb_s,offset);
              pc := Complex.'-'(eigc_s,offset);
              pd := eigd_s;
            elseif vc < values[i] then
              d := dc*(values[i] - vc);
              offset := Complex(re=d, im=0);
              pa := eiga_s;
              pb := eigb_s;
              pc := eigc_s;
              pd := Complex.'-'(eigd_s,offset);
            else
              pa := eiga_s;
              pb := eigb_s;
              pc := eigc_s;
              pd := eigd_s;
            end if;

            // the following complex numbers c1 ... c5 (stored in c) and h1 ... h4 (stored in h) are used
            // to calculte the coefficients of Arel
            c1 := Complex(re=1, im=0);
            c2 := Complex(re=0, im=0);
            c3 := Complex(re=0, im=0);
            c4 := Complex(re=0, im=0);
            c5 := Complex(re=0, im=0);
            c := [c1, c2, c3, c4, c5];

            h1 := Complex(re=0, im=0);
            h2 := Complex(re=0, im=0);
            h3 := Complex(re=0, im=0);
            h4 := Complex(re=0, im=0);
            h := [h1, h2, h3, h4];

            // calculate the coefficients of Arel
            for i in 1:4 loop
              if i == 1 then
                h1 := Complex.'*'(pa, c1);
                c2 := Complex.'-'(c2, h1);
              elseif i == 2 then
                h1 := Complex.'*'(pb, c1);
                h2 := Complex.'*'(pb, c2);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
              elseif i == 3 then
                h1 := Complex.'*'(pc, c1);
                h2 := Complex.'*'(pc, c2);
                h3 := Complex.'*'(pc, c3);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
                c4 := Complex.'-'(c4, h3);
              else
                h1 := Complex.'*'(pd, c1);
                h2 := Complex.'*'(pd, c2);
                h3 := Complex.'*'(pd, c3);
                h4 := Complex.'*'(pd, c4);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
                c4 := Complex.'-'(c4, h3);
                c5 := Complex.'-'(c5, h4);
              end if;
              h := [h1, h2, h3, h4];
              c := [c1, c2, c3, c4, c5];
            end for;

            // remove the imaginary part of the coefficient vector c
            c_real := [c1.re, c2.re, c3.re, c4.re, c5.re];

            // calculate the state feedback matrix F
            F := t*[c_real[1, 5]*identity(4) + c_real[1, 4]*Arel + c_real[1, 3]*Arel^2 + c_real[1, 2]*Arel^3 + Arel^4];
            F_table[i, :] := F[1,:];
            et[i,:] := eig[:,1];
          end if;
        end for;

        // store the eigenvalue matrix and the sorted eigenvalues matrix in tables
        writeMatrix("eig.mat", "et", [values, et[:,:]]);
        writeMatrix("eig_sort.mat", "et_sort", [values, transpose(EV_history[:,1:number_of_values])]);

        // store the state feedback matrices in a table
        writeMatrix(filename,"Ftable",[values,F_table[:,:]]);

      end placeRange_individual_vw_vc;

      function placeRange_individual_vi
        "calculates a set of feedback matrices for a user selected velocity range of a state space system w.r.t. pole placement"

        import Modelica_LinearSystems.Math.Complex;
        import Modelica.Utilities.Streams;
        import SI = Modelica.SIunits;
        extends Modelica.Icons.Function;

        input String modelName;
        input String independentVariableName = "vs";
        input Real startValue = 5;
        input Real endValue = 30;
        input Integer number_of_values = 25;

        input Real vi "|Stable Region| intersection velocity (weave/capsize)";

        input Real dw = 0.5
          "|Input for Controller Design| Offset in order to shift the weave poles";
        input Real dc = 0.2
          "|Input for Controller Design| Offset in order to shift the capsize pole";
        input Real d0 = 0
          "|Input for Controller Design| Offset in order to shift the weave poles and the capsize pole";

        input Real states[4] = {5,6,1,2}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

        input String filename = "place.mat"
          "|Store Settings| Filename to store the feedback matrix";

        output Real F[1, 4] "State Feedback Matrix";

      protected
        Boolean hd = LinearSystems.Internal.SetHideDymosim();
        Real[number_of_values] values = linspace(startValue, endValue, number_of_values);

        Real d;
        Complex offset;
        Complex offset2;
        Real EV_history[4,number_of_values] = fill(0, 4, number_of_values);
        Real EV_history_imag[4,number_of_values] = fill(0, 4, number_of_values);
        Real EV_real[4];
        Real EV_imag[4];
        Real EV_sort[4];
        Real EV_sort_imag[4];

        Integer n;
        Integer k;
        Integer m;

        Real nxMat[1, 1] = readMatrix("dslin.mat", "nx", 1, 1);        // number of columns
        Integer ABCDsizes[2] = readMatrixSize("dslin.mat", "ABCD");
        Integer nx = integer(nxMat[1, 1]);
        Integer nu = ABCDsizes[2] - nx;
        Integer ny = ABCDsizes[1] - nx;

        LinearSystems.StateSpace ABCD(
          nx = nx,
          ny = ny,
          nu = nu);

        Real Arel[4,4];
        Real Brel[4,1];
        Real F_table[number_of_values, 4] = fill(0, number_of_values, 4);
        Real et[number_of_values, 4] = fill(0, number_of_values, 4);
        Real con[4,4];
        Real eig[4, 2] = fill(0, 4, 2);      // each element has the value 0
        Real t[1,4];
        Complex p[1,4];
        Complex h[1,4];
        Complex c[1,5];
        Real c_real[1,5];

      algorithm
        ABCD := LinearSystems.linearize(modelName);

        for i in 1:number_of_values loop
          SetVariable(independentVariableName, values[i]);
          OK := linearizeModel(modelName);
          if OK then
            ABCD := LinearSystems.readStateSpace("dslin.mat");
            // state selection to calculate the relevant matrices
            Arel := (ABCD.A)[states, states];
            Brel := (ABCD.B)[states,:];

            // compute the controlability matrix
            con := [Brel, Arel*Brel, Arel^2*Brel, Arel^3*Brel];

            // store the last row of con in t
            t := [0, 0, 0, 1]*Modelica.Math.Matrices.inv(con);

            // calculate eigenvalues of Arel
            eig := Modelica.Math.Matrices.eigenValues(Arel);

            // Eigenvalues are stored in two separate vectors
            EV_real := eig[:, 1];
            EV_imag := eig[:, 2];

            // control variables
            k := 0;
            m := 1;

            n :=size(EV_imag, 1);
            /* Remark:
           Since the function Modelica.Math.Matrices.eigenValues() orders the Eigenvalues not always in the same way it is
           necessary to re-order the Eigenvalues stored in the Eigenvalue-Vector EigenValuesi.
         Algorithm:
           1. check whether the eigenvalues include imaginary parts
             -> if an imaginary part appears, store the values in the last row of the vector EV_sort and EV_sort_imag
             -> else store the eigenvalues in ascending order
           2. sort the values in ascending order
             -> if all elements of EV_imag are zero sort all rows
             -> else (if imaginary parts appear) sort the first four rows and leave the remaining rows unchanged
       */

            // Part 1
            for j in 1:n loop
              if EV_imag[j] <> 0 then
                EV_sort[n-k] := EV_real[j];
                // build also a new vector which stores the imaginary values <> 0
                EV_sort_imag[n-k] := EV_imag[j];
                k := k+1;
                //p := i;
              else
                EV_sort[m] := EV_real[j];
                EV_sort_imag[m] := EV_imag[j];
                m := m+1;
              end if;
            end for;

            // Part 2
            if EV_imag[1] == 0 and EV_imag[2] == 0 and EV_imag[3] == 0 and EV_imag[4] == 0 then
               EV_history[:, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort);
               EV_history_imag[3:4, i] := EV_sort_imag[3:4];
            else
              EV_history[1:2, i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort[1:2]);
              EV_history[3:4, i] := EV_sort[3:4];
              EV_history_imag[3:4,i] := Modelica_LinearSystems.Math.Vectors.sort(EV_sort_imag[3:4]);
            end if;

            eiga := Complex(re=  EV_history[1,i], im=  EV_history_imag[1,i]);
            eigb := Complex(re=  EV_history[2,i], im=  EV_history_imag[2,i]);
            eigc := Complex(re=  EV_history[3,i], im=  EV_history_imag[3,i]);
            eigd := Complex(re=  EV_history[4,i], im=  EV_history_imag[4,i]);
            eig2 := [eiga, eigb, eigc, eigd];

            // store eigenvalues such that F has correct coefficients
            eig3 := [eiga, eigd, eigc, eigb];
            eiga_s := eiga;
            eigb_s := eigd;
            eigc_s := eigc;
            eigd_s := eigb;

            /* Controller Design Algorithm
         if velocity < vi
            apply an offset just to the weave poles
            --> offset = -dw*eigenvalue (weave eigenvalue)
         if velocity > vi
            apply an offset just to the capsize pole
         end if
      */

            if values[i] <= vi then
              d := d0 + dw*(vi - values[i]);
              offset := Complex(re=d, im=0);
              offset2 := Complex(re=d0, im=0);
              pa := eiga_s;
              pb := Complex.'-'(eigb_s,offset);
              pc := Complex.'-'(eigc_s,offset);
              //pd := eigd_s;
              pd := Complex.'-'(eigd_s,offset2);
            else
              d := d0 + dc*(values[i] - vi);
              offset := Complex(re=d, im=0);
              offset2 := Complex(re=d0, im=0);
              pa := eiga_s;
              //pb := eigb_s + Complex(re=d0, im=0);
              //pc := eigc_s + Complex(re=d0, im=0);
              pb := Complex.'-'(eigb_s,offset2);
              pc := Complex.'-'(eigc_s,offset2);
              pd := Complex.'-'(eigd_s,offset);
            end if;

            // the following complex numbers c1 ... c5 (stored in c) and h1 ... h4 (stored in h) are used
            // to calculte the coefficients of Arel
            c1 := Complex(re=1, im=0);
            c2 := Complex(re=0, im=0);
            c3 := Complex(re=0, im=0);
            c4 := Complex(re=0, im=0);
            c5 := Complex(re=0, im=0);
            c := [c1, c2, c3, c4, c5];

            h1 := Complex(re=0, im=0);
            h2 := Complex(re=0, im=0);
            h3 := Complex(re=0, im=0);
            h4 := Complex(re=0, im=0);
            h := [h1, h2, h3, h4];

            // calculate the coefficients of Arel
            for i in 1:4 loop
              if i == 1 then
                h1 := Complex.'*'(pa, c1);
                c2 := Complex.'-'(c2, h1);
              elseif i == 2 then
                h1 := Complex.'*'(pb, c1);
                h2 := Complex.'*'(pb, c2);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
              elseif i == 3 then
                h1 := Complex.'*'(pc, c1);
                h2 := Complex.'*'(pc, c2);
                h3 := Complex.'*'(pc, c3);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
                c4 := Complex.'-'(c4, h3);
              else
                h1 := Complex.'*'(pd, c1);
                h2 := Complex.'*'(pd, c2);
                h3 := Complex.'*'(pd, c3);
                h4 := Complex.'*'(pd, c4);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
                c4 := Complex.'-'(c4, h3);
                c5 := Complex.'-'(c5, h4);
              end if;
              h := [h1, h2, h3, h4];
              c := [c1, c2, c3, c4, c5];
            end for;

            // remove the imaginary part of the coefficient vector c
            c_real := [c1.re, c2.re, c3.re, c4.re, c5.re];

            // calculate the state feedback matrix F
            F := t*[c_real[1, 5]*identity(4) + c_real[1, 4]*Arel + c_real[1, 3]*Arel^2 + c_real[1, 2]*Arel^3 + Arel^4];
            F_table[i, :] := F[1,:];
            et[i,:] := eig[:,1];
          end if;
        end for;

        // store the eigenvalue matrix and the sorted eigenvalues matrix in tables
        writeMatrix("eig.mat", "et", [values, et[:,:]]);
        writeMatrix("eig_sort.mat", "et_sort", [values, transpose(EV_history[:,1:number_of_values])]);

        // store the state feedback matrices in a table
        //writeMatrix("place.mat","Ftable",[values,F_table[:,:]]);
        writeMatrix(filename,"Ftable",[values,F_table[:,:]]);

      end placeRange_individual_vi;

      package PathPreview
        "pole placement function in order to design a virtual rider capable of tracking a pre-defined path"

        function place_pathPreview
          "calculates a set of feedback matrices for a user selected velocity range of a state space system w.r.t. pole placement"

          import Modelica_LinearSystems.Math.Complex;
          import Modelica.Utilities.Streams;
          import SI = Modelica.SIunits;
          extends Modelica.Icons.Function;

          input String modelName;
          input String independentVariableName = "vs";
          input SI.Velocity v = 10 "Forward velocity of the motorcycle";

          input Real d = 10
            "|Input for Controller Design| Offset in order to shift the poles";
          input Real d_lat = 10
            "|Input for Controller Design| Offset in order to shift the poles";

          input Real states[6] = {5, 6, 1, 2, 11, 10}
            "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle, xlat, der(xlat))";

          output Real F[1, 6] "State Feedback Matrix";

        protected
          Boolean hd = LinearSystems.Internal.SetHideDymosim();

          Complex offset = Complex(re=d, im=0);
          Complex offset_lateral = Complex(re=d_lat, im=0);

          Real EV_history[6,1] = fill(0, 6, 1);
          Real EV_history_imag[6,1] = fill(0, 6, 1);
          Real EV_real[6];
          Real EV_imag[6];
          Real EV_sort[6];
          Real EV_sort_imag[6];

          Integer n;
          Integer k;
          Integer m;

          Real nxMat[1, 1] = readMatrix("dslin.mat", "nx", 1, 1);        // number of columns
          Integer ABCDsizes[2] = readMatrixSize("dslin.mat", "ABCD");
          Integer nx = integer(nxMat[1, 1]);
          Integer nu = ABCDsizes[2] - nx;
          Integer ny = ABCDsizes[1] - nx;

          LinearSystems.StateSpace ABCD(
            nx = nx,
            ny = ny,
            nu = nu);

          Real Arel[6,6];
          Real Brel[6,1];
          Real F_table[1, 6] = fill(0, 1, 6);
          Real con[6,6];
          Real eig[6, 2] = fill(0, 6, 2);      // each element has the value 0
          Real t[1,6];
          Complex p[1,6];
          Complex h[1,6];
          Complex c[1,7];
          Real c_real[1,7];

        algorithm
          ABCD := LinearSystems.linearize(modelName);
          SetVariable(independentVariableName, v);

          OK := linearizeModel(modelName);
          if OK then
            ABCD := LinearSystems.readStateSpace("dslin.mat");

            Arel := (ABCD.A)[states, states];
            Brel := (ABCD.B)[states,:];

            // compute the controlability matrix
            con := [Brel, Arel*Brel, Arel^2*Brel, Arel^3*Brel, Arel^4*Brel, Arel^5*Brel];

            // store the last row of con in t
            t := [0, 0, 0, 0, 0, 1]*Modelica.Math.Matrices.inv(con);

            // calculate eigenvalues of Arel
            eig := Modelica.Math.Matrices.eigenValues(Arel);
            eig_unsort :=eig;

            // Eigenvalues are stored in two separate vectors
            EV_real := eig[:, 1];
            EV_imag := eig[:, 2];

            eiga := Complex(re=  EV_real[1], im=  EV_imag[1]);
            eigb := Complex(re=  EV_real[2], im=  EV_imag[2]);
            eigc := Complex(re=  EV_real[3], im=  EV_imag[3]);
            eigd := Complex(re=  EV_real[4], im=  EV_imag[4]);
            eige := Complex(re=  EV_real[5], im=  EV_imag[5]);
            eigf := Complex(re=  EV_real[6], im=  EV_imag[6]);
            eig2 := [eiga, eigb, eigc, eigd, eige, eigf];

            // pole placement according to a user defined offset (store values in a complex eigenvector)
            pa := Complex.'-'(eiga,offset_lateral);
            pb := Complex.'-'(eigb,offset_lateral);
            pc := Complex.'-'(eigc,offset);
            pd := Complex.'-'(eigd,offset);
            pe := Complex.'-'(eige,offset);
            pf := Complex.'-'(eigf,offset);

            p := [pa, pb, pc, pd, pe, pf];

            // the following complex numbers c1 ... c5 (stored in c) and h1 ... h4 (stored in h) are used
            // to calculte the coefficients of Arel
            c1 := Complex(re=1, im=0);
            c2 := Complex(re=0, im=0);
            c3 := Complex(re=0, im=0);
            c4 := Complex(re=0, im=0);
            c5 := Complex(re=0, im=0);
            c6 := Complex(re=0, im=0);
            c7 := Complex(re=0, im=0);
            c := [c1, c2, c3, c4, c5, c6, c7];

            h1 := Complex(re=0, im=0);
            h2 := Complex(re=0, im=0);
            h3 := Complex(re=0, im=0);
            h4 := Complex(re=0, im=0);
            h5 := Complex(re=0, im=0);
            h6 := Complex(re=0, im=0);
            h := [h1, h2, h3, h4, h5, h6];

            // calculate the coefficients of Arel
          for i in 1:6 loop
            if i == 1 then
              h1 := Complex.'*'(pa, c1);
              c2 := Complex.'-'(c2, h1);
            elseif i == 2 then
              h1 := Complex.'*'(pb, c1);
              h2 := Complex.'*'(pb, c2);
              c2 := Complex.'-'(c2, h1);
              c3 := Complex.'-'(c3, h2);
            elseif i == 3 then
              h1 := Complex.'*'(pc, c1);
              h2 := Complex.'*'(pc, c2);
              h3 := Complex.'*'(pc, c3);
              c2 := Complex.'-'(c2, h1);
              c3 := Complex.'-'(c3, h2);
              c4 := Complex.'-'(c4, h3);
            elseif i == 4 then
              h1 := Complex.'*'(pd, c1);
              h2 := Complex.'*'(pd, c2);
              h3 := Complex.'*'(pd, c3);
              h4 := Complex.'*'(pd, c4);
              c2 := Complex.'-'(c2, h1);
              c3 := Complex.'-'(c3, h2);
              c4 := Complex.'-'(c4, h3);
              c5 := Complex.'-'(c5, h4);
            elseif i == 5 then
              h1 := Complex.'*'(pe, c1);
              h2 := Complex.'*'(pe, c2);
              h3 := Complex.'*'(pe, c3);
              h4 := Complex.'*'(pe, c4);
              h5 := Complex.'*'(pe, c5);
              c2 := Complex.'-'(c2, h1);
              c3 := Complex.'-'(c3, h2);
              c4 := Complex.'-'(c4, h3);
              c5 := Complex.'-'(c5, h4);
              c6 := Complex.'-'(c6, h5);
            else
              h1 := Complex.'*'(pf, c1);
              h2 := Complex.'*'(pf, c2);
              h3 := Complex.'*'(pf, c3);
              h4 := Complex.'*'(pf, c4);
              h5 := Complex.'*'(pf, c5);
              h6 := Complex.'*'(pf, c6);
              c2 := Complex.'-'(c2, h1);
              c3 := Complex.'-'(c3, h2);
              c4 := Complex.'-'(c4, h3);
              c5 := Complex.'-'(c5, h4);
              c6 := Complex.'-'(c6, h5);
              c7 := Complex.'-'(c7, h6);
            end if;
            h := [h1, h2, h3, h4, h5, h6];
            c := [c1, c2, c3, c4, c5, c6, c7];
          end for;

            // remove the imaginary part of the coefficient vector c
            c_real := [c1.re, c2.re, c3.re, c4.re, c5.re, c6.re, c7.re];

            // calculate the state feedback matrix F
            Modelica.Utilities.Streams.print(" ");
            Modelica.Utilities.Streams.print("State Feedback Matrix F");
            F := t*[c_real[1, 7]*identity(6) + c_real[1, 6]*Arel + c_real[1, 5]*Arel^2 + c_real[1, 4]*Arel^3 + c_real[1, 3]*Arel^4 + c_real[1, 2]*Arel^5 + Arel^6];
          end if;

        end place_pathPreview;

        function placeRange_pathPreview
          "calculates a set of feedback matrices for a user selected velocity range of a state space system w.r.t. pole placement"

          import Modelica_LinearSystems.Math.Complex;
          import Modelica.Utilities.Streams;
          import SI = Modelica.SIunits;
          extends Modelica.Icons.Function;

          input String modelName;
          input String independentVariableName = "vs";
          input Real startValue = 5;
          input Real endValue = 30;
          input Integer number_of_values = 25;

          input Real d = 10
            "|Input for Controller Design| Offset in order to shift the poles";
          input Real d_lat = 10
            "|Input for Controller Design| Offset in order to shift the poles";

          input Real states[6] = {5, 6, 1, 2, 11, 10}
            "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle, xlat, der(xlat))";

          input String filename = "place.mat"
            "|Store Settings| Filename to store the feedback matrix";

          output Real F[1, 6] "State Feedback Matrix";

        protected
          Boolean hd = LinearSystems.Internal.SetHideDymosim();
          Real[number_of_values] values = linspace(startValue, endValue, number_of_values);
          Complex offset = Complex(re=d, im=0);
          Complex offset_lateral = Complex(re=d_lat, im=0);

          Real EV_history[6,number_of_values] = fill(0, 6, number_of_values);
          Real EV_history_imag[6,number_of_values] = fill(0, 6, number_of_values);
          Real EV_real[6];
          Real EV_imag[6];
          Real EV_sort[6];
          Real EV_sort_imag[6];

          Integer n;
          Integer k;
          Integer m;

          Real nxMat[1, 1] = readMatrix("dslin.mat", "nx", 1, 1);        // number of columns
          Integer ABCDsizes[2] = readMatrixSize("dslin.mat", "ABCD");
          Integer nx = integer(nxMat[1, 1]);
          Integer nu = ABCDsizes[2] - nx;
          Integer ny = ABCDsizes[1] - nx;

          LinearSystems.StateSpace ABCD(
            nx = nx,
            ny = ny,
            nu = nu);

          Real Arel[6,6];
          Real Brel[6,1];
          Real F_table[number_of_values, 6] = fill(0, number_of_values, 6);
          Real con[6,6];
          Real eig[6, 2] = fill(0, 6, 2);      // each element has the value 0
          Real t[1,6];
          Complex p[1,6];
          Complex h[1,6];
          Complex c[1,7];
          Real c_real[1,7];

        algorithm
          ABCD := LinearSystems.linearize(modelName);

          for i in 1:number_of_values loop
            SetVariable(independentVariableName, values[i]);
            OK := linearizeModel(modelName);
            if OK then
              ABCD := LinearSystems.readStateSpace("dslin.mat");

              Arel := (ABCD.A)[states, states];
              Brel := (ABCD.B)[states,:];

              // compute the controlability matrix
              con := [Brel, Arel*Brel, Arel^2*Brel, Arel^3*Brel, Arel^4*Brel, Arel^5*Brel];

              // store the last row of con in t
              t := [0, 0, 0, 0, 0, 1]*Modelica.Math.Matrices.inv(con);

              // calculate eigenvalues of Arel
              eig := Modelica.Math.Matrices.eigenValues(Arel);
              eig_unsort :=eig;
              //eig := Modelica_LinearSystems.Math.Matrices.sort(eig);
              //eig_test :=eig;

             // Eigenvalues are stored in two separate vectors
              EV_real := eig[:, 1];
              EV_imag := eig[:, 2];

              eiga := Complex(re=  EV_real[1], im=  EV_imag[1]);
              eigb := Complex(re=  EV_real[2], im=  EV_imag[2]);
              eigc := Complex(re=  EV_real[3], im=  EV_imag[3]);
              eigd := Complex(re=  EV_real[4], im=  EV_imag[4]);
              eige := Complex(re=  EV_real[5], im=  EV_imag[5]);
              eigf := Complex(re=  EV_real[6], im=  EV_imag[6]);
              eig2 := [eiga, eigb, eigc, eigd, eige, eigf];

              // pole placement according to a user defined offset (store values in a complex eigenvector)
              pa := Complex.'-'(eiga,offset_lateral);
              pb := Complex.'-'(eigb,offset_lateral);
              pc := Complex.'-'(eigc,offset);
              pd := Complex.'-'(eigd,offset);
              pe := Complex.'-'(eige,offset);
              pf := Complex.'-'(eigf,offset);

              p := [pa, pb, pc, pd, pe, pf];
              //p_mag := Complex

              // the following complex numbers c1 ... c5 (stored in c) and h1 ... h4 (stored in h) are used
              // to calculte the coefficients of Arel
              c1 := Complex(re=1, im=0);
              c2 := Complex(re=0, im=0);
              c3 := Complex(re=0, im=0);
              c4 := Complex(re=0, im=0);
              c5 := Complex(re=0, im=0);
              c6 := Complex(re=0, im=0);
              c7 := Complex(re=0, im=0);
              c := [c1, c2, c3, c4, c5, c6, c7];

              h1 := Complex(re=0, im=0);
              h2 := Complex(re=0, im=0);
              h3 := Complex(re=0, im=0);
              h4 := Complex(re=0, im=0);
              h5 := Complex(re=0, im=0);
              h6 := Complex(re=0, im=0);
              h := [h1, h2, h3, h4, h5, h6];

              // calculate the coefficients of Arel
            for i in 1:6 loop
              if i == 1 then
                h1 := Complex.'*'(pa, c1);
                c2 := Complex.'-'(c2, h1);
              elseif i == 2 then
                h1 := Complex.'*'(pb, c1);
                h2 := Complex.'*'(pb, c2);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
              elseif i == 3 then
                h1 := Complex.'*'(pc, c1);
                h2 := Complex.'*'(pc, c2);
                h3 := Complex.'*'(pc, c3);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
                c4 := Complex.'-'(c4, h3);
              elseif i == 4 then
                h1 := Complex.'*'(pd, c1);
                h2 := Complex.'*'(pd, c2);
                h3 := Complex.'*'(pd, c3);
                h4 := Complex.'*'(pd, c4);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
                c4 := Complex.'-'(c4, h3);
                c5 := Complex.'-'(c5, h4);
              elseif i == 5 then
                h1 := Complex.'*'(pe, c1);
                h2 := Complex.'*'(pe, c2);
                h3 := Complex.'*'(pe, c3);
                h4 := Complex.'*'(pe, c4);
                h5 := Complex.'*'(pe, c5);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
                c4 := Complex.'-'(c4, h3);
                c5 := Complex.'-'(c5, h4);
                c6 := Complex.'-'(c6, h5);
              else
                h1 := Complex.'*'(pf, c1);
                h2 := Complex.'*'(pf, c2);
                h3 := Complex.'*'(pf, c3);
                h4 := Complex.'*'(pf, c4);
                h5 := Complex.'*'(pf, c5);
                h6 := Complex.'*'(pf, c6);
                c2 := Complex.'-'(c2, h1);
                c3 := Complex.'-'(c3, h2);
                c4 := Complex.'-'(c4, h3);
                c5 := Complex.'-'(c5, h4);
                c6 := Complex.'-'(c6, h5);
                c7 := Complex.'-'(c7, h6);
              end if;
              h := [h1, h2, h3, h4, h5, h6];
              c := [c1, c2, c3, c4, c5, c6, c7];
            end for;

              // remove the imaginary part of the coefficient vector c
              c_real := [c1.re, c2.re, c3.re, c4.re, c5.re, c6.re, c7.re];

              // calculate the state feedback matrix F
              F := t*[c_real[1, 7]*identity(6) + c_real[1, 6]*Arel + c_real[1, 5]*Arel^2 + c_real[1, 4]*Arel^3 + c_real[1, 3]*Arel^4 + c_real[1, 2]*Arel^5 + Arel^6];
              F_table[i, :] := F[1,:];
            end if;
          end for;

          // store the state feedback matrices in a table
          writeMatrix(filename,"Ftable",[values,F_table[:,:]]);

        end placeRange_pathPreview;
      end PathPreview;

    end RigidRider;

    annotation (Icon(
        Rectangle(extent=[-100,-100; 80,50], style(
            color=45,
            rgbcolor={255,128,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
            color=45,
            rgbcolor={255,128,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
            color=45,
            rgbcolor={255,128,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Text(
          extent=[-85,35; 65,-85],
          string="Library",
          style(color=45, rgbcolor={255,128,0})),
        Text(
          extent=[-120,122; 120,73],
          string="%name",
          style(color=45, rgbcolor={255,128,0}))), Documentation(info="<html>

A detailed description of the models can be found in:
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.ControllerDesign.StateSpaceControllerDesign\">UsersGuide.Overview.ControllerDesign.StateSpaceControllerDesign</a>]</span>

</html>"));
  end ControllerDesign;

  package VirtualRider
    "Several virtual riders capable of tracking a roll angle profile or a pre-defined trajectory"
    package VirtualRigidRider
      package RollAngleTracking
        model Classic_VR "Classic PID stability controller"
          import Modelica.Blocks.Types.InitPID;
          import SI = Modelica.SIunits;

          parameter Real k=1 "Gain";
          parameter SI.Time Ti(min=Modelica.Constants.small) = 0.5
            "Time Constant of Integrator";
          parameter SI.Time Td(min=0) = 0.1 "Time Constant of Derivative block";
          parameter Real Nd(min=Modelica.Constants.small) = 10
            "The higher Nd, the more ideal the derivative block";
          parameter InitPID.Temp initType=Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState
            "Type of initialization"         annotation(Evaluate=true,
              Dialog(group="Initialization"));
          parameter Real xi_start=0
            "Initial or guess value value for integrator output (= integrator state)"
            annotation (Dialog(group="Initialization"));
          parameter Real xd_start=0
            "Initial or guess value for state of derivative block"
            annotation (Dialog(group="Initialization"));
          parameter Real y_start=0 "Initial value of output"
            annotation(Dialog(enable=initType == Init.InitialOutput, group=
                  "Initialization"));

          parameter Real Tmax = 20 "Maximum steering torque";

          Modelica.Blocks.Math.Feedback feedback
            annotation (extent=[-30,-10; -10,10]);
          Modelica.Blocks.Interfaces.RealInput phi_set "lean angle set point"
            annotation (extent=[-140,40; -100,80]);
          Modelica.Blocks.Interfaces.RealInput phi "lean angle"
            annotation (extent=[-140,-80; -100,-40],rotation=0);
          annotation (Diagram, Icon(
              Line(points=[-92,-80; 66,-80],
                                           style(color=8)),
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=51,
                  rgbfillColor={255,255,170})),
              Text(
                extent=[-100,-100; 98,-160],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-70,42; 70,-98], style(color=1, rgbcolor={255,0,0})),
              Rectangle(extent=[-88,2; 86,-98], style(
                  pattern=0,
                  fillColor=51,
                  rgbfillColor={255,255,170})),
              Ellipse(extent=[-14,86; 14,58], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[-20,18; -20,24; 20,24; 20,18], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Rectangle(extent=[-2,-8; 2,-88], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Polygon(points=[-68,-9; -68,5; -58,1; -68,-9], style(color=1,
                    rgbcolor={255,0,0})),
              Polygon(points=[68,-10; 58,0; 68,4; 68,-10], style(color=1,
                    rgbcolor={255,0,0})),
              Line(points=[0,58; 0,-88], style(color=0, rgbcolor={0,0,0}))),
            Coordsys(scale=0.15));
          Modelica.Blocks.Interfaces.RealOutput SteeringTorque
            annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Continuous.PID PID(
            k=k,
            Ti=Ti,
            Td=Td) annotation (extent=[10,-10; 30,10]);

          Modelica.Blocks.Nonlinear.Limiter limiter(uMax=Tmax)
            annotation (extent=[50,-10; 70,10],    rotation=0);
        initial equation
          if initType==InitPID.InitialOutput then
             SteeringTorque = y_start;
          end if;

        equation
          connect(phi, feedback.u2)
                                   annotation (points=[-120,-60; -20,-60; -20,-8],
                                                                      style(color=
                 74, rgbcolor={0,0,127}));
          connect(feedback.u1, phi_set) annotation (points=[-28,0; -60,0; -60,60;
                -120,60], style(color=74, rgbcolor={0,0,127}));
          connect(PID.u, feedback.y) annotation (points=[8,0; -11,0],  style(
                color=74, rgbcolor={0,0,127}));
          connect(limiter.u, PID.y) annotation (points=[48,0; 31,0], style(color=
                  74, rgbcolor={0,0,127}));
          connect(limiter.y, SteeringTorque) annotation (points=[71,0; 110,0],
              style(color=74, rgbcolor={0,0,127}));
        end Classic_VR;

        model Simple_StateSpace_VR
          "Lean angle and lean rate are fed back to generate a suitable steering torque"

          parameter Real F[1,2] = [53, 14] "state feedback matrix";

          Modelica.Blocks.Continuous.Der derivative1
            annotation (extent=[-8,-30; 12,-10],   rotation=0);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StateSpace_LeanController
            stateSpaceController(F=F)
                                 annotation (extent=[40,-10; 60,10]);
          Modelica.Blocks.Math.Feedback feedback
            annotation (extent=[-60,-4; -40,16]);
          Modelica.Blocks.Interfaces.RealInput phi_set "lean angle set point"
            annotation (extent=[-140,40; -100,80]);
          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Interfaces.RealInput phi "lean angle"
            annotation (extent=[-140,-80; -100,-40]);
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=76,
                  rgbfillColor={170,170,255})),
              Text(
                extent=[-100,-100; 98,-160],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-70,42; 70,-98], style(color=1, rgbcolor={255,0,0})),
              Rectangle(extent=[-98,2; 98,-98], style(
                  pattern=0,
                  fillColor=76,
                  rgbfillColor={170,170,255},
                  fillPattern=1)),
              Ellipse(extent=[-14,86; 14,58], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[-20,18; -20,24; 20,24; 20,18], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Rectangle(extent=[-2,-8; 2,-88], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Polygon(points=[-68,-9; -68,5; -58,1; -68,-9], style(color=1,
                    rgbcolor={255,0,0})),
              Polygon(points=[68,-10; 58,0; 68,4; 68,-10], style(color=1,
                    rgbcolor={255,0,0})),
              Line(points=[0,58; 0,-88], style(color=0, rgbcolor={0,0,0}))),
            Coordsys(scale=0.15));
        equation

          connect(feedback.u1, phi_set) annotation (points=[-58,6; -90,6; -90,60;
                -120,60],       style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController.SteeringTorque, T_steer) annotation (
              points=[61,0; 110,0],     style(color=74, rgbcolor={0,0,127}));
          connect(feedback.u2, phi) annotation (points=[-50,-2; -50,-60; -120,-60],
                      style(color=74, rgbcolor={0,0,127}));
          connect(derivative1.u, feedback.y) annotation (points=[-10,-20; -20,-20;
                -20,6; -41,6], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=51,
              rgbfillColor={255,255,170},
              fillPattern=1));
          connect(stateSpaceController.phi, feedback.y) annotation (points=[38,6;
                -41,6], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=51,
              rgbfillColor={255,255,170},
              fillPattern=1));
          connect(derivative1.y, stateSpaceController.der_phi) annotation (points=
               [13,-20; 20,-20; 20,-6; 38,-6], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=51,
              rgbfillColor={255,255,170},
              fillPattern=1));
        end Simple_StateSpace_VR;

        model StateSpace_VR
          "Virtual rider based on a preceding eigenvalue analysis; valid for a specific velocity"
          import SI = Modelica.SIunits;
          import CO = Modelica.SIunits.Conversions;
          import MA = Modelica.Math;

          parameter SI.Distance p = 1.414 "wheel base";

          parameter CO.NonSIunits.Angle_deg eps = 27
            "Caster angle (Steering head angle)";
          parameter Real F[1,4] = [2621.139060072288, 51.644789540803, 1394.263296471545, 111.065024150724]
            "|State Feedback Matrix| coefficients";
          Modelica.Blocks.Continuous.Der derivative
            annotation (extent=[0,-70; 20,-50],    rotation=0);
          Modelica.Blocks.Continuous.Der derivative1
            annotation (extent=[10,-17; 30,3],     rotation=0);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StateSpace_LeanSteer
            stateSpaceController(F=F)
                                 annotation (extent=[60,-20; 80,0]);
          Modelica.Blocks.Math.Feedback feedback_lean
            annotation (extent=[-60,-50; -40,-30]);
          Modelica.Blocks.Math.Feedback feedback_steer
            annotation (extent=[-30,56; -10,36],   rotation=0);
          Utilities.lean2steer lean2steer(       p=p, eps=eps)
                                        annotation (extent=[-60,36; -40,56]);
          Modelica.Blocks.Interfaces.RealInput v "velocity"
            annotation (extent=[-140,20; -100,60]);
          Modelica.Blocks.Interfaces.RealInput phi_set "lean angle set point"
            annotation (extent=[-140,-60; -100,-20]);
          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Interfaces.RealInput delta "steer angle "
            annotation (extent=[-140,60; -100,100]);
          Modelica.Blocks.Interfaces.RealInput phi "lean angle"
            annotation (extent=[-140,-100; -100,-60]);
        equation
          connect(derivative.u, feedback_lean.y)
                                            annotation (points=[-2,-60; -20,-60;
                -20,-40; -41,-40],       style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController.phi_lean, feedback_lean.y)
                                                             annotation (points=[58,-13;
                40,-13; 40,-40; -41,-40],
                                  style(color=74, rgbcolor={0,0,127}));
          connect(derivative.y,stateSpaceController. der_phi_lean) annotation (
              points=[21,-60; 48,-60; 48,-18; 58,-18],    style(color=74,
                rgbcolor={0,0,127}));
          connect(feedback_steer.y, stateSpaceController.phi_steer)
                                                               annotation (
              points=[-11,46; 48,46; 48,-2; 58,-2],     style(color=74,
                rgbcolor={0,0,127}));
          connect(derivative1.u, feedback_steer.y)
                                              annotation (points=[8,-7; 0,-7; 0,
                46; -11,46],            style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer, feedback_steer.u1)
                                                  annotation (points=[-39,46; -28,
                46],                                            style(color=74,
                rgbcolor={0,0,127}));
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=76,
                  rgbfillColor={170,170,255})),
              Text(
                extent=[-100,-100; 98,-160],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-70,42; 70,-98], style(color=1, rgbcolor={255,0,0})),
              Rectangle(extent=[-98,2; 98,-98], style(
                  pattern=0,
                  fillColor=76,
                  rgbfillColor={170,170,255},
                  fillPattern=1)),
              Ellipse(extent=[-14,86; 14,58], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[-20,18; -20,24; 20,24; 20,18], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Rectangle(extent=[-2,-8; 2,-88], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Polygon(points=[-68,-9; -68,5; -58,1; -68,-9], style(color=1,
                    rgbcolor={255,0,0})),
              Polygon(points=[68,-10; 58,0; 68,4; 68,-10], style(color=1,
                    rgbcolor={255,0,0})),
              Line(points=[0,58; 0,-88], style(color=0, rgbcolor={0,0,0}))),
            Coordsys(scale=0.15));
          connect(lean2steer.v, v) annotation (points=[-62,40; -120,40], style(
                color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u1, phi_set)
                                        annotation (points=[-58,-40; -120,-40],
                                style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.lean, phi_set) annotation (points=[-62,52; -80,52;
                -80,-40; -120,-40], style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController.SteeringTorque, T_steer) annotation (
              points=[81,-10; 90,-10; 90,0; 110,0],
                                        style(color=74, rgbcolor={0,0,127}));
          connect(feedback_steer.u2, delta)
                                       annotation (points=[-20,54; -20,80; -120,
                80], style(color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u2, phi)
                                    annotation (points=[-50,-48; -50,-80; -120,
                -80], style(color=74, rgbcolor={0,0,127}));
          connect(derivative1.y, stateSpaceController.der_phi_steer) annotation (
              points=[31,-7; 58,-7], style(color=74, rgbcolor={0,0,127}));

        end StateSpace_VR;

        model StateSpace_VR_Range
          "Virtual rider based on a preceding eigenvalue analysis; valid for a specific velocity range"

          import SI = Modelica.SIunits;
          import CO = Modelica.SIunits.Conversions;
          import MA = Modelica.Math;

          parameter SI.Distance p = 1.414 "wheel base";

          parameter CO.NonSIunits.Angle_deg eps = 27
            "Caster angle (Steering head angle)";

          parameter String filename = "place.mat"
            "|Store Settings| Filename to store the feedback matrix";

          Modelica.Blocks.Continuous.Der derivative
            annotation (extent=[10,-70; 30,-50],   rotation=0);
          Modelica.Blocks.Continuous.Der derivative1
            annotation (extent=[10,-4; 30,16],     rotation=0);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StabilityController_table
            stateSpaceController(filename=filename)
                                 annotation (extent=[60,-10; 80,10]);
          Modelica.Blocks.Math.Feedback feedback_lean
            annotation (extent=[-60,-50; -40,-30]);
          Modelica.Blocks.Math.Feedback feedback_steer
            annotation (extent=[-30,56; -10,36],   rotation=0);
          Utilities.lean2steer lean2steer(p=p, eps=eps)
                                        annotation (extent=[-60,36; -40,56]);
          Modelica.Blocks.Interfaces.RealInput v "velocity"
            annotation (extent=[-140,20; -100,60]);
          Modelica.Blocks.Interfaces.RealInput phi_set "lean angle set point"
            annotation (extent=[-140,-60; -100,-20]);
          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Interfaces.RealInput delta "steer angle "
            annotation (extent=[-140,60; -100,100]);
          Modelica.Blocks.Interfaces.RealInput phi "lean angle"
            annotation (extent=[-140,-100; -100,-60]);
        equation
          connect(derivative.u, feedback_lean.y)
                                            annotation (points=[8,-60; 0,-60; 0,
                -40; -41,-40],           style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController.phi_lean, feedback_lean.y)
                                                             annotation (points=[58,0; 40,
                0; 40,-40; -41,-40],
                                  style(color=74, rgbcolor={0,0,127}));
          connect(derivative.y,stateSpaceController. der_phi_lean) annotation (
              points=[31,-60; 48,-60; 48,-4; 58,-4],      style(color=74,
                rgbcolor={0,0,127}));
          connect(feedback_steer.y, stateSpaceController.phi_steer)
                                                               annotation (
              points=[-11,46; 40,46; 40,10; 58,10],     style(color=74,
                rgbcolor={0,0,127}));
          connect(derivative1.u, feedback_steer.y)
                                              annotation (points=[8,6; 0,6; 0,46;
                -11,46],                style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer, feedback_steer.u1)
                                                  annotation (points=[-39,46; -28,
                46],                                            style(color=74,
                rgbcolor={0,0,127}));
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=76,
                  rgbfillColor={170,170,255})),
              Text(
                extent=[-100,-100; 98,-160],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-70,42; 70,-98], style(color=1, rgbcolor={255,0,0})),
              Rectangle(extent=[-98,2; 98,-98], style(
                  pattern=0,
                  fillColor=76,
                  rgbfillColor={170,170,255},
                  fillPattern=1)),
              Ellipse(extent=[-14,86; 14,58], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[-20,18; -20,24; 20,24; 20,18], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Rectangle(extent=[-2,-8; 2,-88], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Polygon(points=[-68,-9; -68,5; -58,1; -68,-9], style(color=1,
                    rgbcolor={255,0,0})),
              Polygon(points=[68,-10; 58,0; 68,4; 68,-10], style(color=1,
                    rgbcolor={255,0,0})),
              Line(points=[0,58; 0,-88], style(color=0, rgbcolor={0,0,0}))),
            Coordsys(scale=0.15));
          connect(lean2steer.v, v) annotation (points=[-62,40; -120,40], style(
                color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u1, phi_set)
                                        annotation (points=[-58,-40; -120,-40],
                                style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.lean, phi_set) annotation (points=[-62,52; -86,52;
                -86,-40; -120,-40], style(color=74, rgbcolor={0,0,127}));
          connect(feedback_steer.u2, delta)
                                       annotation (points=[-20,54; -20,80; -120,
                80], style(color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u2, phi)
                                    annotation (points=[-50,-48; -50,-80; -120,
                -80], style(color=74, rgbcolor={0,0,127}));
          connect(derivative1.y, stateSpaceController.der_phi_steer) annotation (
              points=[31,6; 58,6],   style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController.v, v) annotation (points=[58,-10; -74,-10;
                -74,40; -120,40], style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController.T_steering, T_steer) annotation (points=[81,0;
                110,0],                       style(color=74, rgbcolor={0,0,127}));

        end StateSpace_VR_Range;

        model LQR_VR "A virtual rider based on a linear quadratic regulator"

          import SI = Modelica.SIunits;
          import CO = Modelica.SIunits.Conversions;
          import MA = Modelica.Math;

          parameter SI.Distance p = 1.414 "wheel base";

          parameter CO.NonSIunits.Angle_deg eps = 27
            "Caster angle (Steering head angle)";

          parameter Real F[1,4] = [2621.139060072288, 51.644789540803, 1394.263296471545, 111.065024150724]
            "state feedback matrix";
          Modelica.Blocks.Continuous.Der derivative
            annotation (extent=[0,-70; 20,-50],    rotation=0);
          Modelica.Blocks.Continuous.Der derivative1
            annotation (extent=[10,-17; 30,3],     rotation=0);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.LQR_LeanSteer
            LQR_VR(F=F)          annotation (extent=[60,-20; 80,0]);
          Modelica.Blocks.Math.Feedback feedback_lean
            annotation (extent=[-60,-50; -40,-30]);
          Modelica.Blocks.Math.Feedback feedback_steer
            annotation (extent=[-30,56; -10,36],   rotation=0);
          MotorcycleLib.VirtualRider.Utilities.lean2steer lean2steer(p=p, eps=
                eps)                    annotation (extent=[-60,36; -40,56]);
          Modelica.Blocks.Interfaces.RealInput v "velocity"
            annotation (extent=[-140,20; -100,60]);
          Modelica.Blocks.Interfaces.RealInput phi_set "lean angle set point"
            annotation (extent=[-140,-60; -100,-20]);
          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Interfaces.RealInput delta "steer angle "
            annotation (extent=[-140,60; -100,100]);
          Modelica.Blocks.Interfaces.RealInput phi "lean angle"
            annotation (extent=[-140,-100; -100,-60]);
        equation
          connect(derivative.u, feedback_lean.y)
                                            annotation (points=[-2,-60; -20,-60;
                -20,-40; -41,-40],       style(color=74, rgbcolor={0,0,127}));
          connect(LQR_VR.phi_lean, feedback_lean.y)          annotation (points=[58,-13;
                40,-13; 40,-40; -41,-40],
                                  style(color=74, rgbcolor={0,0,127}));
          connect(derivative.y, LQR_VR.der_phi_lean)               annotation (
              points=[21,-60; 48,-60; 48,-18; 58,-18],    style(color=74,
                rgbcolor={0,0,127}));
          connect(feedback_steer.y, LQR_VR.phi_steer)          annotation (
              points=[-11,46; 48,46; 48,-2; 58,-2],     style(color=74,
                rgbcolor={0,0,127}));
          connect(derivative1.u, feedback_steer.y)
                                              annotation (points=[8,-7; 0,-7; 0,
                46; -11,46],            style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer, feedback_steer.u1)
                                                  annotation (points=[-39,46; -28,
                46],                                            style(color=74,
                rgbcolor={0,0,127}));
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=68,
                  rgbfillColor={170,213,255})),
              Text(
                extent=[-100,-100; 98,-160],
                style(color=3, rgbcolor={0,0,255}),
                string="%name"),
              Ellipse(extent=[-70,42; 70,-98], style(color=1, rgbcolor={255,0,0})),
              Rectangle(extent=[-98,2; 98,-98], style(
                  pattern=0,
                  fillColor=68,
                  rgbfillColor={170,213,255})),
              Ellipse(extent=[-14,86; 14,58], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[-20,18; -20,24; 20,24; 20,18], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Rectangle(extent=[-2,-8; 2,-88], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Polygon(points=[-68,-9; -68,5; -58,1; -68,-9], style(color=1,
                    rgbcolor={255,0,0})),
              Polygon(points=[68,-10; 58,0; 68,4; 68,-10], style(color=1,
                    rgbcolor={255,0,0})),
              Line(points=[0,58; 0,-88], style(color=0, rgbcolor={0,0,0}))),
            Coordsys(scale=0.15));
          connect(lean2steer.v, v) annotation (points=[-62,40; -120,40], style(
                color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u1, phi_set)
                                        annotation (points=[-58,-40; -120,-40],
                                style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.lean, phi_set) annotation (points=[-62,52; -80,52;
                -80,-40; -120,-40], style(color=74, rgbcolor={0,0,127}));
          connect(LQR_VR.SteeringTorque, T_steer)               annotation (
              points=[81,-10; 90,-10; 90,0; 110,0],
                                        style(color=74, rgbcolor={0,0,127}));
          connect(feedback_steer.u2, delta)
                                       annotation (points=[-20,54; -20,80; -120,
                80], style(color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u2, phi)
                                    annotation (points=[-50,-48; -50,-80; -120,
                -80], style(color=74, rgbcolor={0,0,127}));
          connect(derivative1.y, LQR_VR.der_phi_steer)               annotation (
              points=[31,-7; 58,-7], style(color=74, rgbcolor={0,0,127}));

        end LQR_VR;

        package StabilityControl
          "several stability controller using lean angle and lean rate or lean angle, lean rate and steer angle, steer rate as inputs"
          model StateSpace_LeanController
            "State Space Controller including lean angle and lean rate as states"

            // The controller matrix is calculated with Matlab
            parameter Real F[1,2] = [53, 14];

            Modelica.Blocks.Interfaces.RealInput der_phi
              "derivative of lean angle"
              annotation (extent=[-140,-80; -100,-40]);
            Modelica.Blocks.Interfaces.RealOutput SteeringTorque
              annotation (extent=[100,-10; 120,10]);
            annotation (Diagram, DymolaStoredErrors,
              Icon(
                Rectangle(extent=[-100,100; 100,-100], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255})),
                Text(extent=[-90,10; -10,90],   string="A",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[0,-90; 0,90],   style(color=8)),
                Text(extent=[10,10; 90,90],   string="B",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[-90,-10; -10,-90],   string="C",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[10,-10; 90,-90],   string="D",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[-90,0; 90,0],   style(color=8)),
                Text(
                  extent=[-100,100; 100,-100],
                  string="F",
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1)),
                Text(
                  extent=[-100,-100; 100,-140],
                  style(
                    color=3,
                    rgbcolor={0,0,255},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1),
                  string="Lean Controller"),
                Text(
                  extent=[-100,140; 100,100],
                  style(
                    color=3,
                    rgbcolor={0,0,255},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1),
                  string="%name")));

            Modelica.Blocks.Interfaces.RealInput phi "lean angle"
              annotation (extent=[-140,40; -100,80]);
          equation
            // T = F*X
            // T ... Torque input
            // F ... Feedback matrix
            // X ... State vector

            {SteeringTorque} = F*{phi, der_phi};

          end StateSpace_LeanController;

          model StateSpace_LeanSteer
            "State Space Controller including lean angle, steer angle and their derivatives as states"

            /* The controller matrix is calculated with the place function
     ControllerDesign.place */
            parameter Real F[1,4] = [293.410352172553, 22.8306544389639, 436.517591182219, 104.848565320498];

            Modelica.Blocks.Interfaces.RealInput phi_lean "lean angle"
              annotation (extent=[-140,-50; -100,-10]);
            Modelica.Blocks.Interfaces.RealInput der_phi_steer "steer rate"
              annotation (extent=[-140,10; -100,50]);
            Modelica.Blocks.Interfaces.RealOutput SteeringTorque
              annotation (extent=[100,-10; 120,10]);
            annotation (Diagram, DymolaStoredErrors,
              Icon(
                Rectangle(extent=[-100,100; 100,-100], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255})),
                Text(extent=[-90,10; -10,90],   string="A",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[0,-90; 0,90],   style(color=8)),
                Text(extent=[10,10; 90,90],   string="B",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[-90,-10; -10,-90],   string="C",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[10,-10; 90,-90],   string="D",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[-90,0; 90,0],   style(color=8)),
                Text(
                  extent=[-100,100; 100,-100],
                  string="F",
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1)),
                Text(
                  extent=[-98,-102; 102,-142],
                  style(
                    color=3,
                    rgbcolor={0,0,255},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1),
                  string="LeanSteer Controller"),
                Text(
                  extent=[-100,140; 100,100],
                  style(
                    color=3,
                    rgbcolor={0,0,255},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1),
                  string="%name")));

            Modelica.Blocks.Interfaces.RealInput phi_steer "steer angle"
              annotation (extent=[-140,60; -100,100]);
            Modelica.Blocks.Interfaces.RealInput der_phi_lean "lean rate"
              annotation (extent=[-140,-100; -100,-60]);
          equation
            // T = F*X
            // T ... Torque input
            // F ... Feedback matrix
            // X ... State vector

            {SteeringTorque} = F*{phi_steer, der_phi_steer, phi_lean, der_phi_lean};

          end StateSpace_LeanSteer;

          model StabilityController_table
            "Full State Feedback Controller with several different feedback matrices depending on the actual velocity"

          parameter String filename = "place.mat"
              "|Store Settings| Filename to store the feedback matrix";

            Modelica.Blocks.Interfaces.RealInput phi_steer "steer angle"
              annotation (extent=[-140,80; -100,120]);
            Modelica.Blocks.Interfaces.RealInput der_phi_steer "steer rate"
              annotation (extent=[-140,40; -100,80]);
            Modelica.Blocks.Interfaces.RealInput phi_lean "lean angle"
              annotation (extent=[-140,-20; -100,20]);
            Modelica.Blocks.Interfaces.RealInput der_phi_lean "lean rate"
              annotation (extent=[-140,-60; -100,-20]);
            annotation (
              Diagram,
              Icon(
                Rectangle(extent=[-100,100; 100,-100], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1)),
                Line(points=[64,70; 44,70; 44,-70; 64,-70], style(color=0, rgbcolor=
                       {0,0,0})),
                Line(points=[74,70; 94,70; 94,-70; 74,-70], style(color=0, rgbcolor=
                       {0,0,0})),
                Line(points=[-76,30; -96,30; -96,-30; -76,-30], style(color=0,
                      rgbcolor={0,0,0})),
                Line(points=[-2,30; 18,30; 18,-30; -2,-30], style(color=0, rgbcolor=
                       {0,0,0})),
                Ellipse(extent=[25,6; 37,-6], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=0,
                    rgbfillColor={0,0,0})),
                Text(
                  extent=[11,-42; -89,42],
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=0,
                    rgbfillColor={0,0,0},
                    fillPattern=1),
                  string="F=f(v)"),
                Text(
                  extent=[109,-44; 29,36],
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=0,
                    rgbfillColor={0,0,0},
                    fillPattern=1),
                  string="X"),
                Line(points=[-100,-100; -12,-100; -12,-16; -18,-32; -6,-32; -12,-16],
                    style(
                    color=10,
                    rgbcolor={95,95,95},
                    pattern=2,
                    fillColor=1,
                    rgbfillColor={255,0,0},
                    fillPattern=1)),
                Text(
                  extent=[-98,-102; 102,-142],
                  style(
                    color=3,
                    rgbcolor={0,0,255},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1),
                  string="%name")),
              Coordsys(scale=0.15));
            Modelica.Blocks.Interfaces.RealInput v "velocity of the vehicle"
              annotation (extent=[-140,-120; -100,-80]);
            Modelica.Blocks.Math.Product product annotation (extent=[0,64; 20,84]);
            Modelica.Blocks.Math.Product product1 annotation (extent=[0,24; 20,44]);
            Modelica.Blocks.Math.Product product2 annotation (extent=[0,-16; 20,4]);
            Modelica.Blocks.Math.Product product3
              annotation (extent=[0,-56; 20,-36]);
            Modelica.Blocks.Math.Add add annotation (extent=[34,44; 54,64]);
            Modelica.Blocks.Math.Add add1 annotation (extent=[34,-36; 54,-16]);
            Modelica.Blocks.Math.Add add2 annotation (extent=[68,-10; 88,10]);
            Modelica.Blocks.Interfaces.RealOutput T_steering
              annotation (extent=[100,-10; 120,10]);
            Modelica.Blocks.Tables.CombiTable1Ds combiTable1Ds(
              tableOnFile=true,
              tableName="Ftable",
              columns=2:5,
              fileName=filename)
                           annotation (extent=[-60,-80; -40,-60]);
          equation
            connect(phi_steer, product.u1) annotation (points=[-120,100; -72,100;
                  -72,80; -2,80], style(color=74, rgbcolor={0,0,127}));
            connect(der_phi_steer, product1.u1) annotation (points=[-120,60; -72,60;
                  -72,40; -2,40], style(color=74, rgbcolor={0,0,127}));
            connect(phi_lean, product2.u1) annotation (points=[-120,0; -2,0],
                              style(color=74, rgbcolor={0,0,127}));
            connect(der_phi_lean, product3.u1) annotation (points=[-120,-40; -2,-40],
                                         style(color=74, rgbcolor={0,0,127}));
            connect(add.u1, product.y) annotation (points=[32,60; 26,60; 26,74; 21,
                  74], style(color=74, rgbcolor={0,0,127}));
            connect(product1.y, add.u2) annotation (points=[21,34; 26,34; 26,48; 32,
                  48],                                                     style(
                  color=74, rgbcolor={0,0,127}));
            connect(product2.y, add1.u1) annotation (points=[21,-6; 26,-6; 26,-20;
                  32,-20],                                                  style(
                  color=74, rgbcolor={0,0,127}));
            connect(product3.y, add1.u2) annotation (points=[21,-46; 26,-46; 26,-32;
                  32,-32],style(color=74, rgbcolor={0,0,127}));
            connect(add2.u1, add.y) annotation (points=[66,6; 60,6; 60,54; 55,54],
                style(color=74, rgbcolor={0,0,127}));
            connect(add2.u2, add1.y) annotation (points=[66,-6; 60,-6; 60,-26; 55,
                  -26],
                style(color=74, rgbcolor={0,0,127}));
            connect(add2.y, T_steering) annotation (points=[89,0; 110,0],
                          style(color=74, rgbcolor={0,0,127}));
            connect(T_steering, T_steering) annotation (points=[110,0; 110,0],
                style(
                color=74,
                rgbcolor={0,0,127},
                fillPattern=1));
            connect(v, combiTable1Ds.u) annotation (points=[-120,-100; -80,-100;
                  -80,-70; -62,-70], style(color=74, rgbcolor={0,0,127}));
            connect(combiTable1Ds.y[4], product3.u2) annotation (points=[-39,-70;
                  -20,-70; -20,-52; -2,-52], style(color=74, rgbcolor={0,0,127}));
            connect(combiTable1Ds.y[3], product2.u2) annotation (points=[-39,-70;
                  -20,-70; -20,-12; -2,-12], style(color=74, rgbcolor={0,0,127}));
            connect(combiTable1Ds.y[2], product1.u2) annotation (points=[-39,-70;
                  -20,-70; -20,28; -2,28], style(color=74, rgbcolor={0,0,127}));
            connect(combiTable1Ds.y[1], product.u2) annotation (points=[-39,-70;
                  -20,-70; -20,68; -2,68], style(color=74, rgbcolor={0,0,127}));
          end StabilityController_table;

          model LQR_LeanSteer
            "LQR including lean angle, steer angle and their derivatives as states"

            // The calculation of the feedback matrix coefficients is done with MATLAB
            parameter Real F[1,4] = [9.5166, 1.9268, 150.4986, 48.1777];

            Modelica.Blocks.Interfaces.RealInput phi_lean "lean angle"
              annotation (extent=[-140,-50; -100,-10]);
            Modelica.Blocks.Interfaces.RealInput der_phi_steer "steer rate"
              annotation (extent=[-140,10; -100,50]);
            Modelica.Blocks.Interfaces.RealOutput SteeringTorque
              annotation (extent=[100,-10; 120,10]);
            annotation (Diagram, DymolaStoredErrors,
              Icon(
                Rectangle(extent=[-100,100; 100,-100], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255})),
                Text(extent=[-90,10; -10,90],   string="A",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[0,-90; 0,90],   style(color=8)),
                Text(extent=[10,10; 90,90],   string="B",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[-90,-10; -10,-90],   string="C",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[10,-10; 90,-90],   string="D",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[-90,0; 90,0],   style(color=8)),
                Text(
                  extent=[-100,100; 100,-100],
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1),
                  string="LQR"),
                Text(
                  extent=[-100,-100; 100,-140],
                  style(
                    color=3,
                    rgbcolor={0,0,255},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1),
                  string="%name")));

            Modelica.Blocks.Interfaces.RealInput phi_steer "steer angle"
              annotation (extent=[-140,60; -100,100]);
            Modelica.Blocks.Interfaces.RealInput der_phi_lean "lean rate"
              annotation (extent=[-140,-100; -100,-60]);
          equation
            // T = F*X
            // T ... Torque input
            // F ... Feedback matrix
            // X ... State vector

            {SteeringTorque} = F*{phi_steer, der_phi_steer, phi_lean, der_phi_lean};

          end LQR_LeanSteer;
          annotation (Icon(
              Rectangle(extent=[-100,-100; 80,50], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Text(
                extent=[-85,35; 65,-85],
                string="Library",
                style(color=45, rgbcolor={255,128,0})),
              Text(
                extent=[-120,122; 120,73],
                string="%name",
                style(color=45, rgbcolor={255,128,0}))));
        end StabilityControl;
      end RollAngleTracking;

      package PathTracking
        model Classic_PT_VR
          "classic virtual rider composed of PI- and PID-controller"

          import Modelica.Blocks.Types.InitPID;
          import SI = Modelica.SIunits;

          // Stability Controller
          parameter Real k=1 "Gain";
          parameter SI.Time Ti(min=Modelica.Constants.small) = 0.5
            "|Stability Controller| Time Constant of Integrator";
          parameter SI.Time Td(min=0) = 0.1
            "|Stability Controller| Time Constant of Derivative block";
          parameter Real Nd(min=Modelica.Constants.small) = 10
            "|Stability Controller| The higher Nd, the more ideal the derivative block";
          parameter InitPID.Temp initType=Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState
            "|Stability Controller| Type of initialization"
                                             annotation(Evaluate=true,
              Dialog(group="Initialization"));
          parameter Real xi_start=0
            "|Stability Controller| Initial or guess value value for integrator output (= integrator state)"
            annotation (Dialog(group="Initialization"));
          parameter Real xd_start=0
            "|Stability Controller| Initial or guess value for state of derivative block"
            annotation (Dialog(group="Initialization"));
          parameter Real y_start=0
            "|Stability Controller| Initial value of output"
            annotation(Dialog(enable=initType == Init.InitialOutput, group=
                  "Initialization"));

          // Path Preview Controller
          parameter Real k_PI = 450 "|Path Preview Controller| Gain";
          parameter Real T = 30 "|Path Preview Controller| Time constant";

          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Interfaces.RealInput leanAngle
            annotation (extent=[-140,-80; -100,-40]);
          Modelica.Blocks.Interfaces.RealInput xlat "absolute lateral position"
            annotation (extent=[-140,0; -100,40]);
          Modelica.Blocks.Interfaces.RealInput xlat_set
            "set point lateral position" annotation (extent=[-140,40; -100,80]);
          Modelica.Blocks.Math.Feedback feedback_pos
            annotation (extent=[-50,50; -30,70],   rotation=0);
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=51,
                  rgbfillColor={255,255,170})),
              Text(
                extent=[-100,-90; 98,-150],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Line(points=[-80,0; -30,0], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Ellipse(extent=[76,4; 84,-4], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Rectangle(extent=[-92,2; -68,-2], style(color=3, rgbcolor={0,0,255})),
              Rectangle(extent=[-42,2; -18,-2], style(color=3, rgbcolor={0,0,255})),
              Line(points=[-50,-10; -46,-10; -46,10; -50,10], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Line(points=[-20,0; 80,0], style(
                  color=1,
                  rgbcolor={255,0,0},
                  fillPattern=1)),
              Line(points=[-20,0; 18,-4; 48,-10; 80,-24], style(
                  color=10,
                  rgbcolor={95,95,95},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Ellipse(extent=[76,-20; 84,-28], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=9,
                  rgbfillColor={175,175,175},
                  fillPattern=1))),
            Coordsys(scale=0.15));
          Modelica.Blocks.Continuous.PI PI_deltaP(     T=T, k=k_PI)
            annotation (extent=[0,50; 20,70]);
          Modelica.Blocks.Math.Add add annotation (extent=[60,-10; 80,10]);
          Modelica.Blocks.Continuous.PID PID(
            k=120,
            Ti=0.4,
            Td=0.15)
                   annotation (extent=[0,-16; 20,4]);
          Modelica.Blocks.Math.Feedback feedback_lean
            annotation (extent=[-50,-16; -30,4]);
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (extent=[-90,-16; -70,4]);

        initial equation
          if initType==InitPID.InitialOutput then
             T_steer = y_start;
          end if;

        equation

          connect(feedback_pos.u1, xlat_set) annotation (points=[-48,60; -120,60],
                                    style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.u2, xlat) annotation (points=[-40,52; -40,20; -120,
                20], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.y, PI_deltaP.u) annotation (points=[-31,60; -2,60],
                                style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(add.y, T_steer) annotation (points=[81,0; 110,0], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(add.u1, PI_deltaP.y) annotation (points=[58,6; 46,6; 46,60; 21,
                60], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(const.y, feedback_lean.u1)
                                            annotation (points=[-69,-6; -48,-6],
              style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=51,
              rgbfillColor={255,255,170},
              fillPattern=1));
          connect(feedback_lean.y, PID.u)
                                         annotation (points=[-31,-6; -2,-6],
              style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=51,
              rgbfillColor={255,255,170},
              fillPattern=1));
          connect(PID.y, add.u2) annotation (points=[21,-6; 58,-6], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=51,
              rgbfillColor={255,255,170},
              fillPattern=1));
          connect(feedback_lean.u2, leanAngle)
                                              annotation (points=[-40,-14; -40,
                -60; -120,-60], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=51,
              rgbfillColor={255,255,170},
              fillPattern=1));
        end Classic_PT_VR;

        model Classic_StateSpace_VR
          "Virtual rider composed of a state-space stability controller and an additional path preview controller (PI-Controller)"

          parameter Real F[1,4] = [2621.139060072288, 51.644789540803, 1394.263296471545, 111.065024150724]
            "|Stability Controller| state feedback matrix";

          parameter Real k = 450 "|Path Preview Controller| Gain";
          parameter Real T = 30 "|Path Preview Controller| Time constant";

          Modelica.Blocks.Interfaces.RealInput v "velocity"
            annotation (extent=[-140,-20; -100,20]);
          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Interfaces.RealInput leanAngle
            annotation (extent=[-140,-120; -100,-80]);
          Modelica.Blocks.Interfaces.RealInput xlat "absolute lateral position"
            annotation (extent=[-140,30; -100,70]);
          Modelica.Blocks.Interfaces.RealInput xlat_set
            "set point lateral position" annotation (extent=[-140,80; -100,120]);
          Modelica.Blocks.Math.Feedback feedback_pos
            annotation (extent=[-50,70; -30,90],   rotation=0);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StateSpace_VR
            stabilityController(F=F)
            annotation (extent=[-4,-21; 26,9]);
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170})),
              Polygon(points=[-100,-100; 100,100; -100,100; -100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=51,
                  rgbfillColor={255,255,170})),
              Text(
                extent=[-100,-90; 98,-150],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Line(points=[-80,0; -30,0], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Ellipse(extent=[76,4; 84,-4], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Rectangle(extent=[-92,2; -68,-2], style(color=3, rgbcolor={0,0,255})),
              Rectangle(extent=[-42,2; -18,-2], style(color=3, rgbcolor={0,0,255})),
              Line(points=[-50,-10; -46,-10; -46,10; -50,10], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Line(points=[-20,0; 80,0], style(
                  color=1,
                  rgbcolor={255,0,0},
                  fillPattern=1)),
              Line(points=[-20,0; 18,-4; 48,-10; 80,-24], style(
                  color=10,
                  rgbcolor={95,95,95},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Ellipse(extent=[76,-20; 84,-28], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=9,
                  rgbfillColor={175,175,175},
                  fillPattern=1))),
            Coordsys(scale=0.15));
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (extent=[-70,-40; -50,-20]);
          Modelica.Blocks.Continuous.PI PI_deltaP(k=k, T=T)
            annotation (extent=[0,50; 20,70]);
          Modelica.Blocks.Math.Add add annotation (extent=[60,-10; 80,10]);
          Modelica.Blocks.Interfaces.RealInput steerAngle
            annotation (extent=[-140,-70; -100,-30]);
        equation

          connect(feedback_pos.u1, xlat_set) annotation (points=[-48,80; -80,80;
                -80,100; -120,100], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.u2, xlat) annotation (points=[-40,72; -40,50; -120,
                50], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(stabilityController.phi, leanAngle) annotation (points=[-7,-18;
                -20,-18; -20,-100; -120,-100],
                                             style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(v, stabilityController.v) annotation (points=[-120,0; -7,0],
                                    style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(const.y, stabilityController.phi_set) annotation (points=[-49,-30;
                -40,-30; -40,-12; -7,-12],          style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(feedback_pos.y, PI_deltaP.u) annotation (points=[-31,80; -12,80;
                -12,60; -2,60], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(stabilityController.T_steer, add.u2) annotation (points=[27.5,-6;
                58,-6],     style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(add.y, T_steer) annotation (points=[81,0; 110,0], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(add.u1, PI_deltaP.y) annotation (points=[58,6; 46,6; 46,60; 21,
                60], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(steerAngle, stabilityController.delta) annotation (points=[-120,-50;
                -80,-50; -80,6; -7,6],      style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
        end Classic_StateSpace_VR;

        model StateSpace_PT_VR
          "Virtual rider based on a preceding eigenvalue analysis; valid for a specific velocity"

          parameter Real F[1,6] = [0, 0, 2621.139060072288, 51.644789540803, 1394.263296471545, 111.065024150724]
            "state feedback matrix";

          Modelica.Blocks.Continuous.Derivative derivative(T=1e-6)
            annotation (extent=[-10,-70; 10,-50],  rotation=0);
          Modelica.Blocks.Continuous.Derivative derivative1(T=1e-6)
            annotation (extent=[-10,-13; 10,7],    rotation=0);
          Modelica.Blocks.Math.Feedback feedback_lean
            annotation (extent=[-60,-50; -40,-30]);
          Modelica.Blocks.Math.Feedback feedback_steer
            annotation (extent=[-50,26; -30,46],   rotation=0);
          MotorcycleLib.VirtualRider.Utilities.lean2steer lean2steer
                                        annotation (extent=[-80,-24; -60,-4]);
          Modelica.Blocks.Interfaces.RealInput v "velocity"
            annotation (extent=[-140,-40; -100,0]);
          Modelica.Blocks.Interfaces.RealInput phi_set "lean angle set point"
            annotation (extent=[-140,-80; -100,-40]);
          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Interfaces.RealInput delta "steer angle "
            annotation (extent=[-140,0; -100,40]);
          Modelica.Blocks.Interfaces.RealInput phi "lean angle"
            annotation (extent=[-140,-120; -100,-80]);
          MotorcycleLib.VirtualRider.VirtualRigidRider.PathTracking.PathPreviewControl.StateSpace_LeanSteerLateral
            stateSpace_LeanSteerLateral(F=F)
            annotation (extent=[52,-15; 82,15]);
          Modelica.Blocks.Interfaces.RealInput xlat "absolute lateral position"
            annotation (extent=[-140,40; -100,80]);
          Modelica.Blocks.Continuous.Derivative derivative2(T=1e-6)
            annotation (extent=[-10,50; 10,70],    rotation=0);
          Modelica.Blocks.Interfaces.RealInput xlat_set
            "set point lateral position" annotation (extent=[-140,80; -100,120]);
          Modelica.Blocks.Math.Feedback feedback_pos
            annotation (extent=[-50,70; -30,90],   rotation=0);
        equation
          connect(derivative.u, feedback_lean.y)
                                            annotation (points=[-12,-60; -20,-60;
                -20,-40; -41,-40],       style(color=74, rgbcolor={0,0,127}));
          connect(derivative1.u, feedback_steer.y)
                                              annotation (points=[-12,-3; -20,-3;
                -20,36; -31,36],        style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer, feedback_steer.u1)
                                                  annotation (points=[-59,-14;
                -54,-14; -54,36; -48,36],                       style(color=74,
                rgbcolor={0,0,127}));
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170})),
              Text(
                extent=[-100,-90; 98,-150],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Line(points=[-80,0; -30,0], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Ellipse(extent=[76,4; 84,-4], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Rectangle(extent=[-92,2; -68,-2], style(color=3, rgbcolor={0,0,255})),
              Rectangle(extent=[-42,2; -18,-2], style(color=3, rgbcolor={0,0,255})),
              Line(points=[-50,-10; -46,-10; -46,10; -50,10], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Line(points=[-20,0; 80,0], style(
                  color=1,
                  rgbcolor={255,0,0},
                  fillPattern=1)),
              Line(points=[-20,0; 18,-4; 48,-10; 80,-24], style(
                  color=10,
                  rgbcolor={95,95,95},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Ellipse(extent=[76,-20; 84,-28], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=9,
                  rgbfillColor={175,175,175},
                  fillPattern=1))),
            Coordsys(scale=0.15));
          connect(lean2steer.v, v) annotation (points=[-82,-20; -120,-20],
                                                                         style(
                color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u1, phi_set)
                                        annotation (points=[-58,-40; -90,-40; -90,
                -60; -120,-60], style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.lean, phi_set) annotation (points=[-82,-8; -90,-8;
                -90,-60; -120,-60], style(color=74, rgbcolor={0,0,127}));
          connect(feedback_steer.u2, delta)
                                       annotation (points=[-40,28; -40,20; -120,
                20], style(color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u2, phi)
                                    annotation (points=[-50,-48; -50,-100; -120,
                -100],style(color=74, rgbcolor={0,0,127}));
          connect(stateSpace_LeanSteerLateral.der_phi_lean, derivative.y)
            annotation (points=[49,-15; 26,-15; 26,-60; 11,-60], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(stateSpace_LeanSteerLateral.phi_lean, feedback_lean.y)
            annotation (points=[49,-9; 20,-9; 20,-40; -41,-40], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(stateSpace_LeanSteerLateral.der_phi_steer, derivative1.y)
            annotation (points=[49,-3; 11,-3], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(stateSpace_LeanSteerLateral.phi_steer, feedback_steer.y)
            annotation (points=[49,3; 26,3; 26,36; -31,36], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(derivative2.y, stateSpace_LeanSteerLateral.der_xlat)
            annotation (points=[11,60; 32,60; 32,9; 49,9], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(stateSpace_LeanSteerLateral.SteeringTorque, T_steer)
            annotation (points=[83.5,0; 110,0], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.u1, xlat_set) annotation (points=[-48,80; -74,80;
                -74,100; -120,100], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.u2, xlat) annotation (points=[-40,72; -40,60; -120,
                60], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.y, stateSpace_LeanSteerLateral.xlat) annotation (
              points=[-31,80; 40,80; 40,15; 49,15], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(derivative2.u, feedback_pos.y) annotation (points=[-12,60; -20,
                60; -20,80; -31,80], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));

        end StateSpace_PT_VR;

        model StateSpace_PT_VR_Range
          "Virtual rider based on a preceding eigenvalue analysis; valid for a specific velocity range"

        parameter String filename = "place_pathPreview.mat"
            "|Store Settings| Filename to store the feedback matrix";

          Modelica.Blocks.Continuous.Der derivative
            annotation (extent=[-10,-26; 10,-6],   rotation=0);
          Modelica.Blocks.Continuous.Der derivative1
            annotation (extent=[-10,15; 10,35],    rotation=0);
          Modelica.Blocks.Math.Feedback feedback_lean
            annotation (extent=[-50,-7; -30,13]);
          Modelica.Blocks.Math.Feedback feedback_steer
            annotation (extent=[-50,54; -30,34],   rotation=0);
          MotorcycleLib.VirtualRider.Utilities.lean2steer lean2steer
                                        annotation (extent=[-80,34; -60,54]);
          Modelica.Blocks.Interfaces.RealInput v "velocity"
            annotation (extent=[-140,40; -100,80]);
          Modelica.Blocks.Interfaces.RealInput phi_set "lean angle set point"
            annotation (extent=[-140,0; -100,40]);
          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Interfaces.RealInput lambda "steer angle "
            annotation (extent=[-140,80; -100,120]);
          Modelica.Blocks.Interfaces.RealInput phi "lean angle"
            annotation (extent=[-140,-40; -100,0]);
          MotorcycleLib.VirtualRider.VirtualRigidRider.PathTracking.PathPreviewControl.PathPreviewController_table
            stateSpace_LeanSteerLateral
            annotation (extent=[46,-15; 76,15]);
          Modelica.Blocks.Interfaces.RealInput xlat "absolute lateral position"
            annotation (extent=[-140,-120; -100,-80]);
          Modelica.Blocks.Continuous.Der derivative2
            annotation (extent=[-10,-88; 10,-68],  rotation=0);
          Modelica.Blocks.Interfaces.RealInput xlat_set
            "set point lateral position" annotation (extent=[-140,-80; -100,-40]);
          Modelica.Blocks.Math.Feedback feedback_pos
            annotation (extent=[-50,-70; -30,-50], rotation=0);
        equation
          connect(derivative.u, feedback_lean.y)
                                            annotation (points=[-12,-16; -20,
                -16; -20,3; -31,3],      style(color=74, rgbcolor={0,0,127}));
          connect(derivative1.u, feedback_steer.y)
                                              annotation (points=[-12,25; -20,
                25; -20,44; -31,44],    style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer, feedback_steer.u1)
                                                  annotation (points=[-59,44;
                -48,44],                                        style(color=74,
                rgbcolor={0,0,127}));
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170})),
              Text(
                extent=[-100,-90; 98,-150],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Line(points=[-80,0; -30,0], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Ellipse(extent=[76,4; 84,-4], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Rectangle(extent=[-92,2; -68,-2], style(color=3, rgbcolor={0,0,255})),
              Rectangle(extent=[-42,2; -18,-2], style(color=3, rgbcolor={0,0,255})),
              Line(points=[-50,-10; -46,-10; -46,10; -50,10], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Line(points=[-20,0; 80,0], style(
                  color=1,
                  rgbcolor={255,0,0},
                  fillPattern=1)),
              Line(points=[-20,0; 18,-4; 48,-10; 80,-24], style(
                  color=10,
                  rgbcolor={95,95,95},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Ellipse(extent=[76,-20; 84,-28], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=9,
                  rgbfillColor={175,175,175},
                  fillPattern=1))),
            Coordsys(scale=0.15));
          connect(lean2steer.v, v) annotation (points=[-82,38; -94,38; -94,60;
                -120,60],                                                style(
                color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u1, phi_set)
                                        annotation (points=[-48,3; -88,3; -88,
                20; -120,20],   style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.lean, phi_set) annotation (points=[-82,50; -88,50;
                -88,20; -120,20],   style(color=74, rgbcolor={0,0,127}));
          connect(feedback_steer.u2, lambda)
                                       annotation (points=[-40,52; -40,100;
                -120,100],
                     style(color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u2, phi)
                                    annotation (points=[-40,-5; -40,-20; -120,
                -20], style(color=74, rgbcolor={0,0,127}));
          connect(stateSpace_LeanSteerLateral.der_phi_lean, derivative.y)
            annotation (points=[43,-3; 20,-3; 20,-16; 11,-16],   style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(stateSpace_LeanSteerLateral.phi_lean, feedback_lean.y)
            annotation (points=[43,3; -31,3],                   style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(stateSpace_LeanSteerLateral.phi_steer, feedback_steer.y)
            annotation (points=[43,15; 28,15; 28,44; -31,44],
                                                            style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.u1, xlat_set) annotation (points=[-48,-60; -120,
                -60],               style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.u2, xlat) annotation (points=[-40,-68; -40,-100;
                -120,-100],
                     style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(derivative2.u, feedback_pos.y) annotation (points=[-12,-78;
                -20,-78; -20,-60; -31,-60],
                                     style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(derivative1.y, stateSpace_LeanSteerLateral.der_phi_steer)
            annotation (points=[11,25; 20,25; 20,9; 43,9],
                                             style(color=74, rgbcolor={0,0,127}));
          connect(stateSpace_LeanSteerLateral.x_lat, feedback_pos.y) annotation (
              points=[43,-9; 28,-9; 28,-60; -31,-60],
                                                    style(color=74, rgbcolor={0,0,
                  127}));
          connect(stateSpace_LeanSteerLateral.der_x_lat, derivative2.y)
            annotation (points=[43,-15; 34,-15; 34,-78; 11,-78],
                                                               style(color=74,
                rgbcolor={0,0,127}));
          connect(stateSpace_LeanSteerLateral.T_steering, T_steer) annotation (
              points=[77.5,0; 110,0], style(color=74, rgbcolor={0,0,127}));
          connect(stateSpace_LeanSteerLateral.v, v) annotation (points=[59.2,-18;
                59.2,-40; -94,-40; -94,60; -120,60], style(color=74, rgbcolor={
                  0,0,127}));

        end StateSpace_PT_VR_Range;

        model LQR_PT_VR "A virtual rider based on a linear quadratic regulator"

          parameter Real F[1,6] = [0, 0, 2621.139060072288, 51.644789540803, 1394.263296471545, 111.065024150724]
            "state feedback matrix";

          Modelica.Blocks.Continuous.Derivative derivative(T=1e-6)
            annotation (extent=[-10,-70; 10,-50],  rotation=0);
          Modelica.Blocks.Continuous.Derivative derivative1(T=1e-6)
            annotation (extent=[-10,-13; 10,7],    rotation=0);
          Modelica.Blocks.Math.Feedback feedback_lean
            annotation (extent=[-60,-50; -40,-30]);
          Modelica.Blocks.Math.Feedback feedback_steer
            annotation (extent=[-50,26; -30,46],   rotation=0);
          MotorcycleLib.VirtualRider.Utilities.lean2steer lean2steer
                                        annotation (extent=[-80,-24; -60,-4]);
          Modelica.Blocks.Interfaces.RealInput v "velocity"
            annotation (extent=[-140,-40; -100,0]);
          Modelica.Blocks.Interfaces.RealInput phi_set "lean angle set point"
            annotation (extent=[-140,-80; -100,-40]);
          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Interfaces.RealInput delta "steer angle "
            annotation (extent=[-140,0; -100,40]);
          Modelica.Blocks.Interfaces.RealInput phi "lean angle"
            annotation (extent=[-140,-120; -100,-80]);
          MotorcycleLib.VirtualRider.VirtualRigidRider.PathTracking.PathPreviewControl.LQR_LeanSteerLateral
            stateSpace_LeanSteerLateral(F=F)
            annotation (extent=[52,-15; 82,15]);
          Modelica.Blocks.Interfaces.RealInput xlat "absolute lateral position"
            annotation (extent=[-140,40; -100,80]);
          Modelica.Blocks.Continuous.Derivative derivative2(T=1e-6)
            annotation (extent=[-10,50; 10,70],    rotation=0);
          Modelica.Blocks.Interfaces.RealInput xlat_set
            "set point lateral position" annotation (extent=[-140,80; -100,120]);
          Modelica.Blocks.Math.Feedback feedback_pos
            annotation (extent=[-50,70; -30,90],   rotation=0);
        equation
          connect(derivative.u, feedback_lean.y)
                                            annotation (points=[-12,-60; -20,-60;
                -20,-40; -41,-40],       style(color=74, rgbcolor={0,0,127}));
          connect(derivative1.u, feedback_steer.y)
                                              annotation (points=[-12,-3; -20,-3;
                -20,36; -31,36],        style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer, feedback_steer.u1)
                                                  annotation (points=[-59,-14;
                -54,-14; -54,36; -48,36],                       style(color=74,
                rgbcolor={0,0,127}));
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=68,
                  rgbfillColor={170,213,255})),
              Text(
                extent=[-100,-90; 98,-150],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Line(points=[-80,0; -30,0], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Ellipse(extent=[76,4; 84,-4], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Rectangle(extent=[-92,2; -68,-2], style(color=3, rgbcolor={0,0,255})),
              Rectangle(extent=[-42,2; -18,-2], style(color=3, rgbcolor={0,0,255})),
              Line(points=[-50,-10; -46,-10; -46,10; -50,10], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Line(points=[-20,0; 80,0], style(
                  color=1,
                  rgbcolor={255,0,0},
                  fillPattern=1)),
              Line(points=[-20,0; 18,-4; 48,-10; 80,-24], style(
                  color=10,
                  rgbcolor={95,95,95},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Ellipse(extent=[76,-20; 84,-28], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=9,
                  rgbfillColor={175,175,175},
                  fillPattern=1))),
            Coordsys(scale=0.15));
          connect(lean2steer.v, v) annotation (points=[-82,-20; -120,-20],
                                                                         style(
                color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u1, phi_set)
                                        annotation (points=[-58,-40; -90,-40; -90,
                -60; -120,-60], style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.lean, phi_set) annotation (points=[-82,-8; -90,-8;
                -90,-60; -120,-60], style(color=74, rgbcolor={0,0,127}));
          connect(feedback_steer.u2, delta)
                                       annotation (points=[-40,28; -40,20; -120,
                20], style(color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u2, phi)
                                    annotation (points=[-50,-48; -50,-100; -120,
                -100],style(color=74, rgbcolor={0,0,127}));
          connect(stateSpace_LeanSteerLateral.der_phi_lean, derivative.y)
            annotation (points=[49,-15; 26,-15; 26,-60; 11,-60], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(stateSpace_LeanSteerLateral.phi_lean, feedback_lean.y)
            annotation (points=[49,-9; 20,-9; 20,-40; -41,-40], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(stateSpace_LeanSteerLateral.der_phi_steer, derivative1.y)
            annotation (points=[49,-3; 11,-3], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(stateSpace_LeanSteerLateral.phi_steer, feedback_steer.y)
            annotation (points=[49,3; 26,3; 26,36; -31,36], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(derivative2.y, stateSpace_LeanSteerLateral.der_xlat)
            annotation (points=[11,60; 32,60; 32,9; 49,9], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(stateSpace_LeanSteerLateral.SteeringTorque, T_steer)
            annotation (points=[83.5,0; 110,0], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.u1, xlat_set) annotation (points=[-48,80; -74,80;
                -74,100; -120,100], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.u2, xlat) annotation (points=[-40,72; -40,60; -120,
                60], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.y, stateSpace_LeanSteerLateral.xlat) annotation (
              points=[-31,80; 40,80; 40,15; 49,15], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(derivative2.u, feedback_pos.y) annotation (points=[-12,60; -20,
                60; -20,80; -31,80], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));

        end LQR_PT_VR;

        package PathPreviewControl
          "several state space controllers for path tracking issues"
          model StateSpace_LeanLateral
            "State Space Controller including lean angle, lateral displacement and their derivatives as states"

            // The controller matrix is calculated with Matlab
            parameter Real F[1,4] = [-0.07, 0.07, 263.74, -25.33];

            Modelica.Blocks.Interfaces.RealInput y
              "absolute lateral displacement"
              annotation (extent=[-140,-50; -100,-10]);
            Modelica.Blocks.Interfaces.RealInput der_phi
              "derivative of lean angle"
              annotation (extent=[-140,10; -100,50]);
            Modelica.Blocks.Interfaces.RealOutput SteeringTorque
              annotation (extent=[100,-10; 120,10]);
            annotation (Diagram, DymolaStoredErrors,
              Icon(
                Rectangle(extent=[-100,100; 100,-100], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255})),
                Text(extent=[-90,10; -10,90],   string="A",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[0,-90; 0,90],   style(color=8)),
                Text(extent=[10,10; 90,90],   string="B",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[-90,-10; -10,-90],   string="C",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[10,-10; 90,-90],   string="D",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[-90,0; 90,0],   style(color=8)),
                Text(
                  extent=[-100,100; 100,-100],
                  string="F",
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1))));

            Modelica.Blocks.Interfaces.RealInput phi "lean angle"
              annotation (extent=[-140,60; -100,100]);
            Modelica.Blocks.Interfaces.RealInput der_y
              "absolute lateral velocity"
              annotation (extent=[-140,-100; -100,-60]);
          equation
            // T = F*X
            // T ... Torque input
            // F ... Feedback matrix
            // X ... State vector

           {SteeringTorque} = F*{y, der_y, phi, der_phi};

          end StateSpace_LeanLateral;

          model StateSpace_LeanYawLateral
            "State Space Controller including lean angle, yaw angle, lateral displacement and their derivatives as states"

            // The controller matrix is calculated with Matlab
            parameter Real F[1,6] = [0, -0.2861, 1.3015, -888.9631, -67.2941, 84.1259];

            Modelica.Blocks.Interfaces.RealInput y
              "absolute lateral displacement"
              annotation (extent=[-140,-80; -100,-40]);
            Modelica.Blocks.Interfaces.RealInput der_phi
              "derivative of lean angle"
              annotation (extent=[-140,40; -100,80]);
            Modelica.Blocks.Interfaces.RealOutput SteeringTorque
              annotation (extent=[100,-10; 120,10]);
            annotation (Diagram, DymolaStoredErrors,
              Icon(
                Rectangle(extent=[-100,100; 100,-100], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255})),
                Text(extent=[-90,10; -10,90],   string="A",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[0,-90; 0,90],   style(color=8)),
                Text(extent=[10,10; 90,90],   string="B",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[-90,-10; -10,-90],   string="C",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[10,-10; 90,-90],   string="D",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[-90,0; 90,0],   style(color=8)),
                Text(
                  extent=[-100,100; 100,-100],
                  string="F",
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1))));

            Modelica.Blocks.Interfaces.RealInput phi "lean angle"
              annotation (extent=[-140,80; -100,120]);
            Modelica.Blocks.Interfaces.RealInput der_y
              "absolute lateral velocity"
              annotation (extent=[-140,-120; -100,-80]);
            Modelica.Blocks.Interfaces.RealInput yaw "absolute yaw angle"
              annotation (extent=[-140,0; -100,40]);
            Modelica.Blocks.Interfaces.RealInput der_yaw "yaw rate"
              annotation (extent=[-140,-40; -100,0]);
          equation
            // T = F*X
            // T ... Torque input
            // F ... Feedback matrix
            // X ... State vector

            {SteeringTorque} = F*{y, der_y, yaw, der_yaw, phi, der_phi};

          end StateSpace_LeanYawLateral;

          model StateSpace_LeanSteerLateral
            "State Space Controller including lateral position, lean angle, steer angle and their derivatives as states"

            // The controller matrix is calculated with Matlab
            // A detailed description can be found in the information section of the State Space Controller
            parameter Real F[1,6] = [0, 0, 663.0621,   27.9578,  234.1761,   37.96249];

            Modelica.Blocks.Interfaces.RealInput phi_lean "lean angle"
              annotation (extent=[-140,-80; -100,-40]);
            Modelica.Blocks.Interfaces.RealInput der_phi_steer "steer rate"
              annotation (extent=[-140,-40; -100,0]);
            Modelica.Blocks.Interfaces.RealOutput SteeringTorque
              annotation (extent=[100,-10; 120,10]);
            annotation (Diagram, DymolaStoredErrors,
              Icon(
                Rectangle(extent=[-100,100; 100,-100], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255})),
                Text(extent=[-90,10; -10,90],   string="A",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[0,-90; 0,90],   style(color=8)),
                Text(extent=[10,10; 90,90],   string="B",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[-90,-10; -10,-90],   string="C",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[10,-10; 90,-90],   string="D",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[-90,0; 90,0],   style(color=8)),
                Text(
                  extent=[-100,100; 100,-100],
                  string="F",
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1))),
              Coordsys(scale=0.15));

            Modelica.Blocks.Interfaces.RealInput phi_steer "steer angle"
              annotation (extent=[-140,0; -100,40]);
            Modelica.Blocks.Interfaces.RealInput der_phi_lean "lean rate"
              annotation (extent=[-140,-120; -100,-80]);
            Modelica.Blocks.Interfaces.RealInput der_xlat
              "absolute lateral rate"
              annotation (extent=[-140,40; -100,80]);
            Modelica.Blocks.Interfaces.RealInput xlat
              "absolute lateral position"
              annotation (extent=[-140,80; -100,120]);
          equation
            // T = F*X
            // T ... Torque input
            // F ... Feedback matrix
            // X ... State vector

            {SteeringTorque} = F*{phi_steer, der_phi_steer, phi_lean, der_phi_lean, xlat, der_xlat};

          end StateSpace_LeanSteerLateral;

          model PathPreviewController_table
            "Full State Feedback Controller with several different feedback matrices depending on the actual velocity"

          parameter String filename = "place_pathPreview.mat"
              "|Store Settings| Filename to store the feedback matrix";

            Modelica.Blocks.Interfaces.RealInput phi_steer "steer angle"
              annotation (extent=[-140,80; -100,120]);
            Modelica.Blocks.Interfaces.RealInput der_phi_steer "steer rate"
              annotation (extent=[-140,40; -100,80]);
            Modelica.Blocks.Interfaces.RealInput phi_lean "lean angle"
              annotation (extent=[-140,0; -100,40]);
            Modelica.Blocks.Interfaces.RealInput der_phi_lean "lean rate"
              annotation (extent=[-140,-40; -100,0]);
            annotation (
              Diagram,
              Icon(
                Rectangle(extent=[-100,102; 100,-100], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1)),
                Line(points=[64,70; 44,70; 44,-70; 64,-70], style(color=0, rgbcolor=
                       {0,0,0})),
                Line(points=[74,70; 94,70; 94,-70; 74,-70], style(color=0, rgbcolor=
                       {0,0,0})),
                Line(points=[-75,30; -95,30; -95,-30; -75,-30], style(color=0,
                      rgbcolor={0,0,0})),
                Line(points=[-2,30; 18,30; 18,-30; -2,-30], style(color=0, rgbcolor=
                       {0,0,0})),
                Ellipse(extent=[25,6; 37,-6], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=0,
                    rgbfillColor={0,0,0})),
                Text(
                  extent=[12,-42; -88,42],
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=0,
                    rgbfillColor={0,0,0},
                    fillPattern=1),
                  string="F=f(v)"),
                Text(
                  extent=[109,-44; 29,36],
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=0,
                    rgbfillColor={0,0,0},
                    fillPattern=1),
                  string="X"),
                Line(points=[-12,-98; -12,-98; -12,-14; -18,-30; -6,-30; -12,
                      -14],
                    style(
                    color=10,
                    rgbcolor={95,95,95},
                    pattern=2,
                    fillColor=1,
                    rgbfillColor={255,0,0},
                    fillPattern=1)),
                Text(
                  extent=[-100,142; 100,102],
                  style(
                    color=3,
                    rgbcolor={0,0,255},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1),
                  string="%name")),
              Coordsys(scale=0.15));
            Modelica.Blocks.Interfaces.RealInput v "velocity of the vehicle"
              annotation (extent=[-32,-140; 8,-100], rotation=90);
            Modelica.Blocks.Math.Product product annotation (extent=[-6,80; 14,
                  100]);
            Modelica.Blocks.Math.Product product1 annotation (extent=[-6,50; 14,
                  70]);
            Modelica.Blocks.Math.Product product2 annotation (extent=[-6,20; 14,
                  40]);
            Modelica.Blocks.Math.Product product3
              annotation (extent=[-6,-10; 14,10]);
            Modelica.Blocks.Math.Add add annotation (extent=[28,56; 48,76]);
            Modelica.Blocks.Math.Add add1 annotation (extent=[28,-4; 48,16]);
            Modelica.Blocks.Math.Add3 add2
                                          annotation (extent=[64,-4; 84,16]);
            Modelica.Blocks.Interfaces.RealOutput T_steering
              annotation (extent=[100,-10; 120,10]);
            Modelica.Blocks.Tables.CombiTable1Ds combiTable1Ds(
              tableOnFile=true,
              tableName="Ftable",
              fileName=filename,
              columns=2:7) annotation (extent=[-50,-91; -30,-71], rotation=90);
            Modelica.Blocks.Math.Product product4 annotation (extent=[-6,-40;
                  14,-20]);
            Modelica.Blocks.Math.Product product5
              annotation (extent=[-6,-70; 14,-50]);
            Modelica.Blocks.Math.Add add3 annotation (extent=[28,-46; 48,-26]);
            Modelica.Blocks.Interfaces.RealInput der_x_lat "lateral rate"
              annotation (extent=[-140,-120; -100,-80]);
            Modelica.Blocks.Interfaces.RealInput x_lat "lateral position"
              annotation (extent=[-140,-80; -100,-40]);
          equation
            connect(phi_steer, product.u1) annotation (points=[-120,100; -80,
                  100; -80,96; -8,96],
                                  style(color=74, rgbcolor={0,0,127}));
            connect(der_phi_steer, product1.u1) annotation (points=[-120,60;
                  -80,60; -80,66; -8,66],
                                  style(color=74, rgbcolor={0,0,127}));
            connect(phi_lean, product2.u1) annotation (points=[-120,20; -80,20;
                  -80,36; -8,36],
                              style(color=74, rgbcolor={0,0,127}));
            connect(der_phi_lean, product3.u1) annotation (points=[-120,-20;
                  -80,-20; -80,6; -8,6], style(color=74, rgbcolor={0,0,127}));
            connect(add.u1, product.y) annotation (points=[26,72; 20,72; 20,90;
                  15,90],
                       style(color=74, rgbcolor={0,0,127}));
            connect(product1.y, add.u2) annotation (points=[15,60; 26,60], style(
                  color=74, rgbcolor={0,0,127}));
            connect(product2.y, add1.u1) annotation (points=[15,30; 20,30; 20,
                  12; 26,12],                                               style(
                  color=74, rgbcolor={0,0,127}));
            connect(product3.y, add1.u2) annotation (points=[15,0; 26,0],
                          style(color=74, rgbcolor={0,0,127}));
            connect(add2.u1, add.y) annotation (points=[62,14; 54,14; 54,66; 49,
                  66],
                style(color=74, rgbcolor={0,0,127}));
            connect(add2.u2, add1.y) annotation (points=[62,6; 49,6],
                style(color=74, rgbcolor={0,0,127}));
            connect(add2.y, T_steering) annotation (points=[85,6; 92,6; 92,0;
                  110,0], style(color=74, rgbcolor={0,0,127}));
            connect(T_steering, T_steering) annotation (points=[110,0; 110,0],
                style(
                color=74,
                rgbcolor={0,0,127},
                fillPattern=1));
            connect(combiTable1Ds.y[4], product3.u2) annotation (points=[-40,-70;
                  -40,-6; -8,-6],            style(color=74, rgbcolor={0,0,127}));
            connect(combiTable1Ds.y[3], product2.u2) annotation (points=[-40,-70;
                  -40,24; -8,24],            style(color=74, rgbcolor={0,0,127}));
            connect(combiTable1Ds.y[2], product1.u2) annotation (points=[-40,-70;
                  -40,54; -8,54],          style(color=74, rgbcolor={0,0,127}));
            connect(combiTable1Ds.y[1], product.u2) annotation (points=[-40,-70;
                  -40,84; -8,84],          style(color=74, rgbcolor={0,0,127}));
            connect(product4.y,add3. u1) annotation (points=[15,-30; 26,-30],
                                                                            style(
                  color=74, rgbcolor={0,0,127}));
            connect(product5.y,add3. u2) annotation (points=[15,-60; 20,-60; 20,
                  -42; 26,-42],
                          style(color=74, rgbcolor={0,0,127}));
            connect(v, combiTable1Ds.u) annotation (points=[-12,-120; -12,-98;
                  -40,-98; -40,-93], style(color=74, rgbcolor={0,0,127}));
            connect(add2.u3, add3.y) annotation (points=[62,-2; 54,-2; 54,-36;
                  49,-36], style(color=74, rgbcolor={0,0,127}));
            connect(product4.u2, combiTable1Ds.y[5]) annotation (points=[-8,-36;
                  -40,-36; -40,-70], style(color=74, rgbcolor={0,0,127}));
            connect(product5.u2, combiTable1Ds.y[6]) annotation (points=[-8,-66;
                  -40,-66; -40,-70], style(color=74, rgbcolor={0,0,127}));
            connect(x_lat, product4.u1) annotation (points=[-120,-60; -70,-60;
                  -70,-24; -8,-24], style(color=74, rgbcolor={0,0,127}));
            connect(der_x_lat, product5.u1) annotation (points=[-120,-100; -60,
                  -100; -60,-54; -8,-54], style(color=74, rgbcolor={0,0,127}));
          end PathPreviewController_table;

          model LQR_LeanSteerLateral
            "LQR including lateral position, lean angle, steer angle and their derivatives as states"

            // The controller matrix is calculated with Matlab
            parameter Real F[1,6] = [0, 0, 663.0621,   27.9578,  234.1761,   37.96249];

            Modelica.Blocks.Interfaces.RealInput phi_lean "lean angle"
              annotation (extent=[-140,-80; -100,-40]);
            Modelica.Blocks.Interfaces.RealInput der_phi_steer "steer rate"
              annotation (extent=[-140,-40; -100,0]);
            Modelica.Blocks.Interfaces.RealOutput SteeringTorque
              annotation (extent=[100,-10; 120,10]);
            annotation (Diagram, DymolaStoredErrors,
              Icon(
                Rectangle(extent=[-100,100; 100,-100], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255})),
                Text(extent=[-90,10; -10,90],   string="A",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[0,-90; 0,90],   style(color=8)),
                Text(extent=[10,10; 90,90],   string="B",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[-90,-10; -10,-90],   string="C",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[10,-10; 90,-90],   string="D",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[-90,0; 90,0],   style(color=8)),
                Text(
                  extent=[-100,100; 100,-100],
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1),
                  string="LQR")),
              Coordsys(scale=0.15));

            Modelica.Blocks.Interfaces.RealInput phi_steer "steer angle"
              annotation (extent=[-140,0; -100,40]);
            Modelica.Blocks.Interfaces.RealInput der_phi_lean "lean rate"
              annotation (extent=[-140,-120; -100,-80]);
            Modelica.Blocks.Interfaces.RealInput der_xlat
              "absolute lateral rate"
              annotation (extent=[-140,40; -100,80]);
            Modelica.Blocks.Interfaces.RealInput xlat
              "absolute lateral position"
              annotation (extent=[-140,80; -100,120]);
          equation
            // T = F*X
            // T ... Torque input
            // F ... Feedback matrix
            // X ... State vector

            {SteeringTorque} = F*{phi_steer, der_phi_steer, phi_lean, der_phi_lean, xlat, der_xlat};

          end LQR_LeanSteerLateral;
          annotation (Icon(
              Rectangle(extent=[-100,-100; 80,50], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Text(
                extent=[-85,35; 65,-85],
                string="Library",
                style(color=45, rgbcolor={255,128,0})),
              Text(
                extent=[-120,122; 120,73],
                string="%name",
                style(color=45, rgbcolor={255,128,0}))));
        end PathPreviewControl;
      end PathTracking;

    end VirtualRigidRider;

    annotation (Icon(
        Rectangle(extent=[-100,-100; 80,50], style(
            color=58,
            rgbcolor={0,127,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
            color=58,
            rgbcolor={0,127,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
            color=58,
            rgbcolor={0,127,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Text(
          extent=[-85,35; 65,-85],
          string="Library",
          style(color=58, rgbcolor={0,127,0})),
        Text(
          extent=[-120,122; 120,73],
          string="%name",
          style(color=58, rgbcolor={0,127,0}))), Documentation(info="<html>
A detailed description of the models can be found in:
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.VirtualRider\">UsersGuide.Overview.VirtualRider</a>]</span>

</html>"));
    package VirtualMovableRider
      package RollAngleTracking
        model StateSpace_VMR
          "virtual movable rider based on  a state-space controller"

          import SI = Modelica.SIunits;
          import CO = Modelica.SIunits.Conversions;
          import MA = Modelica.Math;

          parameter SI.Distance p = 1.414 "wheel base";

          parameter CO.NonSIunits.Angle_deg eps = 27
            "Caster angle (Steering head angle)";

          parameter Real F[2,6] = [ 34.2606,    1.6523,   22.7179,    3.4349,   10.2637,    3.1373;
                                   118.7795,   29.6039,  169.5166,   64.2751,  246.6806,   84.0309];

          Modelica.Blocks.Continuous.Der derivative
            annotation (extent=[0,-34; 20,-14],    rotation=0);
          Modelica.Blocks.Continuous.Der derivative1
            annotation (extent=[0,10; 20,30],      rotation=0);
          Modelica.Blocks.Math.Feedback feedback_lean
            annotation (extent=[-40,-10; -20,10]);
          Modelica.Blocks.Math.Feedback feedback_steer
            annotation (extent=[-40,56; -20,36],   rotation=0);
          Utilities.lean2steer_simple lean2steer(p=p, eps=eps)
                                        annotation (extent=[-70,36; -50,56]);
          Modelica.Blocks.Interfaces.RealInput v "velocity"
            annotation (extent=[-140,40; -100,80]);
          Modelica.Blocks.Interfaces.RealInput phi_set "lean angle set point"
            annotation (extent=[-140,0; -100,40]);
          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,30; 120,50]);
          Modelica.Blocks.Interfaces.RealInput delta "steer angle "
            annotation (extent=[-140,80; -100,120]);
          Modelica.Blocks.Interfaces.RealInput phi "lean angle"
            annotation (extent=[-140,-40; -100,0]);
          MotorcycleLib.VirtualRider.VirtualMovableRider.RollAngleTracking.StabilityControl.StateSpaceController
            stateSpaceController1(F=F)
            annotation (extent=[54,-4; 84,26]);
          Modelica.Blocks.Interfaces.RealOutput T_Rider "rider lean torque"
            annotation (extent=[100,-50; 120,-30]);
          Modelica.Blocks.Interfaces.RealInput phi_rider_set
            "rider lean angle set point"
            annotation (extent=[-140,-80; -100,-40]);
          Modelica.Blocks.Interfaces.RealInput phi_rider "rider lean angle"
            annotation (extent=[-140,-120; -100,-80]);
          Modelica.Blocks.Math.Feedback feedback_rider
            annotation (extent=[-40,-70; -20,-50]);
          Modelica.Blocks.Continuous.Der derivative2
            annotation (extent=[0,-90; 20,-70],    rotation=0);
        equation
          connect(derivative.u, feedback_lean.y)
                                            annotation (points=[-2,-24; -10,-24;
                -10,0; -21,0],           style(color=74, rgbcolor={0,0,127}));
          connect(derivative1.u, feedback_steer.y)
                                              annotation (points=[-2,20; -11,20;
                -11,46; -21,46],        style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer, feedback_steer.u1)
                                                  annotation (points=[-49,46;
                -38,46],                                        style(color=74,
                rgbcolor={0,0,127}));
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=84,
                  rgbfillColor={213,170,255})),
              Text(
                extent=[-100,-90; 98,-150],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-70,42; 70,-98], style(color=1, rgbcolor={255,0,0})),
              Rectangle(extent=[-98,2; 98,-98], style(
                  pattern=0,
                  fillColor=84,
                  rgbfillColor={213,170,255})),
              Ellipse(extent=[12,90; 40,62],  style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[-20,0; -20,6; 20,6; 20,0],     style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Rectangle(extent=[-2,-24; 2,-88],style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Polygon(points=[-68,-9; -68,5; -58,1; -68,-9], style(color=1,
                    rgbcolor={255,0,0})),
              Polygon(points=[68,-10; 58,0; 68,4; 68,-10], style(color=1,
                    rgbcolor={255,0,0})),
              Line(points=[0,6; 0,-88],  style(color=0, rgbcolor={0,0,0})),
              Line(points=[20,64; 0,6],  style(color=0, rgbcolor={0,0,0}))),
            Coordsys(scale=0.15));
          connect(lean2steer.v, v) annotation (points=[-72,40; -90,40; -90,60;
                -120,60],                                                style(
                color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u1, phi_set)
                                        annotation (points=[-38,0; -80,0; -80,
                20; -120,20],   style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.lean, phi_set) annotation (points=[-72,52; -80,52;
                -80,20; -120,20],   style(color=74, rgbcolor={0,0,127}));
          connect(feedback_steer.u2, delta)
                                       annotation (points=[-30,54; -30,100;
                -120,100],
                     style(color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u2, phi)
                                    annotation (points=[-30,-8; -30,-20; -120,
                -20], style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController1.SteeringTorque, T_steer) annotation (
              points=[85.5,17; 90,17; 90,40; 110,40],
                                                    style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(T_Rider, stateSpaceController1.RiderLeanTorque) annotation (
              points=[110,-40; 90,-40; 90,5; 85.5,5],   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(stateSpaceController1.SteerAngle, feedback_steer.y)
                                                                 annotation (
              points=[51,26; 32,26; 32,46; -21,46], style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(stateSpaceController1.SteerRate, derivative1.y) annotation (
              points=[51,20; 21,20],
                                   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(stateSpaceController1.LeanAngle, feedback_lean.y)
                                                               annotation (points=[51,14;
                26,14; 26,0; -21,0],          style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(derivative.y, stateSpaceController1.LeanRate) annotation (
              points=[21,-24; 32,-24; 32,8; 51,8],   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(phi_rider_set, feedback_rider.u1)
                                               annotation (points=[-120,-60;
                -38,-60],
                      style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(feedback_rider.y, stateSpaceController1.RiderLeanAngle)
                                                                     annotation (
              points=[-21,-60; 38,-60; 38,2; 51,2],   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(derivative2.y, stateSpaceController1.RiderLeanRate) annotation (
             points=[21,-80; 44,-80; 44,-4; 51,-4],   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(derivative2.u, feedback_rider.y)
                                              annotation (points=[-2,-80; -10,
                -80; -10,-60; -21,-60],
                                   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(feedback_rider.u2, phi_rider)
                                           annotation (points=[-30,-68; -30,
                -100; -120,-100],
                            style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));

        end StateSpace_VMR;

        model LQR_VMR
          "virtual movable rider based on  a state-space controller"

          import SI = Modelica.SIunits;
          import CO = Modelica.SIunits.Conversions;
          import MA = Modelica.Math;

          parameter SI.Distance p = 1.414 "wheel base";

          parameter CO.NonSIunits.Angle_deg eps = 27
            "Caster angle (Steering head angle)";

          parameter Real F[2,6] = [ 34.2606,    1.6523,   22.7179,    3.4349,   10.2637,    3.1373;
                                   118.7795,   29.6039,  169.5166,   64.2751,  246.6806,   84.0309];

          Modelica.Blocks.Continuous.Der derivative
            annotation (extent=[0,-34; 20,-14],    rotation=0);
          Modelica.Blocks.Continuous.Der derivative1
            annotation (extent=[0,10; 20,30],      rotation=0);
          Modelica.Blocks.Math.Feedback feedback_lean
            annotation (extent=[-40,-10; -20,10]);
          Modelica.Blocks.Math.Feedback feedback_steer
            annotation (extent=[-40,56; -20,36],   rotation=0);
          MotorcycleLib.VirtualRider.Utilities.lean2steer lean2steer(p=p, eps=
                eps)                    annotation (extent=[-70,36; -50,56]);
          Modelica.Blocks.Interfaces.RealInput v "velocity"
            annotation (extent=[-140,40; -100,80]);
          Modelica.Blocks.Interfaces.RealInput phi_set "lean angle set point"
            annotation (extent=[-140,0; -100,40]);
          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,30; 120,50]);
          Modelica.Blocks.Interfaces.RealInput delta "steer angle "
            annotation (extent=[-140,80; -100,120]);
          Modelica.Blocks.Interfaces.RealInput phi "lean angle"
            annotation (extent=[-140,-40; -100,0]);
          StabilityControl.LQRController stateSpaceController1(       F=F)
            annotation (extent=[54,-4; 84,26]);
          Modelica.Blocks.Interfaces.RealOutput T_Rider "rider lean torque"
            annotation (extent=[100,-50; 120,-30]);
          Modelica.Blocks.Interfaces.RealInput phi_rider_set
            "rider lean angle set point"
            annotation (extent=[-140,-80; -100,-40]);
          Modelica.Blocks.Interfaces.RealInput phi_rider "rider lean angle"
            annotation (extent=[-140,-120; -100,-80]);
          Modelica.Blocks.Math.Feedback feedback_rider
            annotation (extent=[-40,-70; -20,-50]);
          Modelica.Blocks.Continuous.Der derivative2
            annotation (extent=[0,-90; 20,-70],    rotation=0);
        equation
          connect(derivative.u, feedback_lean.y)
                                            annotation (points=[-2,-24; -10,-24;
                -10,0; -21,0],           style(color=74, rgbcolor={0,0,127}));
          connect(derivative1.u, feedback_steer.y)
                                              annotation (points=[-2,20; -11,20;
                -11,46; -21,46],        style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer, feedback_steer.u1)
                                                  annotation (points=[-49,46;
                -38,46],                                        style(color=74,
                rgbcolor={0,0,127}));
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=67,
                  rgbfillColor={170,255,255})),
              Text(
                extent=[-100,-90; 98,-150],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-70,42; 70,-98], style(color=1, rgbcolor={255,0,0})),
              Rectangle(extent=[-98,2; 98,-98], style(
                  pattern=0,
                  fillColor=67,
                  rgbfillColor={170,255,255})),
              Ellipse(extent=[12,90; 40,62],  style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Line(points=[-20,0; -20,6; 20,6; 20,0],     style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Rectangle(extent=[-2,-24; 2,-88],style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=10,
                  rgbfillColor={95,95,95},
                  fillPattern=1)),
              Polygon(points=[-68,-9; -68,5; -58,1; -68,-9], style(color=1,
                    rgbcolor={255,0,0})),
              Polygon(points=[68,-10; 58,0; 68,4; 68,-10], style(color=1,
                    rgbcolor={255,0,0})),
              Line(points=[0,6; 0,-88],  style(color=0, rgbcolor={0,0,0})),
              Line(points=[20,64; 0,6],  style(color=0, rgbcolor={0,0,0}))),
            Coordsys(scale=0.15));
          connect(lean2steer.v, v) annotation (points=[-72,40; -90,40; -90,60;
                -120,60],                                                style(
                color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u1, phi_set)
                                        annotation (points=[-38,0; -80,0; -80,
                20; -120,20],   style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.lean, phi_set) annotation (points=[-72,52; -80,52;
                -80,20; -120,20],   style(color=74, rgbcolor={0,0,127}));
          connect(feedback_steer.u2, delta)
                                       annotation (points=[-30,54; -30,100;
                -120,100],
                     style(color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u2, phi)
                                    annotation (points=[-30,-8; -30,-20; -120,
                -20], style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController1.SteeringTorque, T_steer) annotation (
              points=[85.5,17; 90,17; 90,40; 110,40],
                                                    style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(T_Rider, stateSpaceController1.RiderLeanTorque) annotation (
              points=[110,-40; 90,-40; 90,5; 85.5,5],   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(stateSpaceController1.SteerAngle, feedback_steer.y)
                                                                 annotation (
              points=[51,26; 32,26; 32,46; -21,46], style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(stateSpaceController1.SteerRate, derivative1.y) annotation (
              points=[51,20; 21,20],
                                   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(stateSpaceController1.LeanAngle, feedback_lean.y)
                                                               annotation (points=[51,14;
                26,14; 26,0; -21,0],          style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(derivative.y, stateSpaceController1.LeanRate) annotation (
              points=[21,-24; 32,-24; 32,8; 51,8],   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(phi_rider_set, feedback_rider.u1)
                                               annotation (points=[-120,-60;
                -38,-60],
                      style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(feedback_rider.y, stateSpaceController1.RiderLeanAngle)
                                                                     annotation (
              points=[-21,-60; 38,-60; 38,2; 51,2],   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(derivative2.y, stateSpaceController1.RiderLeanRate) annotation (
             points=[21,-80; 44,-80; 44,-4; 51,-4],   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(derivative2.u, feedback_rider.y)
                                              annotation (points=[-2,-80; -10,
                -80; -10,-60; -21,-60],
                                   style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));
          connect(feedback_rider.u2, phi_rider)
                                           annotation (points=[-30,-68; -30,
                -100; -120,-100],
                            style(
              color=74,
              rgbcolor={0,0,127},
              fillPattern=1));

        end LQR_VMR;

        package StabilityControl
          model StateSpaceController

            // The controller matrix is calcutated with Matlab
            parameter Real F[2,6] = [ 34.2606,    1.6523,   22.7179,    3.4349,   10.2637,    3.1373;
                                     118.7795,   29.6039,  169.5166,   64.2751,  246.6806,   84.0309];

            Modelica.Blocks.Interfaces.RealInput SteerRate
              annotation (extent=[-140,40; -100,80]);
            Modelica.Blocks.Interfaces.RealInput LeanAngle
              annotation (extent=[-140,0; -100,40]);
            Modelica.Blocks.Interfaces.RealOutput SteeringTorque
              annotation (extent=[100,30; 120,50]);
            Modelica.Blocks.Interfaces.RealOutput RiderLeanTorque
              annotation (extent=[100,-50; 120,-30]);
            annotation (Diagram, DymolaStoredErrors,
              Icon(
                Rectangle(extent=[-100,100; 100,-100], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255})),
                Text(extent=[-90,10; -10,90],   string="A",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[0,-90; 0,90],   style(color=8)),
                Text(extent=[10,10; 90,90],   string="B",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[-90,-10; -10,-90],   string="C",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[10,-10; 90,-90],   string="D",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[-90,0; 90,0],   style(color=8)),
                Text(
                  extent=[-100,100; 100,-100],
                  string="F",
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=30,
                    rgbfillColor={215,215,215},
                    fillPattern=1))));

            Modelica.Blocks.Interfaces.RealInput SteerAngle
              annotation (extent=[-140,80; -100,120]);
            Modelica.Blocks.Interfaces.RealInput LeanRate
              annotation (extent=[-140,-40; -100,0]);
            Modelica.Blocks.Interfaces.RealInput RiderLeanAngle
              annotation (extent=[-140,-80; -100,-40]);
            Modelica.Blocks.Interfaces.RealInput RiderLeanRate
              annotation (extent=[-140,-120; -100,-80]);
          equation
            // T = F*X
            // T ... Torque input
            // F ... Feedback matrix
            // X ... State vector

           {SteeringTorque, RiderLeanTorque} = F*{SteerAngle, SteerRate, LeanAngle, LeanRate, RiderLeanAngle, RiderLeanRate};

          end StateSpaceController;

          model LQRController

            // The controller matrix is calcutated with Matlab
            parameter Real F[2,6] = [ 28.1962,    2.5176,   51.0262,    7.3671,  -33.9664,   -9.0695;
                                     -14.2983,   -0.6687,    3.7947,   11.6672,   78.9845,   23.2098];

            Modelica.Blocks.Interfaces.RealInput SteerRate
              annotation (extent=[-140,40; -100,80]);
            Modelica.Blocks.Interfaces.RealInput LeanAngle
              annotation (extent=[-140,0; -100,40]);
            Modelica.Blocks.Interfaces.RealOutput SteeringTorque
              annotation (extent=[100,30; 120,50]);
            Modelica.Blocks.Interfaces.RealOutput RiderLeanTorque
              annotation (extent=[100,-50; 120,-30]);
            annotation (Diagram, DymolaStoredErrors,
              Icon(
                Rectangle(extent=[-100,100; 100,-100], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255})),
                Text(extent=[-90,10; -10,90],   string="A",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[0,-90; 0,90],   style(color=8)),
                Text(extent=[10,10; 90,90],   string="B",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[-90,-10; -10,-90],   string="C",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[10,-10; 90,-90],   string="D",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[-90,0; 90,0],   style(color=8)),
                Text(
                  extent=[-100,100; 100,-100],
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1),
                  string="LQR")));

            Modelica.Blocks.Interfaces.RealInput SteerAngle
              annotation (extent=[-140,80; -100,120]);
            Modelica.Blocks.Interfaces.RealInput LeanRate
              annotation (extent=[-140,-40; -100,0]);
            Modelica.Blocks.Interfaces.RealInput RiderLeanAngle
              annotation (extent=[-140,-80; -100,-40]);
            Modelica.Blocks.Interfaces.RealInput RiderLeanRate
              annotation (extent=[-140,-120; -100,-80]);
          equation
            // T = F*X
            // T ... Torque input
            // F ... Feedback matrix
            // X ... State vector

           {SteeringTorque, RiderLeanTorque} = F*{SteerAngle, SteerRate, LeanAngle, LeanRate, RiderLeanAngle, RiderLeanRate};

          end LQRController;
          annotation (Icon(
              Rectangle(extent=[-100,-100; 80,50], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Text(
                extent=[-85,35; 65,-85],
                string="Library",
                style(color=45, rgbcolor={255,128,0})),
              Text(
                extent=[-120,122; 120,73],
                string="%name",
                style(color=45, rgbcolor={255,128,0}))));
        end StabilityControl;
      end RollAngleTracking;

      annotation (Icon);
      package PathTracking
        model StateSpace_PT_VMR

          parameter Real F[1,6] = [0, 0, 2621.139060072288, 51.644789540803, 1394.263296471545, 111.065024150724]
            "state feedback matrix";

          Modelica.Blocks.Continuous.Derivative derivative(T=1e-6)
            annotation (extent=[-20,-50; 0,-30],   rotation=0);
          Modelica.Blocks.Continuous.Derivative derivative1(T=1e-6)
            annotation (extent=[-20,-13; 0,7],     rotation=0);
          Modelica.Blocks.Math.Feedback feedback_lean
            annotation (extent=[-80,-30; -60,-10]);
          Modelica.Blocks.Math.Feedback feedback_steer
            annotation (extent=[-50,26; -30,6],    rotation=0);
          MotorcycleLib.VirtualRider.Utilities.lean2steer lean2steer
                                        annotation (extent=[-84,6; -64,26]);
          Modelica.Blocks.Interfaces.RealInput v "velocity"
            annotation (extent=[-150,-10; -110,30]);
          Modelica.Blocks.Interfaces.RealInput phi_set "lean angle set point"
            annotation (extent=[-150,-40; -110,0]);
          Modelica.Blocks.Interfaces.RealOutput T_steer "steering torque"
            annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Interfaces.RealInput delta "steer angle "
            annotation (extent=[-150,20; -110,60]);
          Modelica.Blocks.Interfaces.RealInput phi "lean angle"
            annotation (extent=[-150,-70; -110,-30]);
          Modelica.Blocks.Interfaces.RealInput xlat "absolute lateral position"
            annotation (extent=[-150,50; -110,90]);
          Modelica.Blocks.Continuous.Derivative derivative2(T=1e-6)
            annotation (extent=[-20,50; 0,70],     rotation=0);
          Modelica.Blocks.Interfaces.RealInput xlat_set
            "set point lateral position" annotation (extent=[-150,80; -110,120]);
          Modelica.Blocks.Math.Feedback feedback_pos
            annotation (extent=[-50,76; -30,96],   rotation=0);
          PathTrackingControl.StateSpace_PT_Controller stateSpace_PT_Controller
            annotation (extent=[38,-27; 80,15]);
          Modelica.Blocks.Math.Feedback feedback_rider
            annotation (extent=[-80,-90; -60,-70]);
          Modelica.Blocks.Interfaces.RealInput lean_rider_set
            "set value of rider's lean angle"
            annotation (extent=[-150,-100; -110,-60]);
          Modelica.Blocks.Interfaces.RealInput lean_rider "rider's lean angle"
            annotation (extent=[-150,-130; -110,-90]);
          Modelica.Blocks.Continuous.Derivative derivative3(
                                                           T=1e-6)
            annotation (extent=[-20,-106; 0,-86],  rotation=0);
        equation
          connect(derivative.u, feedback_lean.y)
                                            annotation (points=[-22,-40; -30,
                -40; -30,-20; -61,-20],  style(color=74, rgbcolor={0,0,127}));
          connect(derivative1.u, feedback_steer.y)
                                              annotation (points=[-22,-3; -28,
                -3; -28,16; -31,16],    style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer, feedback_steer.u1)
                                                  annotation (points=[-63,16;
                -48,16],                                        style(color=74,
                rgbcolor={0,0,127}));
          annotation (
            Diagram,
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=59,
                  rgbfillColor={85,255,85})),
              Text(
                extent=[-100,-90; 98,-150],
                string="%name",
                style(color=3, rgbcolor={0,0,255})),
              Line(points=[-80,0; -30,0], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Ellipse(extent=[76,4; 84,-4], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Rectangle(extent=[-92,2; -68,-2], style(color=3, rgbcolor={0,0,255})),
              Rectangle(extent=[-42,2; -18,-2], style(color=3, rgbcolor={0,0,255})),
              Line(points=[-50,-10; -46,-10; -46,10; -50,10], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Line(points=[-20,0; 80,0], style(
                  color=1,
                  rgbcolor={255,0,0},
                  fillPattern=1)),
              Line(points=[-20,0; 18,-4; 48,-10; 80,-24], style(
                  color=10,
                  rgbcolor={95,95,95},
                  fillColor=42,
                  rgbfillColor={127,0,0},
                  fillPattern=1)),
              Ellipse(extent=[76,-20; 84,-28], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=9,
                  rgbfillColor={175,175,175},
                  fillPattern=1))),
            Coordsys(scale=0.15, extent=[-110,-110; 100,100]));
          connect(lean2steer.v, v) annotation (points=[-86,10; -130,10], style(
                color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u1, phi_set)
                                        annotation (points=[-78,-20; -130,-20],
                                style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.lean, phi_set) annotation (points=[-86,22; -100,22;
                -100,-20; -130,-20],style(color=74, rgbcolor={0,0,127}));
          connect(feedback_steer.u2, delta)
                                       annotation (points=[-40,24; -40,40; -130,
                40], style(color=74, rgbcolor={0,0,127}));
          connect(feedback_lean.u2, phi)
                                    annotation (points=[-70,-28; -70,-50; -130,
                -50], style(color=74, rgbcolor={0,0,127}));
          connect(feedback_pos.u1, xlat_set) annotation (points=[-48,86; -70,86;
                -70,100; -130,100], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(feedback_pos.u2, xlat) annotation (points=[-40,78; -40,70;
                -130,70],
                     style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));
          connect(derivative2.u, feedback_pos.y) annotation (points=[-22,60;
                -28,60; -28,86; -31,86],
                                     style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=60,
              rgbfillColor={170,255,170},
              fillPattern=1));

          connect(stateSpace_PT_Controller.SteeringTorque, T_steer) annotation (
             points=[82,-5; 96,-5; 96,0; 110,0], style(color=74, rgbcolor={0,0,
                  127}));
          connect(stateSpace_PT_Controller.xlat, feedback_pos.y) annotation (
              points=[34,15; 18,15; 18,86; -31,86], style(color=74, rgbcolor={0,
                  0,127}));
          connect(derivative2.y, stateSpace_PT_Controller.der_xlat) annotation (
             points=[1,60; 12,60; 12,9; 34,9], style(color=74, rgbcolor={0,0,
                  127}));
          connect(stateSpace_PT_Controller.phi_steer, feedback_steer.y)
            annotation (points=[34,3; 6,3; 6,16; -31,16], style(color=74,
                rgbcolor={0,0,127}));
          connect(derivative1.y, stateSpace_PT_Controller.der_phi_steer)
            annotation (points=[1,-3; 34,-3], style(color=74, rgbcolor={0,0,127}));
          connect(stateSpace_PT_Controller.phi_lean, feedback_lean.y)
            annotation (points=[34,-9; 6,-9; 6,-20; -61,-20], style(color=74,
                rgbcolor={0,0,127}));
          connect(derivative.y, stateSpace_PT_Controller.der_phi_lean)
            annotation (points=[1,-40; 12,-40; 12,-15; 34,-15], style(color=74,
                rgbcolor={0,0,127}));
          connect(feedback_rider.u1, lean_rider_set)
                                                    annotation (points=[-78,-80;
                -130,-80], style(color=74, rgbcolor={0,0,127}));
          connect(lean_rider, feedback_rider.u2)
                                                annotation (points=[-130,-110;
                -70,-110; -70,-88], style(color=74, rgbcolor={0,0,127}));
          connect(feedback_rider.y, stateSpace_PT_Controller.lean_rider)
            annotation (points=[-61,-80; 18,-80; 18,-21; 34,-21], style(color=
                  74, rgbcolor={0,0,127}));
          connect(derivative3.u, feedback_rider.y)
                                                  annotation (points=[-22,-96;
                -30,-96; -30,-80; -61,-80], style(color=74, rgbcolor={0,0,127}));
          connect(derivative3.y, stateSpace_PT_Controller.der_lean_rider)
            annotation (points=[1,-96; 24,-96; 24,-27; 34,-27], style(color=74,
                rgbcolor={0,0,127}));
        end StateSpace_PT_VMR;

        package PathTrackingControl
          model StateSpace_PT_Controller
            "State Space Controller including lateral position, lean angle, steer angle and their derivatives as states"

            // The controller matrix is calcutated with Matlab
            parameter Real F[2,6] = [ 34.2606,    1.6523,   22.7179,    3.4349,   10.2637,    3.1373, 3.1373;
                                     118.7795,   29.6039,  169.5166,   64.2751,  246.6806,   84.0309, 84.0309];

            Modelica.Blocks.Interfaces.RealInput phi_lean "lean angle"
              annotation (extent=[-150,-40; -110,0]);
            Modelica.Blocks.Interfaces.RealInput der_phi_steer "steer rate"
              annotation (extent=[-150,-10; -110,30]);
            Modelica.Blocks.Interfaces.RealOutput SteeringTorque
              annotation (extent=[100,-10; 120,10]);
            annotation (Diagram, DymolaStoredErrors,
              Icon(
                Rectangle(extent=[-110,100; 100,-110], style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255})),
                Text(extent=[-94,4; -14,84],    string="A",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[-4,-96; -4,84], style(color=8)),
                Text(extent=[6,4; 86,84],     string="B",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[-94,-16; -14,-96],   string="C",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Text(extent=[6,-16; 86,-96],    string="D",
                  style(
                    color=30,
                    rgbcolor={215,215,215},
                    fillColor=30,
                    rgbfillColor={215,215,215})),
                Line(points=[-94,-6; 86,-6], style(color=8)),
                Text(
                  extent=[-110,100; 100,-110],
                  string="F",
                  style(
                    color=0,
                    rgbcolor={0,0,0},
                    fillColor=7,
                    rgbfillColor={255,255,255},
                    fillPattern=1))),
              Coordsys(scale=0.2, extent=[-110,-110; 100,100]));

            Modelica.Blocks.Interfaces.RealInput phi_steer "steer angle"
              annotation (extent=[-150,20; -110,60]);
            Modelica.Blocks.Interfaces.RealInput der_phi_lean "lean rate"
              annotation (extent=[-150,-70; -110,-30]);
            Modelica.Blocks.Interfaces.RealInput der_xlat
              "absolute lateral rate"
              annotation (extent=[-150,50; -110,90]);
            Modelica.Blocks.Interfaces.RealInput xlat
              "absolute lateral position"
              annotation (extent=[-150,80; -110,120]);
            Modelica.Blocks.Interfaces.RealInput lean_rider
              "lean angle of the rider rel. to the rear frame"
              annotation (extent=[-150,-100; -110,-60]);
            Modelica.Blocks.Interfaces.RealInput der_lean_rider
              "lean angle of the rider rel. to the rear frame"
              annotation (extent=[-150,-130; -110,-90]);
          equation
            // T = F*X
            // T ... Torque input
            // F ... Feedback matrix
            // X ... State vector

            {SteeringTorque, RiderLeanTorque} = F*{phi_steer, der_phi_steer, phi_lean, der_phi_lean, lean_rider, der_lean_rider, xlat, der_xlat};

          end StateSpace_PT_Controller;
          annotation (Icon(
              Rectangle(extent=[-100,-100; 80,50], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
                  color=45,
                  rgbcolor={255,128,0},
                  fillColor=30,
                  rgbfillColor={235,235,235},
                  fillPattern=1)),
              Text(
                extent=[-85,35; 65,-85],
                string="Library",
                style(color=45, rgbcolor={255,128,0})),
              Text(
                extent=[-120,122; 120,73],
                string="%name",
                style(color=45, rgbcolor={255,128,0}))));
        end PathTrackingControl;
      end PathTracking;
    end VirtualMovableRider;

    package VelocityControl
      model SpeedController "Classic PI speed controller"

        import SI = Modelica.SIunits;

      parameter Real k = 800 "Gain";
      parameter SI.Time T = 50 "Time Constant";

      parameter SI.Distance r = 0.305
          "Rear wheel radius to calculate w (v = w r)";

        Modelica.Blocks.Math.Gain v_to_w(k=1/r)
          annotation (extent=[-60,-10; -40,10]);
        Modelica.Blocks.Math.Feedback feedback2
          annotation (extent=[-10,-10; 10,10]);
        Modelica.Blocks.Continuous.PI PI(k=k, T=T)
          annotation (extent=[40,-10; 60,10]);
        Modelica.Blocks.Interfaces.RealInput v "motorcycle's forward velocity"
          annotation (extent=[-140,-20; -100,20]);
        Modelica.Blocks.Interfaces.RealInput w
          "angular velocity of the rear wheel"
          annotation (extent=[-20,-140; 20,-100], rotation=90);
        Modelica.Blocks.Interfaces.RealOutput T_engine "Required engine torque"
          annotation (extent=[100,-10; 120,10]);
      equation
        connect(feedback2.u1, v_to_w.y)
                                      annotation (points=[-8,0; -39,0],
            style(color=74, rgbcolor={0,0,127}));
        connect(PI.u,feedback2. y) annotation (points=[38,0; 9,0],        style(
              color=74, rgbcolor={0,0,127}));
        annotation (Diagram, Icon(
            Rectangle(extent=[-100,100; 100,-100], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,146; 100,100],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Polygon(points=[-80,88; -88,66; -72,66; -80,88],     style(color=8,
                   fillColor=8)),
            Line(points=[-80,-90; -80,66],   style(color=8)),
            Line(points=[-92,-80; 66,-80],
                                         style(color=8)),
            Polygon(points=[88,-80; 66,-72; 66,-88; 88,-80],
                                                          style(color=8,
                  fillColor=8)),
            Line(points=[-80,28; 78,28], style(
                color=1,
                rgbcolor={255,0,0},
                pattern=3,
                fillPattern=1)),
            Line(points=[-80,-80; -62,-20; -56,-2; -52,4; -46,12; -42,16; -30,
                  22; -10,26; 12,28; 30,28; 50,28; 58,28; 58,28; 80,28; 96,28],
                style(
                color=0,
                rgbcolor={0,0,0},
                fillPattern=1))));
        connect(PI.y, T_engine) annotation (points=[61,0; 110,0], style(color=
                74, rgbcolor={0,0,127}));
        connect(v_to_w.u, v)
                           annotation (points=[-62,0; -120,0], style(color=74,
              rgbcolor={0,0,127}));
        connect(w, feedback2.u2) annotation (points=[0,-120; 0,-8], style(color=
               74, rgbcolor={0,0,127}));
      end SpeedController;
    end VelocityControl;

    package MiscController "miscellaneous controller"

      model StateSpaceController
        "Velocity and stability control via a state space controller"

        // The controller matrix is calcutated with Matlab
        // A detailed description can be found in the information section of the State Space Controller
        parameter Real F[2,4] = [0.0357, 0.0071, 1.1095, 0.2717; 1.2524, 0.3757, 0.1642, 0.0392]*1000;

        Modelica.Blocks.Interfaces.RealInput w
          annotation (extent=[-140,10; -100,50]);
        Modelica.Blocks.Interfaces.RealInput LeanAngle
          annotation (extent=[-140,-50; -100,-10]);
        Modelica.Blocks.Interfaces.RealOutput SteeringTorque
          annotation (extent=[100,30; 120,50]);
        Modelica.Blocks.Interfaces.RealOutput EngineTorque
          annotation (extent=[100,-50; 120,-30]);
        annotation (Diagram, DymolaStoredErrors,
          Icon(
            Rectangle(extent=[-100,100; 100,-100], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(extent=[-90,10; -10,90],   string="A",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Line(points=[0,-90; 0,90],   style(color=8)),
            Text(extent=[10,10; 90,90],   string="B",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Text(extent=[-90,-10; -10,-90],   string="C",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Text(extent=[10,-10; 90,-90],   string="D",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Line(points=[-90,0; 90,0],   style(color=8)),
            Text(
              extent=[-100,100; 100,-100],
              string="F",
              style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1))));

        Modelica.Blocks.Interfaces.RealInput phi
          annotation (extent=[-140,60; -100,100]);
        Modelica.Blocks.Interfaces.RealInput LeanRate
          annotation (extent=[-140,-100; -100,-60]);
      equation
        // T = F*X
        // T ... Torque input
        // F ... Feedback matrix
        // X ... State vector

        {SteeringTorque, EngineTorque} = F*{phi, w, LeanAngle, LeanRate};

      end StateSpaceController;

      model StateSpace_LeanLateral
        "State Space Controller including lean angle, lean rate and lateral displacement as states"

        // The controller matrix is calcutated with Matlab
        // A detailed description can be found in the information section of the State Space Controller
        parameter Real F[1,3] = [0,  384.1428,  119.0735];

        Modelica.Blocks.Interfaces.RealInput y "absolute lateral displacement"
          annotation (extent=[-140,-100; -100,-60]);
        Modelica.Blocks.Interfaces.RealInput der_phi "derivative of lean angle"
          annotation (extent=[-140,0; -100,40]);
        Modelica.Blocks.Interfaces.RealOutput SteeringTorque
          annotation (extent=[100,-10; 120,10]);
        annotation (Diagram, DymolaStoredErrors,
          Icon(
            Rectangle(extent=[-100,100; 100,-100], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(extent=[-90,10; -10,90],   string="A",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Line(points=[0,-90; 0,90],   style(color=8)),
            Text(extent=[10,10; 90,90],   string="B",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Text(extent=[-90,-10; -10,-90],   string="C",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Text(extent=[10,-10; 90,-90],   string="D",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Line(points=[-90,0; 90,0],   style(color=8)),
            Text(
              extent=[-100,100; 100,-100],
              string="F",
              style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1))));

        Modelica.Blocks.Interfaces.RealInput phi "lean angle"
          annotation (extent=[-140,60; -100,100]);
      equation
        // T = F*X
        // T ... Torque input
        // F ... Feedback matrix
        // X ... State vector

        {SteeringTorque} = F*{y, phi, der_phi};

      end StateSpace_LeanLateral;

      model LQR_Controller
        "a state space controller for stability and path tracking based on a linear quadratic regulator"

        // The controller matrix is calcutated with Matlab
        // A detailed description can be found in the information section of the LQR Controller
        parameter Real F[1,4] = [-0.2000, -1.7276, 0.2167, 0.5523]*10000;

        Modelica.Blocks.Interfaces.RealInput y "absolute lateral displacement"
          annotation (extent=[-140,60; -100,100]);
        Modelica.Blocks.Interfaces.RealInput der_phi "derivative of lean angle"
          annotation (extent=[-140,-100; -100,-60]);
        Modelica.Blocks.Interfaces.RealOutput SteeringTorque
          annotation (extent=[100,-10; 120,10]);
        annotation (Diagram, DymolaStoredErrors,
          Icon(
            Text(extent=[-90,10; -10,90],   string="A",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Line(points=[0,-90; 0,90],   style(color=8)),
            Text(extent=[10,10; 90,90],   string="B",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Text(extent=[-90,-10; -10,-90],   string="C",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Text(extent=[10,-10; 90,-90],   string="D",
              style(
                color=30,
                rgbcolor={215,215,215},
                fillColor=30,
                rgbfillColor={215,215,215})),
            Line(points=[-90,0; 90,0],   style(color=8)),
            Rectangle(extent=[-100,100; 100,-100], style(color=0, rgbcolor={0,0,
                    0})),
            Text(
              extent=[-80,80; 80,-80],
              style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=30,
                rgbfillColor={215,215,215},
                fillPattern=1),
              string="LQR")));

        Modelica.Blocks.Interfaces.RealInput der_y
          "derivative of absolute lateral displacement"
          annotation (extent=[-140,10; -100,50]);
        Modelica.Blocks.Interfaces.RealInput phi "lean angle"
          annotation (extent=[-140,-50; -100,-10]);
      equation
        // T = F*X
        // T ... Torque input
        // F ... Feedback matrix
        // X ... State vector

        {SteeringTorque} = F*{y, der_y, phi, der_phi};

      end LQR_Controller;
    end MiscController;

    package Utilities
      annotation (Icon(
          Rectangle(extent=[-100,-100; 80,50], style(
              color=42,
              rgbcolor={127,0,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
              color=42,
              rgbcolor={127,0,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
              color=42,
              rgbcolor={127,0,0},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Text(
            extent=[-85,35; 65,-85],
            string="Library",
            style(color=42, rgbcolor={127,0,0})),
          Text(
            extent=[-120,122; 120,73],
            string="%name",
            style(color=1))));
      model lean2steer "Calculation of the steer angle for a given lean angle"

        import SI = Modelica.SIunits;
        import CO = Modelica.SIunits.Conversions;
        import MA = Modelica.Math;

        parameter SI.Distance p = 1.414 "wheel base";

        parameter CO.NonSIunits.Angle_deg eps = 27
          "Caster angle (Steering head angle)";
        final parameter SI.Angle eps_rad = CO.from_deg(eps);

        SI.Distance R "Curve radius";

      equation
        R = noEvent( if abs(lean) < 10e-6 then 0 else v^2 / (9.81*tan(lean)));
        steer = noEvent( if abs(R) < 10e-6 then 0 else MA.atan(-p*cos(lean) / (R*cos(eps_rad))));

      public
        Modelica.Blocks.Interfaces.RealInput lean
          annotation (extent=[-140,40; -100,80]);
        Modelica.Blocks.Interfaces.RealOutput steer
          annotation (extent=[100,-10; 120,10]);
        annotation (Diagram, Icon(
            Rectangle(extent=[-100,100; 100,-100], style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[-100,-100; 100,-140],
              string="Lean2Steer",
              style(color=3, rgbcolor={0,0,255})),
            Line(points=[-64,46; -64,-12],
                                       style(color=0, rgbcolor={0,0,0})),
            Rectangle(extent=[-66,-12; -62,-64], style(pattern=0)),
            Line(points=[-80,16; -80,22; -48,22; -48,16],
                                                        style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Ellipse(extent=[-74,66; -54,46], style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[1,-19; -9,-9],     style(color=0, rgbcolor={0,0,0})),
            Line(points=[-4,-14; 52,16],style(color=0, rgbcolor={0,0,0})),
            Line(points=[23,0; 23,18],   style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[27,17; 20,24],     style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[-24,6; 16,-34], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[71,-19; 61,-9],    style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[46,6; 86,-34], style(color=3, rgbcolor={0,0,255})),
            Line(points=[66,-14; 42,42; 36,42], style(color=0, rgbcolor={0,0,0})),
            Line(points=[-60,-64; -68,-12; -72,-14; -64,-66; -60,-64], style(color=10,
                  rgbcolor={135,135,135})),
            Line(points=[-70,-14; -80,44], style(color=10, rgbcolor={135,135,135})),
            Ellipse(extent=[-92,62; -72,42], style(color=10, rgbcolor={135,135,
                    135})),
            Line(points=[-58,16; -60,22; -92,16; -90,10], style(color=10,
                  rgbcolor={135,135,135})),
            Ellipse(extent=[52,6; 80,-34], style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0)),
            Ellipse(extent=[70,-8; 62,-20], style(color=9, rgbcolor={175,175,175})),
            Line(points=[66,-14; 44,40; 44,40], style(color=9, rgbcolor={175,175,
                    175})),
            Line(points=[26,46; 32,46; 56,34; 50,34], style(color=9, rgbcolor={
                    175,175,175}))),
          Coordsys(scale=0.1));
        Modelica.Blocks.Interfaces.RealInput v
          annotation (extent=[-140,-80; -100,-40]);
      equation

      end lean2steer;

      model lean2steer_simple
        "Calculation of the steer angle for a given lean angle"

        import SI = Modelica.SIunits;
        import CO = Modelica.SIunits.Conversions;
        import MA = Modelica.Math;

        parameter SI.Distance p = 1.414 "wheel base";

        parameter CO.NonSIunits.Angle_deg eps = 27
          "Caster angle (Steering head angle)";
        final parameter SI.Angle eps_rad = CO.from_deg(eps);

        SI.Distance R "Curve radius";

      equation
        R = noEvent( if abs(lean) < 10e-6 then 0 else v^2 / (9.81*tan(lean)));
        steer = noEvent( if abs(R) < 10e-6 then 0 else MA.atan(-p / (R*cos(eps_rad))));

      public
        Modelica.Blocks.Interfaces.RealInput lean
          annotation (extent=[-140,40; -100,80]);
        Modelica.Blocks.Interfaces.RealOutput steer
          annotation (extent=[100,-10; 120,10]);
        annotation (Diagram, Icon(
            Text(
              extent=[-100,-100; 100,-140],
              string="Lean2Steer",
              style(color=3, rgbcolor={0,0,255})),
            Text(
              extent=[-100,-100; 100,-140],
              string="Lean2Steer",
              style(color=3, rgbcolor={0,0,255})),
            Rectangle(extent=[-100,100; 100,-100], style(color=0, rgbcolor={0,0,0})),
            Text(
              extent=[-100,-100; 100,-140],
              string="Lean2Steer",
              style(color=3, rgbcolor={0,0,255})),
            Line(points=[-64,46; -64,-12],
                                       style(color=0, rgbcolor={0,0,0})),
            Rectangle(extent=[-66,-12; -62,-64], style(pattern=0)),
            Line(points=[-80,16; -80,22; -48,22; -48,16],
                                                        style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Ellipse(extent=[-74,66; -54,46], style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[1,-19; -9,-9],     style(color=0, rgbcolor={0,0,0})),
            Line(points=[-4,-14; 52,16],style(color=0, rgbcolor={0,0,0})),
            Line(points=[23,0; 23,18],   style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[27,17; 20,24],     style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[-24,6; 16,-34], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[71,-19; 61,-9],    style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[46,6; 86,-34], style(color=3, rgbcolor={0,0,255})),
            Line(points=[66,-14; 42,42; 36,42], style(color=0, rgbcolor={0,0,0})),
            Line(points=[-60,-64; -68,-12; -72,-14; -64,-66; -60,-64], style(color=10,
                  rgbcolor={135,135,135})),
            Line(points=[-70,-14; -80,44], style(color=10, rgbcolor={135,135,135})),
            Ellipse(extent=[-92,62; -72,42], style(color=10, rgbcolor={135,135,
                    135})),
            Line(points=[-58,16; -60,22; -92,16; -90,10], style(color=10,
                  rgbcolor={135,135,135})),
            Ellipse(extent=[52,6; 80,-34], style(
                color=9,
                rgbcolor={175,175,175},
                pattern=0)),
            Ellipse(extent=[70,-8; 62,-20], style(color=9, rgbcolor={175,175,175})),
            Line(points=[66,-14; 44,40; 44,40], style(color=9, rgbcolor={175,175,
                    175})),
            Line(points=[26,46; 32,46; 56,34; 50,34], style(color=9, rgbcolor={
                    175,175,175}))));
        Modelica.Blocks.Interfaces.RealInput v
          annotation (extent=[-140,-80; -100,-40]);
      equation

      end lean2steer_simple;
    end Utilities;
  end VirtualRider;

  package Environments "Several Tracks; open-loop and closed-loop method"

  annotation (
  Documentation(info="<html>
A detailed description of the models can be found in:
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Environments\">UsersGuide.Overview.Environments</a>]</span>

</html>"), Icon);

    package Tracks "Tracks based on open-loop and closed-loop methods"
      package OpenLoopMethod
        "provides different standard tracks (e.g. 90° curve, S shikane)"
        model Curve_90degree
          import SI = Modelica.SIunits;

          parameter SI.Velocity v "Velocity of the vehicle";
          final parameter SI.Length R = 25 "Curve radius";

          parameter Real table[:,:]
            "Insert either roll angle values as a function of the current location phi = f(x) or a record";

          Modelica.Blocks.Math.Product product
            annotation (extent=[-40,-10; -20,10],    rotation=0);
          Modelica.Blocks.Sources.Clock clock
            annotation (extent=[-90,-30; -70,-10]);
          MotorcycleLib.Visualisation.RoadGraphics.Road_90degree_curve
            road_90degree_curve
            annotation (extent=[0,40; 20,60]);
          Modelica.Blocks.Interfaces.RealOutput leanAngle
            "lean angle of the rear frame" annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Tables.CombiTable1Ds combiTable1Ds(
              smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments, table=
                table)  annotation (extent=[0,-10; 20,10]);
          Modelica.Blocks.Sources.Constant const(k=v)
            annotation (extent=[-90,10; -70,30]);
        equation
          connect(clock.y,product. u2) annotation (points=[-69,-20; -54,-20;
                -54,-6; -42,-6],
                           style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=30,
              rgbfillColor={215,215,215},
              fillPattern=1));
          annotation (Diagram(
              Rectangle(extent=[-12,68; 32,-18], style(
                  color=9,
                  rgbcolor={175,175,175},
                  thickness=4)),
              Line(points=[10,18; 10,38], style(
                  color=10,
                  rgbcolor={95,95,95},
                  arrow=2,
                  fillPattern=1)),
              Text(
                extent=[-52,-22; 82,-34],
                string=
                    "table includes the lean angle as a function of the current position",
                style(
                  color=10,
                  rgbcolor={95,95,95},
                  arrow=2,
                  fillPattern=1)),
              Text(
                extent=[-45,-34; 65,-40],
                style(
                  color=10,
                  rgbcolor={95,95,95},
                  arrow=2,
                  fillPattern=1),
                string="lean angle = f(x), where x = v t")),
                               Icon(
                           Bitmap(extent=[-122,100; 122,-100],
                                                            name="Images/10.png"), Text(
                extent=[-100,-90; 100,-138],
                style(
                  color=3,
                  rgbcolor={0,0,255},
                  fillColor=7,
                  rgbfillColor={255,255,255},
                  fillPattern=1),
                string="%name")));
          connect(product.y, combiTable1Ds.u) annotation (points=[-19,0; -2,0],   style(
                color=74, rgbcolor={0,0,127}));

          connect(combiTable1Ds.y[1], leanAngle) annotation (points=[21,0; 110,
                0],                      style(color=74, rgbcolor={0,0,127}));
          connect(const.y, product.u1) annotation (points=[-69,20; -54,20; -54,
                6; -42,6],
                        style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
        end Curve_90degree;

        model S_Chicane
          import SI = Modelica.SIunits;
          final parameter SI.Length R = 11;
          parameter SI.Velocity v;

          Modelica.Blocks.Math.Product product
            annotation (extent=[-40,-10; -20,10],    rotation=0);
          Modelica.Blocks.Sources.Clock clock
            annotation (extent=[-90,-30; -70,-10]);
          Modelica.Blocks.Interfaces.RealOutput leanAngle
            "lean angle of the rear frame" annotation (extent=[76,-10; 96,10]);
          Modelica.Blocks.Tables.CombiTable1Ds combiTable1Ds(table=[0,0; 21,0; 24,
                Modelica.Math.atan(v^2/(R*9.81)); 38,Modelica.Math.atan(v^2/(R*
                9.81)); 40,0; 76,0])
                        annotation (extent=[0,-10; 20,10]);
          Modelica.Blocks.Sources.Constant const(k=v)
            annotation (extent=[-90,10; -70,30]);
          Visualisation.RoadGraphics.S_Shikane s_Shikane
            annotation (extent=[-90,60; -70,80]);
        equation
          connect(clock.y,product. u2) annotation (points=[-69,-20; -52,-20;
                -52,-6; -42,-6],
                           style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=30,
              rgbfillColor={215,215,215},
              fillPattern=1));
          annotation (Diagram, Icon(                                               Text(
                extent=[-100,-90; 100,-138],
                style(
                  color=3,
                  rgbcolor={0,0,255},
                  fillColor=7,
                  rgbfillColor={255,255,255},
                  fillPattern=1),
                string="%name"), Bitmap(extent=[-83,100; 83,-100], name=
                    "Images/12.png")));
          connect(product.y, combiTable1Ds.u) annotation (points=[-19,0; -2,0],   style(
                color=74, rgbcolor={0,0,127}));
          connect(combiTable1Ds.y[1], leanAngle) annotation (points=[21,0; 86,0],
                                         style(color=74, rgbcolor={0,0,127}));
          connect(const.y, product.u1) annotation (points=[-69,20; -52,20; -52,6;
                -42,6], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
        end S_Chicane;

        model Moose_Test
          import SI = Modelica.SIunits;
          final parameter SI.Length R = 11;
          parameter SI.Velocity v;

          Modelica.Blocks.Math.Product product
            annotation (extent=[-40,-10; -20,10],    rotation=0);
          Modelica.Blocks.Sources.Clock clock
            annotation (extent=[-90,-30; -70,-10]);
          Modelica.Blocks.Interfaces.RealOutput leanAngle
            "lean angle of the rear frame" annotation (extent=[100,-10; 120,10]);
          Modelica.Blocks.Tables.CombiTable1Ds combiTable1Ds(table=[0,0; 21,0; 24,
                Modelica.Math.atan(v^2/(R*9.81)); 38,Modelica.Math.atan(v^2/(R*
                9.81)); 40,0; 76,0])
                        annotation (extent=[0,-10; 20,10]);
          Modelica.Blocks.Sources.Constant const(k=v)
            annotation (extent=[-90,10; -70,30]);
          Visualisation.RoadGraphics.DoubleLane doubleLane
            annotation (extent=[-80,50; -40,90]);
        equation
          connect(clock.y,product. u2) annotation (points=[-69,-20; -52,-20;
                -52,-6; -42,-6],
                           style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=30,
              rgbfillColor={215,215,215},
              fillPattern=1));
          annotation (Diagram, Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=7,
                  rgbfillColor={255,255,255})),                                    Text(
                extent=[-100,-90; 100,-138],
                style(
                  color=3,
                  rgbcolor={0,0,255},
                  fillColor=7,
                  rgbfillColor={255,255,255},
                  fillPattern=1),
                string="%name"),
              Line(points=[-100,20; -60,20; -20,-20; 20,-20; 60,20; 100,20],
                  style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[-82,42; -78,38], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-62,42; -58,38], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-102,42; -98,38], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-82,2; -78,-2], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-62,2; -58,-2], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-102,2; -98,-2], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-2,2; 2,-2], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[18,2; 22,-2], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-22,2; -18,-2], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-2,-38; 2,-42], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[18,-38; 22,-42], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-22,-38; -18,-42], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[78,42; 82,38], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[98,42; 102,38], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[58,42; 62,38], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[78,2; 82,-2], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[98,2; 102,-2], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[58,2; 62,-2], style(color=3, rgbcolor={0,0,255}))));
          connect(product.y, combiTable1Ds.u) annotation (points=[-19,0; -2,0],   style(
                color=74, rgbcolor={0,0,127}));
          connect(combiTable1Ds.y[1], leanAngle) annotation (points=[21,0; 110,
                0],                      style(color=74, rgbcolor={0,0,127}));
          connect(const.y, product.u1) annotation (points=[-69,20; -52,20; -52,6;
                -42,6], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
        end Moose_Test;

        package Data
          "provides record which include the lean angle profile for a specific vehicle model"
          record Curve90degree_basicMotorcycle
            "90° Curve with radius of R = 25m"
            import SI = Modelica.SIunits;
            import MA = Modelica.Math;

            final parameter SI.Length R = 25;
            parameter SI.Velocity v;

            parameter Real table[:,:] = [0, 0; 45, 0; 51, MA.atan(v^2/(R*9.81)); 51 + 39.27 - 5, MA.atan(v^2/(R*9.81)); 51 + 39.27 + 1, 0; 100, 0];

          end Curve90degree_basicMotorcycle;

          record Curve90degree_4dof_bicycle "90° Curve with radius of R = 25m"
            import SI = Modelica.SIunits;
            import MA = Modelica.Math;

            final parameter SI.Length R = 25;
            parameter SI.Velocity v;

            parameter Real table[:,:] = [0, 0; 48, 0; 51, MA.atan(v^2/(R*9.81)); 51 + 39.27 - 5, MA.atan(v^2/(R*9.81)); 51 + 39.27 + 1, 0; 100, 0];

          end Curve90degree_4dof_bicycle;
        end Data;
      end OpenLoopMethod;

      package ClosedLoopMethod
        "path-tracking with single point preview (several lateral profiles are provided)"
        model PathPreview "single point path preview"

          import SI = Modelica.SIunits;

          parameter SI.Distance preview = 2 "path preview";
          final parameter SI.Distance r[3] = {-preview, 0, 0};
          parameter SI.Distance height = 0
            "Heigth of the center of mass of the rear frame";
          final parameter SI.Distance h[3] = {0, -height, 0};

          annotation (
            Diagram,
            Coordsys(extent=[-100,-100; 100,100], scale=0.1),
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Line(points=[100,20; -100,20], style(color=0, rgbcolor={0,0,0})),
              Line(points=[100,-38; 68,-42; 34,-50; 4,-58; -20,-60; -60,-54;
                    -100,-50],        style(color=1, rgbcolor={255,0,0})),
              Line(points=[-20,20; -20,-60; -20,-44],  style(color=3, rgbcolor={0,
                      0,255})),
              Ellipse(extent=[-29,28; -11,10], style(
                  color=58,
                  rgbcolor={0,127,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Line(points=[-20,-60; -26,-48], style(
                  color=3,
                  rgbcolor={0,0,255},
                  fillColor=7,
                  rgbfillColor={255,255,255},
                  fillPattern=1)),
              Line(points=[-20,-60; -14,-48], style(
                  color=3,
                  rgbcolor={0,0,255},
                  fillColor=3,
                  rgbfillColor={0,0,255},
                  fillPattern=1)),
              Text(
                extent=[100,60; -100,100],
                style(
                  color=3,
                  rgbcolor={0,0,255},
                  fillPattern=1),
                string="%name")));
          MultiBondLib.Mechanics3D.Interfaces.Frame_a frame_a
            annotation (extent=[89,0; 111,40]);
          Modelica.Blocks.Interfaces.RealOutput x_lat
            "lateral position of the vehicle"
            annotation (extent=[-120,10; -100,30], rotation=180);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation(r=r,
              animation=false) annotation (extent=[0,30; 20,50],  rotation=180);
          MultiBondLib.Mechanics3D.MechSensors.AbsoluteSensor absoluteSensor
            annotation (extent=[-60,30; -40,50], rotation=180);
          MultiBondLib.Mechanics3D.Parts.SimpleBody PreviewPoint(
            m=0,
            I_11=0,
            I_22=0,
            I_33=0) annotation (extent=[-30,-10; -10,10],
                                                        rotation=270);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation1(
              animation=false, r=h)
                               annotation (extent=[40,30; 60,50], rotation=180);
        equation
          connect(absoluteSensor.frame_a, fixedTranslation.frame_b) annotation (
             points=[-39,40; -1,40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(PreviewPoint.frame_a, fixedTranslation.frame_b)
                                                                annotation (
              points=[-20,11; -20,40; -1,40],                style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(absoluteSensor.out[3], x_lat) annotation (points=[-61,40; -80,
                40; -80,20; -110,20], style(color=74, rgbcolor={0,0,127}));
          connect(fixedTranslation1.frame_b, fixedTranslation.frame_a)
            annotation (points=[39,40; 21,40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(fixedTranslation1.frame_a, frame_a) annotation (points=[61,40;
                80,40; 80,20; 100,20], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
        end PathPreview;

        model PathPreview_StateSpace
          "single point path preview model for a state-space controller"

          import SI = Modelica.SIunits;

          parameter SI.Distance preview = 2 "path preview";
          final parameter SI.Distance r[3] = {-preview, 0, 0};
          parameter SI.Distance height = 0
            "Heigth of the center of mass of the rear frame";
          final parameter SI.Distance h[3] = {0, -height, 0};

          annotation (
            Diagram(
              Text(
                extent=[-98,-7; -44,-27],
                style(color=3, rgbcolor={0,0,255}),
                string="absolute lateral position"),
              Text(
                extent=[-98,32; -52,14],
                style(color=3, rgbcolor={0,0,255}),
                string="absolute lateral rate")),
            Coordsys(extent=[-100,-100; 100,100], scale=0.1),
            Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Line(points=[100,20; -100,20], style(color=0, rgbcolor={0,0,0})),
              Line(points=[100,-38; 68,-42; 34,-50; 4,-58; -20,-60; -60,-54;
                    -100,-50], style(color=2, rgbcolor={0,255,0})),
              Line(points=[-20,20; -20,-60; -20,-44],  style(color=3, rgbcolor={0,
                      0,255})),
              Ellipse(extent=[-29,28; -11,10], style(
                  color=58,
                  rgbcolor={0,127,0},
                  fillColor=60,
                  rgbfillColor={170,255,170},
                  fillPattern=1)),
              Line(points=[-20,-60; -26,-48], style(
                  color=3,
                  rgbcolor={0,0,255},
                  fillColor=7,
                  rgbfillColor={255,255,255},
                  fillPattern=1)),
              Line(points=[-20,-60; -14,-48], style(
                  color=3,
                  rgbcolor={0,0,255},
                  fillColor=3,
                  rgbfillColor={0,0,255},
                  fillPattern=1)),
              Text(
                extent=[100,60; -100,100],
                string="%name",
                style(
                  color=3,
                  rgbcolor={0,0,255},
                  fillColor=7,
                  rgbfillColor={255,255,255},
                  fillPattern=1))));
          MultiBondLib.Mechanics3D.Interfaces.Frame_a frame_a
            annotation (extent=[89,0; 111,40]);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation(r=r,
              animation=false) annotation (extent=[50,30; 70,50], rotation=270);
          MultiBondLib.Mechanics3D.Parts.SimpleBody PreviewPoint(
            m=0,
            I_11=0,
            I_22=0,
            I_33=0) annotation (extent=[50,-51; 70,-31],rotation=270);
          MultiBondLib.Mechanics3D.MechSensors.AbsoluteSensor absoluteSensor(
            get_R=false,
            get_r_abs=false,
            get_v_abs=false,
            get_a_abs=true)
            annotation (extent=[32,10; 52,30],      rotation=180);
          Modelica.Blocks.Continuous.Integrator get_xB_d(initType=Modelica.Blocks.Types.Init.InitialState,
              y_start=0)
            annotation (extent=[0,10; 20,30],    rotation=180);
          Modelica.Blocks.Continuous.Integrator get_xB(initType=Modelica.Blocks.Types.Init.InitialState,
              y_start=0)
            annotation (extent=[-40,-30; -20,-10],
                                                 rotation=180);
          Modelica.Blocks.Interfaces.RealOutput x1_lateralPosition
            annotation (extent=[-120,-30; -100,-10],  rotation=180);
          Modelica.Blocks.Interfaces.RealOutput x2_lateralVelocity
            annotation (extent=[-120,10; -100,30],    rotation=180);
          MultiBondLib.Mechanics3D.Parts.FixedTranslation fixedTranslation1(
              animation=false, r=h)
                               annotation (extent=[70,30; 90,50], rotation=90);
        equation
          connect(x1_lateralPosition,x1_lateralPosition)  annotation (points=[-110,-20;
                -110,-20],           style(color=74, rgbcolor={0,0,127}));
          connect(get_xB_d.y,x2_lateralVelocity)    annotation (points=[-1,20;
                -110,20],  style(color=74, rgbcolor={0,0,127}));
          connect(get_xB.y,x1_lateralPosition)  annotation (points=[-41,-20;
                -110,-20], style(color=74, rgbcolor={0,0,127}));
          connect(x2_lateralVelocity,x2_lateralVelocity)  annotation (points=[-110,20;
                -110,20],            style(color=74, rgbcolor={0,0,127}));
          connect(get_xB.u,get_xB_d. y) annotation (points=[-18,-20; -10,-20;
                -10,20; -1,20],
                              style(color=74, rgbcolor={0,0,127}));
          connect(absoluteSensor.frame_a, fixedTranslation.frame_b)
            annotation (points=[53,20; 60,20; 60,29],
                                               style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(absoluteSensor.out[3], get_xB_d.u) annotation (points=[31,20;
                22,20], style(color=74, rgbcolor={0,0,127}));
          connect(fixedTranslation.frame_b, PreviewPoint.frame_a) annotation (
              points=[60,29; 60,-30], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(fixedTranslation.frame_a, fixedTranslation1.frame_b)
            annotation (points=[60,51; 60,60; 80,60; 80,51], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(fixedTranslation1.frame_a, frame_a) annotation (points=[80,29;
                80,20; 100,20], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
        end PathPreview_StateSpace;

        model Path "lateral profile generated with a matlab m-file"

          import SI = Modelica.SIunits;

          parameter SI.Velocity v "Velocity of the vehicle";
          parameter SI.Distance offset = 2
            "Offset equal to the path-preview distance";

          Modelica.Blocks.Sources.Clock clock
            annotation (extent=[-80,-10; -60,10]);
          Modelica.Blocks.Math.Product product
            annotation (extent=[-40,10; -20,30],     rotation=0);
          Modelica.Blocks.Sources.Constant setPoint_velocity(k=v)
            annotation (extent=[-80,30; -60,50]);
          Modelica.Blocks.Tables.CombiTable1Ds Position_preview(
            tableOnFile=true,
            tableName="pos_tab",
            fileName="Position.mat",
            smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative)
                                     annotation (extent=[40,-10; 60,10]);
          Modelica.Blocks.Interfaces.RealOutput p_pre "preview position"
                                           annotation (extent=[100,-50; 120,-30]);
          annotation (Diagram(
              Rectangle(extent=[30,66; 70,-26], style(
                  color=30,
                  rgbcolor={215,215,215},
                  thickness=4)),
              Text(
                extent=[21,-30; 79,-42],
                style(
                  color=10,
                  rgbcolor={95,95,95},
                  thickness=4,
                  fillPattern=1),
                string="Position.mat table"),
              Text(
                extent=[8,-36; 92,-54],
                string="path generation with butterfil.m",
                style(
                  color=10,
                  rgbcolor={135,135,135},
                  thickness=4,
                  fillPattern=1))),
                               Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=7,
                  rgbfillColor={255,255,255},
                  fillPattern=1)),
              Text(
                extent=[-60,80; 60,40],
                string="%name",
                style(
                  color=3,
                  rgbcolor={0,0,255},
                  fillColor=7,
                  rgbfillColor={255,255,255},
                  fillPattern=1)),
              Polygon(points=[-30,28; -70,-52; -70,-64; 70,-64; 70,-52; 30,28;
                    -30,28],          style(color=10, fillColor=10)),
              Polygon(points=[-2,14; 2,14; 0,28; 0,28; -2,14],           style(color=
                      8, fillColor=8)),
              Polygon(points=[-4,-12; 4,-12; 2,6; -2,6; -4,-12],          style(color=
                     8, fillColor=8)),
              Polygon(points=[-10,-58; 10,-58; 6,-22; -6,-22; -10,-58],     style(
                    color=8, fillColor=8))));
          Modelica.Blocks.Sources.Constant Preview(k=offset)
            annotation (extent=[-80,-50; -60,-30]);
          Modelica.Blocks.Math.Add add annotation (extent=[0,-10; 20,10]);
          Modelica.Blocks.Tables.CombiTable1Ds Position(
            tableOnFile=true,
            tableName="pos_tab",
            fileName="Position.mat",
            smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative)
                                     annotation (extent=[40,30; 60,50]);
          Modelica.Blocks.Interfaces.RealOutput p_act
            "lateral position without offset"
                                           annotation (extent=[100,30; 120,50]);
        equation
          connect(setPoint_velocity.y, product.u1) annotation (points=[-59,40;
                -50,40; -50,26; -42,26],
                                      style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(Position_preview.y[1], p_pre)
                                           annotation (points=[61,0; 90,0; 90,
                -40; 110,-40],
              style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(clock.y, product.u2) annotation (points=[-59,0; -50,0; -50,14;
                -42,14], style(color=74, rgbcolor={0,0,127}));
          connect(add.y, Position_preview.u)
                                     annotation (points=[21,0; 38,0], style(
                color=74, rgbcolor={0,0,127}));
          connect(Preview.y, add.u2) annotation (points=[-59,-40; -10,-40; -10,
                -6; -2,-6], style(color=74, rgbcolor={0,0,127}));
          connect(add.u1, product.y) annotation (points=[-2,6; -10,6; -10,20;
                -19,20], style(color=74, rgbcolor={0,0,127}));
          connect(Position.u, product.y) annotation (points=[38,40; -10,40; -10,
                20; -19,20], style(color=74, rgbcolor={0,0,127}));
          connect(p_act, Position.y[1]) annotation (points=[110,40; 61,40],
              style(color=74, rgbcolor={0,0,127}));
        end Path;

        model Moose_Test "Moose test (closed loop version)"

          import SI = Modelica.SIunits;

          parameter SI.Velocity v;
          parameter SI.Distance preview = 5 "path preview";

          Modelica.Blocks.Sources.Clock clock
            annotation (extent=[-80,-40; -60,-20]);
          Modelica.Blocks.Math.Product product
            annotation (extent=[-30,-4; -10,16],     rotation=0);
          Modelica.Blocks.Sources.Constant setPoint_velocity(k=v)
            annotation (extent=[-80,20; -60,40]);
          Modelica.Blocks.Tables.CombiTable1Ds combiTable1Ds(smoothness=
                Modelica.Blocks.Types.Smoothness.LinearSegments, table=[0,0; 12,
                0; 25.9463,3.5; 36.9463,3.5; 50.8927,0; 62.8927,0])
            annotation (extent=[50,-10; 70,10]);
          annotation (Diagram, Icon(
              Rectangle(extent=[-100,100; 100,-100], style(
                  color=0,
                  rgbcolor={0,0,0},
                  fillColor=7,
                  rgbfillColor={255,255,255},
                  fillPattern=1)),
              Text(
                extent=[-50,70; 42,26],
                style(
                  color=3,
                  rgbcolor={0,0,255},
                  fillColor=7,
                  rgbfillColor={255,255,255},
                  fillPattern=1),
                string="%name"),
              Line(points=[-100,2; -60,2; -20,-38; 20,-38; 60,2; 100,2],
                  style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[-82,24; -78,20], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-64,24; -60,20], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-100,24; -96,20], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-82,-16; -78,-20],
                                              style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-64,-16; -60,-20],
                                              style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-100,-16; -96,-20],
                                               style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-2,-16; 2,-20],
                                           style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[16,-16; 20,-20],
                                            style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-20,-16; -16,-20],
                                              style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-2,-56; 2,-60], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[16,-56; 20,-60], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[-20,-56; -16,-60], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[78,24; 82,20], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[96,24; 100,20], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[60,24; 64,20], style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[78,-16; 82,-20],
                                            style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[96,-16; 100,-20],
                                             style(color=3, rgbcolor={0,0,255})),
              Ellipse(extent=[60,-16; 64,-20],
                                            style(color=3, rgbcolor={0,0,255}))));
          Modelica.Blocks.Interfaces.RealOutput y
                                           annotation (extent=[100,-10; 120,10]);
          Visualisation.RoadGraphics.DoubleLane doubleLane
            annotation (extent=[-80,50; -40,90]);
          Modelica.Blocks.Sources.Constant PathPreview(k=preview)
            annotation (extent=[-30,-60; -10,-40]);
          Modelica.Blocks.Math.Add add3_2 annotation (extent=[10,-10; 30,10],
                       rotation=0);
        equation
          connect(setPoint_velocity.y, product.u1) annotation (points=[-59,30;
                -40,30; -40,12; -32,12],
                                      style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=3,
              rgbfillColor={0,0,255},
              fillPattern=1));
          connect(clock.y, product.u2) annotation (points=[-59,-30; -40,-30;
                -40,0; -32,0], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(combiTable1Ds.y[1], y) annotation (points=[71,0; 110,0],
              style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(add3_2.y, combiTable1Ds.u) annotation (points=[31,0; 48,0],
              style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(add3_2.u1, product.y) annotation (points=[8,6; -9,6], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(add3_2.u2, PathPreview.y) annotation (points=[8,-6; 0,-6; 0,
                -50; -9,-50], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
        end Moose_Test;
      end ClosedLoopMethod;
      annotation (Icon(
          Rectangle(extent=[-100,-100; 80,50], style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Text(
            extent=[-81,87; 69,-33],
            string="Library",
            style(color=10, rgbcolor={95,95,95})),
          Text(
            extent=[-120,122; 120,73],
            string="%name",
            style(color=1)),
          Polygon(points=[-40,18; -80,-62; -80,-74; 60,-74; 60,-62; 20,18; -40,
                18],              style(color=10, fillColor=10)),
          Polygon(points=[-14,-22; -6,-22; -8,-4; -12,-4; -14,-22],   style(color=
                 8, fillColor=8)),
          Polygon(points=[-12,4; -8,4; -10,18; -10,18; -12,4],       style(color=
                  8, fillColor=8)),
          Polygon(points=[-20,-68; 0,-68; -4,-32; -16,-32; -20,-68],    style(
                color=8, fillColor=8))));
    end Tracks;

    package Disturbances "simulation of disturbances (e.g. side wind)"
      annotation (Icon(
          Rectangle(extent=[-100,-100; 80,50], style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
              color=10,
              rgbcolor={95,95,95},
              fillColor=30,
              rgbfillColor={235,235,235},
              fillPattern=1)),
          Text(
            extent=[-85,35; 65,-85],
            string="Library",
            style(color=10, rgbcolor={95,95,95})),
          Text(
            extent=[-120,122; 120,73],
            string="%name",
            style(color=1)),
          Line(points=[-90,-34; -72,-32; -62,-34; -52,-30; -36,-36; -24,42; -8,
                -92; 6,-26; 32,-32; 38,-30; 54,-32; 66,-30], style(color=3,
                rgbcolor={0,0,255}))));
      model SideWind "Side wind force in z-direction"

        import SI = Modelica.SIunits;
        import MB = Modelica.Mechanics.MultiBody;

        parameter SI.Force a = 1500 "amplitude of the pulse (side wind force)";

        parameter SI.Time T = 10 "time of one period";
        parameter SI.Time w = 0.1 "width of the pulse";
        parameter SI.Time r = 0.15 "rising time of the pulse";
        parameter SI.Time f = 0.15 "falling time of the pulse";
        parameter SI.Time s = 3 "start time of the pulse";

        // Graphical Annotation
        annotation (Images(Parameters(name="", source="images/WindForce.jpg")),
          Icon(
            Rectangle(extent=[-100,100; 100,-100], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1)),
            Line(points=[46,40; 46,-18],
                                       style(color=0, rgbcolor={0,0,0})),
            Rectangle(extent=[44,-18; 48,-70],   style(pattern=0)),
            Line(points=[30,10; 30,16; 62,16; 62,10],   style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=10,
                rgbfillColor={95,95,95},
                fillPattern=1)),
            Ellipse(extent=[36,60; 56,40],   style(color=0, rgbcolor={0,0,0})),
            Line(points=[46,-72; 54,-20; 50,-18; 42,-70; 46,-72],      style(color=10,
                  rgbcolor={135,135,135})),
            Line(points=[52,-20; 64,38],   style(color=10, rgbcolor={135,135,135})),
            Ellipse(extent=[54,56; 74,36],   style(color=10, rgbcolor={135,135,
                    135})),
            Line(points=[72,4; 74,10; 44,16; 42,10],      style(color=10,
                  rgbcolor={135,135,135})),
            Polygon(points=[20,0; -26,46; -26,24; -86,24; -86,-24; -26,-24; -26,
                  -24; -26,-46; 20,0], style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=60,
                rgbfillColor={170,255,170})),
            Text(
              extent=[-100,-100; 100,-146],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1))),
          Diagram(Text(
              extent=[-54,30; -22,16],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="z-direction"), Text(
              extent=[-54,-9; -26,-23],
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=7,
                rgbfillColor={255,255,255},
                fillPattern=1),
              string="x = y = 0")));
        // Animation
       parameter MB.Types.Color arrowColor = {0,255,0} "|Visualisation|";
       parameter Real arrowDiameter = 0.03 "|Visualisation|";

       MotorcycleLib.Utilities.Arrow normalForce(
          each r=frame_a.P.x,
          each r_tail=zeros(3) - {0,0,1}*pulse.y/1000,
          each r_head={0,0,1}*pulse.y/1000,
          each diameter=arrowDiameter,
          each color=arrowColor,
          each specularCoefficient=0,
          each R=MB.Frames.Orientation(T=identity(3), w=zeros(3)));

        Modelica.Blocks.Sources.Trapezoid pulse(
          amplitude=a,
          rising=r,
          width=w,
          falling=f,
          period=T,
          startTime=s) annotation (extent=[-80,10; -60,30]);
        Modelica.Blocks.Sources.Constant const[2](k={0,0})
          annotation (extent=[-80,-30; -60,-10]);
        MultiBondLib.Mechanics3D.Forces.WorldForce WorldForce
          annotation (extent=[20,-10; 40,10]);
        MultiBondLib.Mechanics3D.Interfaces.Frame_a frame_a
          annotation (extent=[90,-20; 110,20]);
      equation
        connect(pulse.y, WorldForce.force[3])
                                             annotation (points=[-59,20; -20,20;
              -20,0.666667; 19.6,0.666667],
                                        style(color=74, rgbcolor={0,0,127}));
        annotation (Icon(
            Rectangle(extent=[-100,100; 100,-100], style(
                color=0,
                rgbcolor={0,0,0},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Polygon(points=[12,0; -20,32; -20,16; -80,16; -80,-16; -20,-16; -20,
                  -32; 12,0],
                style(
                color=58,
                rgbcolor={0,127,0},
                fillColor=60,
                rgbfillColor={170,255,170})),
            Text(
              extent=[-80,100; 80,60],
              string="%name",
              style(
                color=3,
                rgbcolor={0,0,255},
                fillColor=60,
                rgbfillColor={170,255,170},
                fillPattern=1))), Diagram);
        connect(WorldForce.frame_b, frame_a)
                                            annotation (points=[41,0; 100,0], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=60,
            rgbfillColor={170,255,170},
            fillPattern=1));
        connect(const[1].y, WorldForce.force[1]) annotation (points=[-59,-20;
              -20,-20; -20,-0.666667; 19.6,-0.666667], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(const[2].y, WorldForce.force[2]) annotation (points=[-59,-20;
              -20,-20; -20,5.55112e-017; 19.6,5.55112e-017], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
      end SideWind;
    end Disturbances;

  end Environments;

  package Visualisation
    "Provides the graphical information (pictures of the tracks)"
    package RoadGraphics
      model Road_straight

        MotorcycleLib.Visualisation.FlatSurface flat_Surface2_1(
          offset_y=2.75,
          lenght_x=5,
          lenght_y=5,
          offset_x=5,
          PNG=3) annotation (extent=[20,0; 40,20]);
        MotorcycleLib.Visualisation.FlatSurface flat_Surface2_2(
          offset_y=2.75,
          lenght_x=5,
          lenght_y=5,
          offset_x=9.5,
          PNG=3) annotation (extent=[0,0; 20,20]);
        MotorcycleLib.Visualisation.FlatSurface flat_Surface2_3(
          offset_y=2.75,
          lenght_x=5,
          lenght_y=5,
          offset_x=14,
          PNG=3) annotation (extent=[-20,0; 0,20]);
        MotorcycleLib.Visualisation.FlatSurface flat_Surface2_4(
          offset_y=2.75,
          lenght_x=5,
          lenght_y=5,
          offset_x=18.5,
          PNG=3) annotation (extent=[-40,0; -20,20]);
        annotation (Icon(Bitmap(extent=[-102,100; 102,-100], name="Images/3.png")));
      end Road_straight;

      model Road_90degree_curve

        annotation (Icon(Bitmap(extent=[-122,100; 122,-100],
                                                          name="Images/10.png"), Text(
              extent=[-100,160; 100,100],
              style(
                color=3,
                rgbcolor={0,0,255},
                arrow=2,
                fillPattern=1),
              string="Visualization")));
        FlatSurface flatSurface(
          offset_x=100 + 100/10,
          lenght_x=100 + 100/10,
          lenght_y=100 + 100/10,
          PNG=10,
          offset_y=35 + 100/10) annotation (extent=[-80,50; -50,80]);
      end Road_90degree_curve;

      model Road_u_turn

        MotorcycleLib.Visualisation.FlatSurface flat_Surface2_1(
          PNG=10,
          offset_x=50,
          offset_y=20.5,
          lenght_x=50,
          lenght_y=50) annotation (extent=[0,0; 20,20]);
        annotation (Icon(Bitmap(extent=[-122,40; 22,-60], name="Images/10.png"),
              Bitmap(extent=[-20,40; 120,-60], name="Images/11.png")));
        MotorcycleLib.Visualisation.FlatSurface flat_Surface2_2(
          PNG=11,
          offset_y=-24.5,
          offset_x=50,
          lenght_x=50,
          lenght_y=50)  annotation (extent=[-20,0; 0,20]);
      end Road_u_turn;

      model S_Shikane

        annotation (Icon(Bitmap(extent=[-100,100; 100,-100], name=
                  "Images/12.png")));
        MotorcycleLib.Visualisation.FlatSurface flat_Surface(
          PNG=12,
          offset_x=50,
          offset_y=20.5,
          lenght_x=50,
          lenght_y=50) annotation (extent=[0,0; 20,20]);
      end S_Shikane;

      model DoubleLane

        annotation (Icon(
            Rectangle(extent=[-100,42; 100,-42], style(
                color=7,
                rgbcolor={255,255,255},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Line(points=[-100,20; -60,20; -20,-20; 20,-20; 60,20; 100,20],
                style(color=0, rgbcolor={0,0,0})),
            Ellipse(extent=[-82,42; -78,38], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[-62,42; -58,38], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[-102,42; -98,38], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[-82,2; -78,-2], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[-62,2; -58,-2], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[-102,2; -98,-2], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[-2,2; 2,-2], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[18,2; 22,-2], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[-22,2; -18,-2], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[-2,-38; 2,-42], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[18,-38; 22,-42], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[-22,-38; -18,-42], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[78,42; 82,38], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[98,42; 102,38], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[58,42; 62,38], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[78,2; 82,-2], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[98,2; 102,-2], style(color=3, rgbcolor={0,0,255})),
            Ellipse(extent=[58,2; 62,-2], style(color=3, rgbcolor={0,0,255}))));

        MotorcycleLib.Visualisation.FlatSurface flat_Surface2_1(
          PNG=15,
          offset_x=62 + 62/10,
          lenght_x=62 + 62/10,
          lenght_y=7 + 7/10,
          offset_y=7 + 7/10 - 5.25)           annotation (extent=[0,0; 20,20]);
      end DoubleLane;

    end RoadGraphics;

    model VisualBase
      //constant Real VisualObject = 987000;
      Real ObjectType;
      output Real Form = 987000 + ObjectType  annotation(Hide=false);
      annotation (
        Coordsys(extent=[-100, -100; 100, 100]));
    end VisualBase;

    model SurfaceMaterial
      //import VisualBase;
      //extends VisualBase;
      import MotorcycleLib.Visualisation.VisualBase;
      extends MotorcycleLib.Visualisation.VisualBase;

      output Real material annotation (Hide=false);
      output Real extra annotation (Hide=false);
      output Real NumberOfU annotation (Hide=false);
      output Real NumberOfV annotation (Hide=false);
      output Real x[nu, nv] annotation (Hide=false);
      output Real y[nu, nv] annotation (Hide=false);
      output Real z[nu, nv] annotation (Hide=false);
      parameter Integer nu=2;
      parameter Integer nv=2 "Number of points for u and v.";
      parameter Real Material[4]={1,0,0,0.5} "Color and specular coefficient.";
      parameter Real Extra=0.0 "Additional parameters.";
      annotation (Coordsys(extent=[-100, -100; 100, 100]));
    equation
      ObjectType = 57;
      NumberOfU = nu;
      NumberOfV = nv;
      material = PackMaterial(Material[1], Material[2], Material[3], Material[4]);
      extra = Extra;
    end SurfaceMaterial;

    model FlatSurface "Flat surface in the xz-plane"
      import SurfaceMaterial;
      parameter Real offset_x=0 "Desired offset + Desired Length/10";
      parameter Real offset_y=0 "Desired offset + Desired Length/10";
      parameter Real lenght_x=100 "Desired length + Desired Length/10";
      parameter Real lenght_y=100 "Desired length + Desired Length/10";
      parameter Real quote=0;
      parameter Real PNG=1;
      SurfaceMaterial surf(
        Material={1,1,1,0},
        nu=11,
        nv=11,
        Extra=10*(PNG + 10*100))
                               annotation (extent=[-20,20; 0,40]);
    equation

        for i in 1:surf.nu loop
          for j in 1:surf.nv loop
            surf.x[i, j] = lenght_x*i/surf.nu - offset_x;
            surf.z[i, j] = lenght_y*j/surf.nv - offset_y;
            surf.y[i, j] = quote;
          end for;
        end for;

      annotation (Icon(
          Rectangle(extent=[-100,100; 100,-100], style(
              color=0,
              rgbcolor={0,0,0},
              fillColor=7,
              rgbfillColor={255,255,255})),
          Polygon(points=[-18,18; 92,18; 22,-30; -88,-30; -18,18], style(
              color=0,
              rgbcolor={0,0,0},
              fillColor=9,
              rgbfillColor={175,175,175})),
          Text(
            extent=[-100,100; 100,40],
            string="%name",
            style(
              color=3,
              rgbcolor={0,0,255},
              fillColor=9,
              rgbfillColor={175,175,175},
              fillPattern=1))), Coordsys(scale=0.15));
    end FlatSurface;

    annotation (Documentation(info="<html>
A detailed description of the models can be found in:
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Visualisation\">UsersGuide.Overview.Visualisation</a>]</span>

</html>"));
  end Visualisation;

  package IdealWheels
    "This models contain slight modifications of those in the MultiBondLib"

    model WheelJoint "models the joint characteristics of a wheel"
      import SI = Modelica.SIunits;
      import MB = Modelica.Mechanics.MultiBody;

      parameter Boolean animation = true "animate wheel";

     parameter SI.Radius r=1 "radius of wheel";
      parameter Real n[3] = {0,1,0}
        "vector normal to rolling plane, pointing upwards"                             annotation(Evaluate=true);
      parameter SI.Distance d=0 "distance of rolling plane o origin";

      parameter SI.Radius rRim = 0.9*r "|Animation|| radius of rim";
      parameter SI.Diameter wWheel = 0.3*r "|Animation|| width of the wheel";
      parameter MB.Types.Color tireColor= {64,64,64}
        "|Animation|| Color of the tire";
      parameter MB.Types.Color rodColor= {155,155,155}
        "|Animation|| Color of the rods";
      parameter MB.Types.Color contactColor= {128,128,128}
        "|Animation|| Color of the contactpoint";

      final parameter Real eN[3] = n/sqrt(n*n) "normalization of n"
                                           annotation(Evaluate=true);
      final parameter Real notN[3] = if abs(eN[1]) > 0.1 then {0,1,0} else (if abs(eN[2])
           > 0.1 then {0,0,1} else {1,0,0})
        "Arbitrary vector that is not aligned with eN"   annotation(Evaluate=true);
      final parameter Real vec_a[3] = cross(eN,notN) "vector in rolling plane"
                                  annotation(Evaluate=true);
      final parameter Real eA[3] = {1,0,0} "normalized vector in rolling plane"
                                           annotation(Evaluate=true);
      final parameter Real eB[3] = cross(eA,eN)
        "normalized vector in rolling plane orthogonal to eA"
                                           annotation(Evaluate=true);

      SI.AngularVelocity w[3] "angular velocity";
      SI.AngularAcceleration z[3] "angular acceleration";

      SI.Position x[3] "Position of the frame";
      SI.Velocity v[3] "Velocity";
      SI.Acceleration a[3] "Acceleration";

      Real d_cp[3]
        "vector pointing in direction of the contact point from wheel center res. in inertial frame";

      SI.Force fN;

    protected
      Real eAxis[3] "unit vector aligned to wheel Axis in inertial frame";
      SI.Position r_cp[3]
        "Vector from wheel center to contact point res. in inertial frame";

    public
      MultiBondLib.Mechanics3D.Interfaces.Frame_b frame_b
                                 annotation (extent=[100,-20; 120,20]);

    protected
      MultiBondLib.Mechanics3D.Interfaces.MBG2Mech MBG2Mech1
                                    annotation (extent=[80,-60; 100,20]);
      inner MultiBondLib.Defaults MBG_defaults(n=3)
                                       annotation (extent=[40,60; 60,80]);
      MultiBondLib.Junctions.J0 J0_1
                        annotation (extent=[-60,0; -40,20]);
      MultiBondLib.Bonds.MultiBond MultiBond2
                                 annotation (extent=[60,0; 80,20]);
      MultiBondLib.Bonds.MultiBond MultiBond5
                                 annotation (extent=[60,-60; 80,-40], rotation=0);
      MultiBondLib.Bonds.MultiBond MultiBond13
                                  annotation (extent=[-40,-60; -20,-40], rotation=0);
      MultiBondLib.Bonds.MultiBond MultiBond14
                                  annotation (extent=[0,-60; 20,-40], rotation=0);
      MultiBondLib.Bonds.Utilities.MultiBondTail MultiBondTail2
        annotation (extent=[-60,-48; -40,0], rotation=90);
      MultiBondLib.Bonds.Utilities.MultiBondTail MultiBondTail3
        annotation (extent=[-48,-60; -38,-40], rotation=0);
      MultiBondLib.Bonds.Utilities.MultiBondTail MultiBondTail4
        annotation (extent=[40,-60; 62,-40]);
      MultiBondLib.Passive.mTF_effort mTF_effort1
                                     annotation (extent=[20,-60; 40,-40]);

    protected
      outer MultiBondLib.Mechanics3D.World3D world3D;

     parameter Integer ndim=if world3D.enableAnimation and animation then 1 else 0;
    MB.Visualizers.Advanced.Shape tirePipe[ndim](
        each shapeType="pipe",
        each color=tireColor,
        each length= wWheel,
        each width=2*r,
        each height=2*r,
        each lengthDirection={0,0,1},
        each widthDirection={0,1,0},
        each extra=0.9,
        each r_shape=-{0,0,1}*wWheel/2,
        each r=MBG2Mech1.x,
        each R=MB.Frames.Orientation(T=MBG2Mech1.R,w=zeros(3)),
        each specularCoefficient = 0.1);

    MB.Visualizers.Advanced.Shape cylinder[ndim](
        each shapeType="cylinder",
        each color=rodColor,
        each length= 0.02,
        each lengthDirection={0,0,1},
        each width=rRim,
        each height=rRim,
        each r_shape=-{0, 0, 1}*0.01,
        each r=MBG2Mech1.x,
        each R=MB.Frames.Orientation(T=MBG2Mech1.R,w=zeros(3)),
        each specularCoefficient = 0.1);

    MB.Visualizers.Advanced.Shape contactPoint[ndim](
        each shapeType="cylinder",
        each color=contactColor,
        each length= r/20,
        each width=wWheel*3,
        each height=wWheel*3,
        each lengthDirection=eN,
        each widthDirection=eA,
        each r=MBG2Mech1.x,
        each r_shape=r_cp,
        each specularCoefficient = 0.1);

     annotation (Diagram(
          Rectangle(extent=[0,-70; 20,-90],style(
              color=10,
              rgbcolor={135,135,135},
              fillColor=7,
              rgbfillColor={255,255,255})),
          Text(
            extent=[18,-86; 2,-80],
            style(
              color=10,
              rgbcolor={135,135,135},
              gradient=3),
            string="point"),
          Text(
            extent=[2,-72; 18,-82],
            style(
              color=10,
              rgbcolor={135,135,135},
              gradient=3),
            string="contact"),
          Line(points=[-10,-64; -10,-80; 0,-80],   style(color=10, rgbcolor={135,
                  135,135})),
          Line(points=[20,-80; 72,-80; 72,-30],    style(color=10, rgbcolor={135,
                  135,135})),
          Rectangle(extent=[20,0; 40,-20], style(
              color=10,
              rgbcolor={135,135,135},
              fillColor=7,
              rgbfillColor={255,255,255})),
          Text(
            extent=[40,-16; 20,-10],
            style(
              color=10,
              rgbcolor={135,135,135},
              gradient=3),
            string="constraint"),
          Text(
            extent=[20,-2; 40,-10],
            style(
              color=10,
              rgbcolor={135,135,135},
              gradient=3),
            string="holonomic"),
          Line(points=[40,-10; 68,-10; 78,-10],    style(color=10, rgbcolor={135,
                  135,135})),
          Line(points=[-46,100; 30,56; 30,0],  style(color=10, rgbcolor={135,135,
                  135}))),      Icon(
          Ellipse(extent=[-70,68; 70,-70], style(
              color=3,
              rgbcolor={0,0,255},
              gradient=3,
              fillColor=83,
              rgbfillColor={255,170,255})),
          Line(points=[-100,-70; 100,-70], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2)),
          Text(extent=[-114,130; 116,72], string="%name"),
          Text(
            extent=[128,-116; -104,-76],
            style(color=0),
            string="r=%r"),
          Line(points=[98,0; 20,0], style(
              color=0,
              rgbcolor={0,0,0},
              gradient=3,
              fillColor=5,
              rgbfillColor={255,0,255})),
          Ellipse(extent=[-42,42; 42,-42], style(
              pattern=0,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1)),
          Ellipse(extent=[-18,18; 18,-18], style(
              pattern=0,
              fillColor=10,
              rgbfillColor={95,95,95},
              fillPattern=1))),
        Documentation(info="<html>
This component models the movement constraints for an ideal rolling wheel.
<p>
<img src=\"../Images/Wheel.png\">
</p>
<h3>General parameter</h3>
The radius of the wheel can be defined by the parameter r.
<p>
The rolling plane can be specified by the vector n (pointing upwards) and the distance of the  plane
from the origin d.
<p>
The parameter animation toggles the visualization
<h3>Visualization</h3>
A full animation of the wheel is supported.
Color and basic geometry can be changed by the corresponding parameters.
<h3>Remarks</h3>
Ideal rolling establishes one holonomic constraint and two non-holonomic constraints.
A freely rolling wheel therefore has 3 degrees of freedom on the level of velocity
on five degrees of freedom on the level of position.
</html>"),
        experiment,
        experimentSetupOutput);

      MultiBondLib.Mechanics3D.AdditionalMBG.translational_mTF2
        translational_mTF2_1
        annotation (extent=[-20,-60; 0,-40], rotation=180);
      MultiBondLib.Bonds.Utilities.MultiBondTail MultiBondTail5
                                                   annotation (extent=[-40,0; 62,20]);
      MultiBondLib.Bonds.MultiBond MultiBond4(n=1)
                                 annotation (extent=[-60,60; -40,80],
                                                                    rotation=270);
      MultiBondLib.Bonds.MultiBond MultiBond6
                                 annotation (extent=[-60,20; -40,40], rotation=270);
    public
      MultiBondLib.Sources.mSe mSe1(n=1)
                            annotation (extent=[-60,80; -40,100], rotation=90);

      MultiBondLib.Passive.TF2_effort projectiveTF(
        nA=3,
        nB=1,
        M={eN}) annotation (extent=[-60,40; -40,60], rotation=90);
    equation

      w = MBG2Mech1.MultiBondConRot.f;
      z = der(w);

      x = MBG2Mech1.x;
      v = MBG2Mech1.MultiBondConTrans.f;
      a = der(v);

    // holonomic constraint
      x*eN  = (d - r_cp*eN);
        fN = mSe1.s[1];

    // contact point computation
      eAxis = transpose(MBG2Mech1.R)*{0,0,1};
      d_cp = (-eN) - ((-eN)*eAxis)*eAxis;
      r_cp = r* d_cp/sqrt(d_cp*d_cp);
      translational_mTF2_1.r = r_cp;

      connect(MBG2Mech1.frame_b,frame_b)  annotation (points=[99,-20; 104,-20; 104,
            0; 110,0],
                    style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2));
      connect(MultiBond2.MultiBondCon2, MBG2Mech1.MultiBondConTrans) annotation (
          points=[80,10; 80,10], style(
          color=71,
          rgbcolor={85,170,255},
          thickness=2,
          gradient=3,
          fillColor=83,
          rgbfillColor={255,170,255}));
      connect(MultiBond13.MultiBondCon1, J0_1.MultiBondCon3) annotation (points=[-40,-50;
            -50,-50; -50,0],          style(
          color=71,
          rgbcolor={85,170,255},
          gradient=3,
          fillColor=83,
          rgbfillColor={255,170,255}));
      connect(mTF_effort1.MultiBondCon2, MultiBond5.MultiBondCon1) annotation (
          points=[40,-50; 60,-50], style(color=71, rgbcolor={85,170,255}));
      connect(mTF_effort1.MultiBondCon1, MultiBond14.MultiBondCon2) annotation (
          points=[20,-50; 20,-50], style(color=71, rgbcolor={85,170,255}));
      connect(translational_mTF2_1.MultiBondCon1, MultiBond14.MultiBondCon1)
        annotation (points=[0,-50; 0,-50], style(color=71, rgbcolor={85,170,255}));
      connect(translational_mTF2_1.MultiBondCon2, MultiBond13.MultiBondCon2)
        annotation (points=[-20,-50; -20,-50], style(color=71, rgbcolor={85,170,255}));
      connect(mTF_effort1.M, MBG2Mech1.R) annotation (points=[30,-60; 30,-70; 76,
            -70; 76,-30; 80,-30], style(color=3, rgbcolor={0,0,255}));
      connect(MultiBond5.MultiBondCon2, MBG2Mech1.MultiBondConRot) annotation (
          points=[80,-50; 80,-50], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond2.MultiBondCon1, J0_1.MultiBondCon2) annotation (points=[60,10;
            -40,10],     style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond6.MultiBondCon2, J0_1.MultiBondCon4) annotation (points=[-50,20;
            -50,20],     style(color=71, rgbcolor={85,170,255}));
      connect(mSe1.MultiBondCon1, MultiBond4.MultiBondCon1) annotation (points=[-50,
            80; -50,80], style(color=71, rgbcolor={85,170,255}));
      connect(projectiveTF.MultiBondConB, MultiBond4.MultiBondCon2)
        annotation (points=[-50,60; -50,60], style(color=71, rgbcolor={85,170,
              255}));
      connect(projectiveTF.MultiBondConA, MultiBond6.MultiBondCon1)
        annotation (points=[-50,40; -50,40], style(color=71, rgbcolor={85,170,
              255}));
    end WheelJoint;

    model Wheel "complete model of a wheel"
      import SI = Modelica.SIunits;
      import MB = Modelica.Mechanics.MultiBody;
      import Cv = Modelica.SIunits.Conversions;

      parameter Boolean animation = true "animate wheel";

      parameter SI.Radius r=1 "radius of wheel";
      parameter Real n[3] = {0,1,0}
        "vector normal to rolling plane, pointing upwards"                             annotation(Evaluate=true);
      parameter SI.Distance d=0 "distance of rolling plane o origin";

      parameter SI.Mass m = 1 "mass of body";

      parameter SI.Inertia I_11=0.001
        "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (1,1) element of inertia tensor"
                                                                                                            annotation(Evaluate=true);
      parameter SI.Inertia I_22=0.001
        "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,2) element of inertia tensor"
                                                                                                            annotation(Evaluate=true);
      parameter SI.Inertia I_33=0.001
        "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,3) element of inertia tensor"
                                                                                                            annotation(Evaluate=true);
      parameter SI.Inertia I_21=0
        "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (2,1) element of inertia tensor"
                                                                                                            annotation(Evaluate=true);
      parameter SI.Inertia I_31=0
        "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,1) element of inertia tensor"
                                                                                                            annotation(Evaluate=true);
      parameter SI.Inertia I_32=0
        "|Inertia tensor (resolved in center of mass, parallel to frame_a)| (3,2) element of inertia tensor"
                                                                                                            annotation(Evaluate=true);
      final parameter SI.Inertia Inert[3, 3]=[I_11, I_21, I_31; I_21, I_22, I_32;
          I_31, I_32, I_33] "inertia tensor"
                                            annotation(Evaluate=true);

      parameter MB.Types.Init.Temp initType=MB.Types.Init.Free
        "|Initialization|| Type of initialization (defines usage of start values below)";
      parameter Boolean useTransVelocities = false
        "|Initialization|| use the translational velocities (defines usage of start values below)";
      parameter Cv.NonSIunits.Angle_deg phi_start[3] = {0,0,0}
        "|Initialization||initial cardan angles in degree";
      parameter MultiBondLib.Mechanics3D.Types.AngularVelocity_deg w_start[3]={0,0,
          0} "|Initialization||initial angular velocity in deg/s";
      parameter MultiBondLib.Mechanics3D.Types.AngularAcceleration_deg z_start[3]={
          0,0,0} "|Initialization||initial angular acceleration in deg/s2";
      parameter SI.Position x_start[3] = {0,0,0}
        "|Initialization||initial position";
      parameter SI.Velocity v_start[3] = {0,0,0}
        "|Initialization||initial velocity";
      parameter SI.Acceleration a_start[3] = {0,0,0}
        "|Initialization||initial acceleration";

      final parameter SI.Angle phi_start_rad[3] = Cv.from_deg(phi_start)
        "initial cardan angles";
      final parameter SI.AngularVelocity w_start_rad[3] = Cv.from_deg(w_start)
        "initial angular velocity";
      final parameter SI.AngularAcceleration z_start_rad[3] = Cv.from_deg(z_start)
        "initial angular acceleration";

      parameter SI.Radius rRim = 0.9*r "|Animation|| radius of rim";
      parameter SI.Diameter wWheel = 0.3*r "|Animation|| width of the wheel";
      parameter MB.Types.Color tireColor= {64,64,64}
        "|Animation|| Color of the tire";
      parameter MB.Types.Color rodColor= {155,155,155}
        "|Animation|| Color of the rods";
      parameter MB.Types.Color contactColor= {128,128,128}
        "|Animation|| Color of the contactpoint";

      parameter Boolean enforceStates =  false
        "|Advanced||enforce Quaternions or cardan angles and w as states";
      parameter Boolean useQuaternions =  false
        "|Advanced||use Quaternions instead of cardan angles";
      final parameter MultiBondLib.Mechanics3D.Types.RotationSequence
        sequence_angles={2,1,3} "|Advanced||sequence of the cardan angles";
      final parameter MultiBondLib.Mechanics3D.Types.Quaternion Q_start=
          MultiBondLib.Mechanics3D.Utilities.AxesRotQ(phi_start_rad,
          sequence_angles);

      SI.Position xA(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
        "Position in direction of eA";

      SI.Position xB(stateSelect=if enforceStates then StateSelect.always else StateSelect.prefer)
        "Position in direction of eB";

      SI.Position x[3] "Position of the frame";
      SI.Velocity v[3] "Velocity";

      MultiBondLib.Mechanics3D.Types.Quaternion Q(
        stateSelect=if useQuaternions then StateSelect.prefer else StateSelect.never,
        start=Q_start,
        fixed=false) "quaternions";

      SI.Angle phi[3](stateSelect=if not useQuaternions then (if enforceStates then
                      StateSelect.always else StateSelect.prefer) else  StateSelect.never)
        "cardan angles";
      SI.Angle phi_d[3](stateSelect=if not useQuaternions then (if enforceStates then
                      StateSelect.always else StateSelect.prefer) else  StateSelect.never)
        "cardan^ angles derivatives";
      SI.AngularVelocity w[3](stateSelect=if useQuaternions then (if enforceStates then
                      StateSelect.always else StateSelect.prefer) else  StateSelect.default)
        "angular velocity";

      SI.Acceleration a[3] "Acceleration";
      SI.AngularAcceleration z[3] "angular acceleration";

    public
      MultiBondLib.Mechanics3D.Interfaces.Frame_b frame_b
                                 annotation (extent=[100,-20; 120,20]);
      annotation (Icon(
          Text(extent=[-114,130; 116,72], string="%name"),
          Ellipse(extent=[-70,68; 70,-70], style(
              color=3,
              rgbcolor={0,0,255},
              gradient=3,
              fillColor=71,
              rgbfillColor={85,170,255})),
          Ellipse(extent=[-18,18; 18,-18], style(
              pattern=0,
              fillColor=10,
              rgbfillColor={95,95,95},
              fillPattern=1)),
          Ellipse(extent=[-42,42; 42,-42], style(
              pattern=0,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1)),
          Line(points=[-100,-70; 100,-70], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2)),
          Text(
            extent=[128,-116; -104,-76],
            style(color=0),
            string="r=%r"),
          Line(points=[98,0; 20,0], style(
              color=0,
              rgbcolor={0,0,0},
              gradient=3,
              fillColor=5,
              rgbfillColor={255,0,255})),
          Ellipse(extent=[-18,18; 18,-18], style(
              pattern=0,
              fillColor=10,
              rgbfillColor={95,95,95},
              fillPattern=1))), Diagram,
        Documentation(info="<html>
This is the model of a wheel.
The movement of the wheel is restricted to be ideally rolling on a straight plane.
The model is composed out of the corresponding rudimental joint model and the body model.
<p>
<img src=\"../Images/Wheel.png\">
</p>
<h3>General parameter</h3>
The mass of the wheel can be specified by the parameter m.
<p>
The inertia tensor of the wheel is a symmetric 3x3 matrix and can be specified by the parameters I11, I12, ...
<p>
The radius of the wheel can be defined by the parameter r.
<p>
The rolling plane can be specified by the vector n (pointing upwards) and the distance of the  plane
from the origin d.
<p>
The parameter animation toggles the visualization
<h3>Initialization</h3>
In general, you can specify...
<ul>
<li>...the initial position and orientation.
<li>...the initial velocity and angular velocity.
<li>...the initial acceleration and angular acceleration.
</ul>
Which of these variables do effectively appear in the inital equations can be defined by the parameter initType and useTransVelocity.
<p>
The ideal rolling restricts the wheel's position on the plane and the statement of the initial position is overdetermined. Therefore the initial position is automatically projected on the rolling plane.
<p>
The ideal rolling restricts the wheel's movement. The initial velocities and angular velocities form an overdetermined initial statement.<br>
By the activation of useTransVelocity, all velocities are defined by the translational movement on the plane and the rotation around the plane's normal vector.
Otherwise all initial angular velocities are taken to define the initial movement.
<h3>Visualization</h3>
A full animation of the wheel is supported.
Color and basic geometry can be changed by the corresponding parameters.
<h3>Advanced settings</h3>
The activation of enforceStates enforces the model to explicitely define integrators.
This parameter is useful to choose the state variables in a kinematic loop.
<p>
The orientation can either be expressed by the three cardan angles or by quaternions.
<ul>
<li>The usage of cardan angles leads to a faster computation but contains a singular point. It is therefore of limited applicability.
<li> The usage of quaternions leads to a robust solution, but it generates the need for a dynamic state selection and leads to non-linear equations.
</ul>
<p>
Which of these two variants is used, can be specified by the parameter useQuaternions.
</html>"),
        DymolaStoredErrors);
      WheelJoint WheelJoint1(
        animation=animation,
        r=r,
        n=n,
        d=d,
        rRim=rRim,
        wWheel=wWheel,
        tireColor=tireColor,
        rodColor=rodColor,
        contactColor=contactColor)
             annotation (extent=[20,-28; 40,-8]);
      MultiBondLib.Mechanics3D.Parts.Body WheelBody(
        animation=false,
        I_22=I_22,
        I_33=I_33,
        I_21=I_21,
        I_31=I_31,
        I_32=I_32,
        initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
        enforceStates=false,
        useQuaternions=useQuaternions,
        sequence_angles={2,1,3},
        m=m,
        I_11=I_11)     annotation (extent=[40,12; 20,32]);
    initial equation
      if initType == MB.Types.Init.Position or initType == MB.Types.Init.
          PositionVelocity or initType == MB.Types.Init.PositionVelocityAcceleration then
        // Initialize positional variables
        xA = x_start*WheelJoint1.eA;
        xB = x_start*WheelJoint1.eB;
        if useQuaternions then
          Q[1:3] = Q_start[1:3];
        else
          phi = phi_start_rad;
        end if;
      end if;

      if initType == MB.Types.Init.PositionVelocity or initType == MB.Types.Init.
          PositionVelocityAcceleration or initType == MB.Types.Init.Velocity or
          initType == MB.Types.Init.VelocityAcceleration then
        // Initialize velocity variables
        if useTransVelocities then
          v*WheelJoint1.eA = v_start*WheelJoint1.eA;
          v*WheelJoint1.eB = v_start*WheelJoint1.eB;
          w*WheelJoint1.eN = w_start_rad*WheelJoint1.eN;
        else
          w = w_start_rad;
        end if;
      end if;

      if initType == MB.Types.Init.VelocityAcceleration or initType == MB.Types.Init.
          PositionVelocityAcceleration then
        // Initialize acceleration variables
        if useTransVelocities then
          a*WheelJoint1.eA = a_start*WheelJoint1.eA;
          a*WheelJoint1.eB = a_start*WheelJoint1.eB;
          z*WheelJoint1.eN = z_start_rad*WheelJoint1.eN;
        else
          z = z_start_rad;
        end if;
      end if;

      if initType == MB.Types.Init.SteadyState then
        w = zeros(3);
        z = zeros(3);
      end if;

    equation
      x = WheelBody.PotentialFBM1.x;
      v = WheelBody.PotentialFBM1.v;
      a = WheelBody.PotentialFBM1.a;
      phi = WheelBody.PotentialFBM1.phi;
      phi_d = WheelBody.PotentialFBM1.phi_d;
      Q = WheelBody.PotentialFBM1.Q;
      w = WheelBody.PotentialFBM1.w;
      z = WheelBody.PotentialFBM1.z;

      xA = x*WheelJoint1.eA;
      xB = x*WheelJoint1.eB;

      connect(WheelBody.frame_a, frame_b)
                                      annotation (points=[41,22; 72,22; 72,0;
            110,0],
          style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2,
          fillColor=71,
          rgbfillColor={85,170,255},
          fillPattern=1));
      connect(WheelJoint1.frame_b, frame_b) annotation (points=[41,-18; 72,
            -18; 72,0; 110,0],            style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2,
          fillColor=71,
          rgbfillColor={85,170,255},
          fillPattern=1));
    end Wheel;

    annotation (preferedView="info", Documentation(info="<html>

In the ideal wheels sub-package the visualization of the rolling objects from D. Zimmer's MultiBondLib
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Literature\">Zim06</a>]</span>
were modified such that the appearance is similar to real motorcycle wheels.
<p>
A detailed description of the models can be found in:
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.IdealWheels\">UsersGuide.Overview.IdealWheels</a>]</span>

</html>"),
      Icon(
        Rectangle(extent=[-100,-100; 80,50], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
            color=71,
            rgbcolor={85,170,255},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Text(
          extent=[-120,125; 120,70],
          string="%name",
          style(color=3, rgbcolor={0,0,255})),
        Text(
          extent=[-90,40; 70,10],
          string="Library",
          style(
            color=3,
            rgbcolor={0,0,255},
            fillColor=0,
            rgbfillColor={0,0,0},
            fillPattern=1))));

  end IdealWheels;

  package Utilities "Several useful functions and models"
    function getStates
      "Returns the states of the vehicle (according to these names appropriate states can be selected)"

      extends Modelica.Icons.Function;
      import Modelica.Utilities;

      input String modelName;

    protected
      Boolean hd = LinearSystems.Internal.SetHideDymosim();
      Boolean OK=linearizeModel(modelName);
      Real nxMat[1, 1] = readMatrix("dslin.mat", "nx", 1, 1);
      Integer ABCDsizes[2] = readMatrixSize("dslin.mat", "ABCD");
      Integer nx = integer(nxMat[1, 1]);
      Integer nu = ABCDsizes[2] - nx;
      Integer ny = ABCDsizes[1] - nx;

      LinearSystems.StateSpace ABCD(
        nx = nx,
        ny = ny,
        nu = nu);

    algorithm
      ABCD := LinearSystems.linearize(modelName);
      stateNames := ABCD.xNames;

      // print the states to command window
      for i in 1:nx loop
        Modelica.Utilities.Streams.print(" ");
        Modelica.Utilities.Streams.print("Nr." + integerString(i));
        Modelica.Utilities.Streams.print(stateNames[i]);
      end for;

      Advanced.HideDymosim := hd;

      annotation (Documentation(info="<html>
<p>
This function is used to determine the states of a vehicle.
</p>
</html>"));
    end getStates;
    annotation (Icon(
        Rectangle(extent=[-100,-100; 80,50], style(
            color=42,
            rgbcolor={127,0,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50], style(
            color=42,
            rgbcolor={127,0,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70], style(
            color=42,
            rgbcolor={127,0,0},
            fillColor=30,
            rgbfillColor={235,235,235},
            fillPattern=1)),
        Text(
          extent=[-85,35; 65,-85],
          string="Library",
          style(color=42, rgbcolor={127,0,0})),
        Text(
          extent=[-120,122; 120,73],
          string="%name",
          style(color=1))), Documentation(info="<html>
A detailed description of the models can be found in:
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.UsersGuide.Overview.Utilities\">UsersGuide.Overview.Utilities</a>]</span>
</html>"));

    function PlotRootLocusForVehicles
      "Plots the root locii for vehicles as a function of the vehicles forward velocity"

      input String modelName = "MotorcycleDynamicsV6.StabilityAnalysis.BasicMotorcycle.Motorcycle_Vittore_encapsulated";
      input String independentVariableName = "vs";
      input Real startValue = 0;
      input Real endValue = 8;
      input Integer number_of_values = 40;

    algorithm
        LinearSystems.rootLocus(modelName, independentVariableName, startValue, endValue, number_of_values);
      annotation (Documentation(info="<HTML>
<p>
This example demonstrates plotting of a root locus for the Motor Drive example with repect to the gain of the controller, controller.k.
</p>
<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The example exploits
<pre>
LinearSystems.rootLocus(\"LinearSystems.Examples.DriveLib.TestMotorDrive\", \"controller.k\", startValue = 1, endValue = 100, n=20);
<\\pre>
</p>
</HTML>"));
    end PlotRootLocusForVehicles;

    model BodyAngleSensor "Measures the body angles"

      import SI = Modelica.SIunits;
      import CO = Modelica.SIunits.Conversions;

      parameter CO.NonSIunits.Angle_deg initialAngles[3] = {0,5,0};
      final parameter SI.Angle initialAngles_rad[3] = CO.from_deg(initialAngles);

      MultiBondLib.Mechanics3D.Interfaces.Frame_a frame_a
                                 annotation (extent=[-120,-20; -100,20]);
    protected
      MultiBondLib.Mechanics3D.Interfaces.Mech2MBG mech2MBG
                                   annotation (extent=[-70,-40; -50,40]);
      MultiBondLib.Bonds.MultiBond multiBond1
                                annotation (extent=[-50,-40; -30,-20]);
      MultiBondLib.Sensors.Df Dq(n=3)
                          annotation (extent=[-30,-40; -10,-20],
                                                             rotation=0);
    public
      Modelica.Blocks.Interfaces.RealOutput phi[3]
        annotation (extent=[100,-10; 120,10],   rotation=0);
    protected
      inner MultiBondLib.Defaults MBG_defaults(
                                  n=3) annotation (extent=[-80,60; -60,80]);
      MultiBondLib.Sources.Se Se2(
                     n=3, e0={0}) annotation (extent=[-10,20; -30,40],
                                                                    rotation=180);
      MultiBondLib.Bonds.MultiBond MultiBond3
                                      annotation (extent=[-50,20; -30,40],
                                                                         rotation=180);
    public
      MultiBondLib.Mechanics3D.Utilities.toCardanAngles toCardanAngles1(
          sequence_angles={2,1,3}, phi(start=initialAngles_rad))
        annotation (extent=[10,-40; 30,-20],   rotation=0);
    equation
      connect(mech2MBG.frame_a,frame_a)  annotation (points=[-69,0; -110,0],
          style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2,
          fillColor=10,
          rgbfillColor={95,95,95},
          fillPattern=1));
      annotation (Diagram, Icon(
          Ellipse(extent=[-70,70; 70,-70],   style(color=0, fillColor=7)),
          Line(points=[0,70; 0,46], style(color=10, rgbcolor={95,95,95})),
          Line(points=[26,38; 40.2,57.3], style(color=10, rgbcolor={95,95,95})),
          Line(points=[-26,38; -40.2,57.3], style(color=10, rgbcolor={95,95,
                  95})),
          Line(points=[44,16; 65.8,23.9], style(color=10, rgbcolor={95,95,95})),
          Line(points=[-46,16; -65.8,23.9], style(color=10, rgbcolor={95,95,
                  95})),
          Line(points=[0,0; 9.02,28.6],   style(color=0)),
          Polygon(points=[2,32; 16,26; 20,58; 2,32], style(
              color=0,
              rgbcolor={0,0,0},
              fillColor=10,
              rgbfillColor={95,95,95},
              fillPattern=1)),
          Ellipse(extent=[-5,5; 5,-5],   style(
              color=0,
              gradient=0,
              fillColor=0,
              fillPattern=1)),
          Text(extent=[-128,78; 133,126],   string="%name"),
             Text(
            extent=[-58,-68; 58,-94],
            string="force",
            style(color=10, rgbcolor={95,95,95})),
          Line(points=[-100,0; -70,0], style(color=0, rgbcolor={0,0,0})),
          Line(points=[70,0; 100,0], style(color=0, rgbcolor={0,0,0}))));
      connect(Dq.MultiBondCon1, multiBond1.MultiBondCon2)  annotation (points=[
            -30,-30; -30,-30], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond3.MultiBondCon2, mech2MBG.MultiBondConTrans) annotation (
         points=[-50,30; -50,30], style(color=71, rgbcolor={85,170,255}));
      connect(Se2.MultiBondCon1, MultiBond3.MultiBondCon1) annotation (points=[
            -30,30; -30,30], style(color=71, rgbcolor={85,170,255}));
      connect(multiBond1.MultiBondCon1, mech2MBG.MultiBondConRot) annotation (
          points=[-50,-30; -49.8,-30], style(color=71, rgbcolor={85,170,255}));
      connect(toCardanAngles1.w, Dq.f_out) annotation (points=[10,-30; -10,-30],
          style(color=3, rgbcolor={0,0,255}));
      connect(toCardanAngles1.phi, phi) annotation (points=[30,-30; 64,-30; 64,
            0; 110,0], style(color=3, rgbcolor={0,0,255}));
    end BodyAngleSensor;

    model BodyAngleSensorV2 "Measures the body angles"

      import SI = Modelica.SIunits;
      import CO = Modelica.SIunits.Conversions;

      parameter CO.NonSIunits.Angle_deg initialAngles[3] = {0,5,0};
      final parameter SI.Angle initialAngles_rad[3] = CO.from_deg(initialAngles);

      MultiBondLib.Mechanics3D.Interfaces.Frame_a frame_a
                                 annotation (extent=[-120,-20; -100,20]);
    protected
      MultiBondLib.Mechanics3D.Interfaces.Mech2MBG mech2MBG
                                   annotation (extent=[-70,-40; -50,40]);
      MultiBondLib.Bonds.MultiBond multiBond1
                                annotation (extent=[-50,-40; -30,-20]);
      MultiBondLib.Sensors.Dq Dq(
        n=3,
        stateInitialCondition=true,
        q_start=initialAngles_rad)
                          annotation (extent=[-30,-40; -10,-20],
                                                             rotation=0);
    public
      Modelica.Blocks.Interfaces.RealOutput phi[3]
        annotation (extent=[100,-10; 120,10],   rotation=0);
    protected
      inner MultiBondLib.Defaults MBG_defaults(
                                  n=3) annotation (extent=[-80,60; -60,80]);
      MultiBondLib.Sources.Se Se2(
                     n=3, e0={0}) annotation (extent=[-10,20; -30,40],
                                                                    rotation=180);
      MultiBondLib.Bonds.MultiBond MultiBond3
                                      annotation (extent=[-50,20; -30,40],
                                                                         rotation=180);
    equation
      connect(mech2MBG.frame_a,frame_a)  annotation (points=[-69,0; -110,0],
          style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2,
          fillColor=10,
          rgbfillColor={95,95,95},
          fillPattern=1));
      annotation (Diagram, Icon(
          Ellipse(extent=[-70,70; 70,-70],   style(color=0, fillColor=7)),
          Line(points=[0,70; 0,46], style(color=10, rgbcolor={95,95,95})),
          Line(points=[26,38; 40.2,57.3], style(color=10, rgbcolor={95,95,95})),
          Line(points=[-26,38; -40.2,57.3], style(color=10, rgbcolor={95,95,
                  95})),
          Line(points=[44,16; 65.8,23.9], style(color=10, rgbcolor={95,95,95})),
          Line(points=[-46,16; -65.8,23.9], style(color=10, rgbcolor={95,95,
                  95})),
          Line(points=[0,0; 9.02,28.6],   style(color=0)),
          Polygon(points=[2,32; 16,26; 20,58; 2,32], style(
              color=0,
              rgbcolor={0,0,0},
              fillColor=10,
              rgbfillColor={95,95,95},
              fillPattern=1)),
          Ellipse(extent=[-5,5; 5,-5],   style(
              color=0,
              gradient=0,
              fillColor=0,
              fillPattern=1)),
          Text(extent=[-128,78; 133,126],   string="%name"),
             Text(
            extent=[-58,-68; 58,-94],
            string="force",
            style(color=10, rgbcolor={95,95,95})),
          Line(points=[-100,0; -70,0], style(color=0, rgbcolor={0,0,0})),
          Line(points=[70,0; 100,0], style(color=0, rgbcolor={0,0,0}))));
      connect(Dq.MultiBondCon1, multiBond1.MultiBondCon2)  annotation (points=[
            -30,-30; -30,-30], style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond3.MultiBondCon2, mech2MBG.MultiBondConTrans) annotation (
         points=[-50,30; -50,30], style(color=71, rgbcolor={85,170,255}));
      connect(Se2.MultiBondCon1, MultiBond3.MultiBondCon1) annotation (points=[
            -30,30; -30,30], style(color=71, rgbcolor={85,170,255}));
      connect(multiBond1.MultiBondCon1, mech2MBG.MultiBondConRot) annotation (
          points=[-50,-30; -49.8,-30], style(color=71, rgbcolor={85,170,255}));
      connect(Dq.q, phi) annotation (points=[-10,-30; 44,-30; 44,0; 110,0], style(
            color=3, rgbcolor={0,0,255}));
    end BodyAngleSensorV2;

    model BodyAngleSensor_es
      "Measures the body angles - including state selection (es ... enforce states)"

      import SI = Modelica.SIunits;
      import CO = Modelica.SIunits.Conversions;

      parameter CO.NonSIunits.Angle_deg initialAngles[3] = {0,5,0};
      final parameter SI.Angle initialAngles_rad[3] = CO.from_deg(initialAngles);

      parameter Boolean enforceStates =  false
        "|Advanced||enforce Quaternions or cardan angles and w as states";

      Real lean_d(stateSelect= if enforceStates then StateSelect.always else StateSelect.prefer);

      MultiBondLib.Mechanics3D.Interfaces.Frame_a frame_a
                                 annotation (extent=[-120,-20; -100,20]);
    protected
      MultiBondLib.Mechanics3D.Interfaces.Mech2MBG mech2MBG
                                   annotation (extent=[-70,-40; -50,40]);
      MultiBondLib.Bonds.MultiBond multiBond1
                                annotation (extent=[-50,-40; -30,-20]);
      MultiBondLib.Sensors.Df Df(n=3)
                          annotation (extent=[-30,-40; -10,-20],
                                                             rotation=0);
    public
      Modelica.Blocks.Interfaces.RealOutput phi[3]
        annotation (extent=[100,-10; 120,10],   rotation=0);
    protected
      inner MultiBondLib.Defaults MBG_defaults(
                                  n=3) annotation (extent=[-80,60; -60,80]);
      MultiBondLib.Sources.Se Se2(
                     n=3, e0={0}) annotation (extent=[-10,20; -30,40],
                                                                    rotation=180);
      MultiBondLib.Bonds.MultiBond MultiBond3
                                      annotation (extent=[-50,20; -30,40],
                                                                         rotation=180);
    public
      MultiBondLib.Mechanics3D.Utilities.toCardanAngles toCardanAngles1(
          sequence_angles={2,1,3}, phi(start=initialAngles_rad))
        annotation (extent=[10,-40; 30,-20],   rotation=0);
    equation
      lean_d = Df.MultiBondCon1.f[1];

      connect(mech2MBG.frame_a,frame_a)  annotation (points=[-69,0; -110,0],
          style(
          color=0,
          rgbcolor={0,0,0},
          thickness=2,
          fillColor=10,
          rgbfillColor={95,95,95},
          fillPattern=1));
      annotation (Diagram, Icon(
          Ellipse(extent=[-70,70; 70,-70],   style(color=0, fillColor=7)),
          Line(points=[0,70; 0,46], style(color=10, rgbcolor={95,95,95})),
          Line(points=[26,38; 40.2,57.3], style(color=10, rgbcolor={95,95,95})),
          Line(points=[-26,38; -40.2,57.3], style(color=10, rgbcolor={95,95,
                  95})),
          Line(points=[44,16; 65.8,23.9], style(color=10, rgbcolor={95,95,95})),
          Line(points=[-46,16; -65.8,23.9], style(color=10, rgbcolor={95,95,
                  95})),
          Line(points=[0,0; 9.02,28.6],   style(color=0)),
          Polygon(points=[2,32; 16,26; 20,58; 2,32], style(
              color=0,
              rgbcolor={0,0,0},
              fillColor=10,
              rgbfillColor={95,95,95},
              fillPattern=1)),
          Ellipse(extent=[-5,5; 5,-5],   style(
              color=0,
              gradient=0,
              fillColor=0,
              fillPattern=1)),
          Text(extent=[-128,78; 133,126],   string="%name"),
             Text(
            extent=[-58,-68; 58,-94],
            string="force",
            style(color=10, rgbcolor={95,95,95})),
          Line(points=[-100,0; -70,0], style(color=0, rgbcolor={0,0,0})),
          Line(points=[70,0; 100,0], style(color=0, rgbcolor={0,0,0}))));
      connect(Df.MultiBondCon1, multiBond1.MultiBondCon2)  annotation (points=[-30,-30;
            -30,-30],          style(color=71, rgbcolor={85,170,255}));
      connect(MultiBond3.MultiBondCon2, mech2MBG.MultiBondConTrans) annotation (
         points=[-50,30; -50,30], style(color=71, rgbcolor={85,170,255}));
      connect(Se2.MultiBondCon1, MultiBond3.MultiBondCon1) annotation (points=[
            -30,30; -30,30], style(color=71, rgbcolor={85,170,255}));
      connect(multiBond1.MultiBondCon1, mech2MBG.MultiBondConRot) annotation (
          points=[-50,-30; -49.8,-30], style(color=71, rgbcolor={85,170,255}));
      connect(toCardanAngles1.w,Df. f_out) annotation (points=[10,-30; -10,-30],
          style(color=3, rgbcolor={0,0,255}));
      connect(toCardanAngles1.phi, phi) annotation (points=[30,-30; 60,-30; 60,
            0; 110,0], style(color=3, rgbcolor={0,0,255}));
    end BodyAngleSensor_es;

    model Arrow
      "Visualizing an arrow with variable size; all data have to be set as modifiers (see info layer)"

      import SI = Modelica.SIunits;
      import Modelica.Mechanics.MultiBody.Types;
      import Modelica.Mechanics.MultiBody.Frames;

      input Frames.Orientation R=Frames.nullRotation()
        "Orientation object to rotate the world frame into the arrow frame." annotation(Dialog);
      input SI.Position r[3]={0,0,0}
        "Position vector from origin of world frame to origin of arrow frame, resolved in world frame"
                                                                                                       annotation(Dialog);
      input SI.Position r_tail[3]={0,0,0}
        "Position vector from origin of arrow frame to arrow tail, resolved in arrow frame"
                                                                                            annotation(Dialog);
      input SI.Position r_head[3]={0,0,0}
        "Position vector from arrow tail to the head of the arrow, resolved in arrow frame"
                                                                                            annotation(Dialog);
      input SI.Diameter diameter=world3D.defaultArrowDiameter
        "Diameter of arrow line" annotation(Dialog);
      input Modelica.Mechanics.MultiBody.Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.ArrowColor
        "Color of arrow" annotation(Dialog);
      input Types.SpecularCoefficient specularCoefficient = world3D.defaultSpecularCoefficient
        "Material property describing the reflecting of ambient light (= 0 means, that light is completely absorbed)"
                                                                                                            annotation(Dialog);
    protected
      outer MultiBondLib.Mechanics3D.World3D world3D;
      SI.Length length=Frames.length(r_head) "Length of arrow";
      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape arrowLine(
        length=noEvent(max(0, length - diameter*Types.Defaults.ArrowHeadLengthFraction)),
        width=diameter,
        height=diameter,
        lengthDirection=r_head,
        widthDirection={0,1,0},
        shapeType="cylinder",
        color=color,
        specularCoefficient=specularCoefficient,
        r_shape=r_tail,
        r=r,
        R=R) if world3D.enableAnimation;

      Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape arrowHead(
        length=noEvent(max(0, min(length, diameter*Types.Defaults.ArrowHeadLengthFraction))),
        width=noEvent(max(0, diameter*Types.Defaults.ArrowHeadWidthFraction)),
        height=noEvent(max(0, diameter*Types.Defaults.ArrowHeadWidthFraction)),
        lengthDirection=r_head,
        widthDirection={0,1,0},
        shapeType="cone",
        color=color,
        specularCoefficient=specularCoefficient,
        r=arrowLine.rvisobj + arrowLine.rxvisobj*arrowLine.length,
        R=R) if world3D.enableAnimation;

      annotation (
        preferedView="info",
        Documentation(info="<HTML>
<p>
Model <b>Arrow</b> defines an arrow that is dynamically
visualized at the defined location (see variables below).
</p>
<IMG SRC=\"../Images/MultiBody/Visualizers/Arrow.png\" ALT=\"model Visualizers.Advanced.Arrow\">
<p>
The variables under heading <b>Parameters</b> below
are declared as (time varying) <b>input</b> variables.
If the default equation is not appropriate, a corresponding
modifier equation has to be provided in the
model where an <b>Arrow</b> instance is used, e.g., in the form
</p>
<pre>
    Visualizers.Advanced.Arrow arrow(diameter = sin(time));
</pre>

<p>
Variable <b>color</b> is an Integer vector with 3 elements,
{r, g, b}, and specifies the color of the shape.
{r,g,b} are the \"red\", \"green\" and \"blue\" color parts.
Note, r g, b are given in the range 0 .. 255.
The predefined type <b>MultiBody.Types.Color</b> contains
a menu definition of the colors used in the MultiBody
library (will be replaced by a color editor).
</p>
</HTML>"),
        Icon(
          Rectangle(extent=[-100, 28; 20, -30], style(color=10, fillColor=10)),
          Polygon(points=[20, 60; 100, 0; 20, -60; 20, 60], style(color=10,
                fillColor=10)),
          Text(extent=[-146, 124; 142, 62], string="%name")),
        Diagram);

    end Arrow;

  end Utilities;

  package Examples "Examples of uncontrolled and controlled vehicles"
    annotation (Icon(
        Rectangle(extent=[-100,-100; 80,50],   style(
            color=0,
            fillColor=30,
            fillPattern=1)),
        Polygon(points=[-100,50; -80,70; 100,70; 80,50; -100,50],      style(
            color=0,
            fillColor=30,
            fillPattern=1)),
        Polygon(points=[100,70; 100,-80; 80,-100; 80,50; 100,70],      style(
            color=0,
            fillColor=30,
            fillPattern=1)),
        Text(
          extent=[-85,71; 65,-49],
          string="Sample",
          style(color=0)),
        Text(
          extent=[-118,114; 122,65],
          string="%name",
          style(color=1)),
        Text(
          extent=[-97,23; 78,-98],
          string="Programs",
          style(color=0))), Documentation(info="<html>
In this sub-package several examples are provided:
</p>
<ul>
<li>Benchmark Bicycle</li>
<li>BasicMotorcycle</li>
<li>AdvancedMotorcycle</li>
</ul>

</html>"));
    package BenchmarkBicycle
      package RigidRider

        model uncontrolled_3dof_bicycle
          import MotorcycleLib;

          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 4;
          MultiBondLib.Mechanics3D.RollingObjects.WheelJoint FWheelJoint(        rodColor=
               {128,0,0}, r=0.35)
                    annotation (extent=[-90,-70; -70,-50]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
            I_21=0,
            I_31=0,
            I_32=0,
            animation=false,
            m=3,
            I_11=0.14,
            I_22=0.14,
            I_33=0.28)
                 annotation (extent=[-50,-70; -30,-50]);
          MultiBondLib.Mechanics3D.RollingObjects.Wheel RWheel(
            m=2,
            I_11=0.06,
            I_22=0.06,
            I_33=0.12,
            r=0.3,
            w_start=vs*{0,0,1/0.3*180/Modelica.Constants.pi},
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            phi_start={0,5,0})  annotation (extent=[92,-70; 72,-50], rotation=0);
          annotation (
            Diagram(             Text(
                extent=[-98,-94; -12,-102],
                style(
                  color=9,
                  rgbcolor={175,175,175},
                  thickness=4),
                string="... essential for controller design"),
              Text(
                extent=[-51,85; 52,72],
                style(
                  color=70,
                  rgbcolor={45,96,172},
                  fillColor=70,
                  rgbfillColor={45,96,172}),
                string="Initial Conditions: initial steer angle = 0deg"),
              Text(
                extent=[-50,74; 53,68],
                style(
                  color=70,
                  rgbcolor={45,96,172},
                  fillColor=70,
                  rgbfillColor={45,96,172}),
                string="Advanced: enforce states = TRUE"),
              Line(points=[-54,88; -54,56; 54,56; 54,88; -28,88], style(
                  color=9,
                  rgbcolor={175,175,175},
                  thickness=2,
                  fillColor=70,
                  rgbfillColor={45,96,172},
                  fillPattern=1)),
              Text(
                extent=[-52,94; -30,84],
                style(
                  color=9,
                  rgbcolor={175,175,175},
                  thickness=4,
                  fillColor=70,
                  rgbfillColor={45,96,172},
                  fillPattern=1),
                string="Hints"),
              Text(
                extent=[-51,68; 53,59],
                style(
                  color=70,
                  rgbcolor={45,96,172},
                  fillColor=70,
                  rgbfillColor={45,96,172}),
                string="Initialization: Rear wheel: phi_start = {0,5,0}")),
            experiment(
              StopTime=30,
              Tolerance=1e-006,
              Algorithm="Euler"),
            experimentSetupOutput,
            Icon(
              Text(extent=[-140,162; 136,102],  string="%name"),
              Ellipse(extent=[-100,100; 100,-100], style(
                  color=78,
                  rgbcolor={127,0,127},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Text(
                extent=[-100,100; 100,-80],
                string="ex",
                style(color=78, rgbcolor={127,0,127}))));
          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[-90,70; -70,
                90]);
          Modelica.Blocks.Interfaces.RealInput ControllerDesignInput
            "this input is needed for controller design"
            annotation (extent=[-134,-107; -100,-73],
                                                   rotation=0);
          MotorcycleLib.BasicBicycle.RigidRider.BicycleModel_3dof
            bicycleModel_3dof(
            p1={0.3,0.9,0},
            p2={0.9,0.7,0},
            p3={0.8,0.9,0},
            I_RF_11=9.2,
            I_RF_22=2.8,
            I_RF_33=11,
            I_RF_21=2.4,
            I_FF_11=0.0546,
            I_FF_33=0.06,
            I_FF_22=0.0114,
            I_FF_21=-0.0162,
            enforceStates=true,
            init_steerAngle=0)  annotation (extent=[-50,-30; 54,50]);
        equation
          connect(FWheelJoint.frame_b, FWheelMass.frame_a) annotation (points=[
                -69,-60; -51,-60], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(bicycleModel_3dof.connectFW, FWheelJoint.frame_b)
            annotation (points=[-53.2,-18; -60,-18; -60,-60; -69,-60], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(ControllerDesignInput, bicycleModel_3dof.T_Steering)
            annotation (points=[-117,-90; -2,-90; -2,-34.8], style(color=74,
                rgbcolor={0,0,127}));
          connect(bicycleModel_3dof.connectRW, RWheel.frame_b)
            annotation (points=[53.2,-22; 64,-22; 64,-60; 71,-60], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=70,
              rgbfillColor={45,96,172},
              fillPattern=1));
        end uncontrolled_3dof_bicycle;

        model uncontrolled_3dof_bicycle_AndresTires
          "Same model with tires from the WheelsAndTires Lib by Markus Andres"
          import MotorcycleLib;

          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 4;
          annotation (
            Diagram(             Text(
                extent=[-98,-94; -12,-102],
                style(
                  color=9,
                  rgbcolor={175,175,175},
                  thickness=4),
                string="... essential for controller design"),
              Text(
                extent=[-40,84; 104,56],
                string=
                    "... needed in combination with Tires provided by the WheelsAndTires library",
                style(
                  color=10,
                  rgbcolor={95,95,95},
                  fillColor=70,
                  rgbfillColor={45,96,172})),
              Rectangle(extent=[-64,84; 104,56], style(
                  color=9,
                  rgbcolor={175,175,175},
                  thickness=2))),
            experiment(StopTime=30),
            experimentSetupOutput,
            Icon(
              Text(extent=[-140,162; 136,102],  string="%name"),
              Ellipse(extent=[-100,100; 100,-100], style(
                  color=78,
                  rgbcolor={127,0,127},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Text(
                extent=[-100,100; 100,-80],
                string="ex",
                style(color=78, rgbcolor={127,0,127}))),
            Coordsys(extent=[-110,-100; 110,100], scale=0.1));

          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[-100,60;
                -80,80]);
          Modelica.Blocks.Interfaces.RealInput ControllerDesignInput
            "this input is needed for controller design"
            annotation (extent=[-134,-107; -100,-73],
                                                   rotation=0);
          WheelsAndTires.Tires.Slim.IdealTire RWheel(
            mRim=2,
            I_11=0.06,
            I_22=0.06,
            I_33=0.12,
            w_start=vs*{0,0,1/0.3},
            enforceStates=false,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            phi_start={5*Modelica.Constants.pi/180,0,0},
            rWheel=0.3,
            height=10e-3)
            annotation (extent=[68,-60; 108,-20], rotation=180);
          WheelsAndTires.Tires.Slim.IdealTire FWheel(
            mRim=3,
            I_11=0.14,
            I_22=0.14,
            I_33=0.28,
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            rWheel=0.35,
            height=10e-3)
            annotation (extent=[-68,-58; -108,-18], rotation=180);
          MotorcycleLib.BasicBicycle.RigidRider.BicycleModel_3dof
            bicycleModel_3dof(
            p1={0.3,0.9,0},
            p2={0.9,0.7,0},
            p3={0.8,0.9,0},
            I_RF_11=9.2,
            I_RF_22=2.8,
            I_RF_33=11,
            I_RF_21=2.4,
            I_FF_11=0.0546,
            I_FF_33=0.06,
            I_FF_22=0.0114,
            I_FF_21=-0.0162,
            enforceStates=true,
            init_steerAngle=0)  annotation (extent=[-52,-28; 52,52]);
          inner WheelsAndTires.Environment.Surface Surface
            annotation (extent=[-60,60; -40,80]);
        equation
          connect(ControllerDesignInput, bicycleModel_3dof.T_Steering)
            annotation (points=[-117,-90; -4,-90; -4,-32.8], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=70,
              rgbfillColor={45,96,172},
              fillPattern=1));
          connect(RWheel.TireHub, bicycleModel_3dof.connectRW) annotation (
              points=[68,-40; 60,-40; 60,-20; 51.2,-20], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(FWheel.TireHub, bicycleModel_3dof.connectFW) annotation (
              points=[-68,-38; -60,-38; -60,-16; -55.2,-16], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
        end uncontrolled_3dof_bicycle_AndresTires;

        function StabilityAnalysis
          "Stability analysis of an uncontrolled bicycle, plots eigenvalues as a function of bicycle's forward velocity"

          input String modelName = "MotorcycleLib.Examples.BenchmarkBicycle.RigidRider.uncontrolled_3dof_bicycle";
          input String independentVariableName = "vs";
          input Real startValue = 0 "lowest velocity";
          input Real endValue = 10 "highest velocity";
          input Integer n = 101 "Number of steps";

          input Real states[4] =  {7,8,3,4}
            "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

          input Integer plotSignals = 0
            "|Signals to plot| 0 ... real and imaginary eigenvalues; 1 ... real eigenvalues; 2 ... imaginary eigenvalues";

        algorithm
          MotorcycleLib.BasicBicycle.RigidRider.CalculateEigenvaluesBicycle(
                    modelName,
                    "vs",
                    startValue,
                    endValue,
                    n,
                    states,
                    plotSignals);
          annotation (Documentation(info="<HTML>

<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The function exploits
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.BasicBicycle.RigidRider.CalculateEigenvaluesBicycle\">BasicBicycle.RigidRider.CalculateEigenvaluesBicycle</a>]</span>.
</p>
</HTML>"));
        end StabilityAnalysis;

        function ControllerDesign
          "Controller design via pole-placement according to a preceding stability analysis"
          import SI = Modelica.SIunits;

          input String modelName = "MotorcycleLib.Examples.BenchmarkBicycle.RigidRider.uncontrolled_3dof_bicycle";
          input String independentVariableName = "vs";

          input SI.Velocity v = 10 "Forward velocity of the motorcycle";

          input Real d = 5
            "|Inputs for Controller Design| Real part of the offset";

          input Real states[4] = {7,8,3,4}
            "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

          output Real F[1, 4] "State Feedback Matrix";

        algorithm
          F := MotorcycleLib.ControllerDesign.RigidRider.place(
                    modelName,
                    "vs",
                    v,
                    d,
                    states);
          annotation (Documentation(info="<HTML>
<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The function exploits
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.ControllerDesign.RigidRider.place\">ControllerDesign.RigidRider.place</a>]</span>.
</p>
</HTML>"));
        end ControllerDesign;

        model controlled_3dof_bicycle
          import MotorcycleLib;

          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 3;
          MultiBondLib.Mechanics3D.RollingObjects.WheelJoint FWheelJoint(        rodColor=
               {128,0,0}, r=0.35)
                    annotation (extent=[-90,-30; -70,-10]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
            I_21=0,
            I_31=0,
            I_32=0,
            animation=false,
            m=3,
            I_11=0.14,
            I_22=0.14,
            I_33=0.28)
                 annotation (extent=[-50,-30; -30,-10]);
          MultiBondLib.Mechanics3D.RollingObjects.Wheel RWheel(
            m=2,
            I_11=0.06,
            I_22=0.06,
            I_33=0.12,
            r=0.3,
            w_start=vs*{0,0,1/0.3*180/Modelica.Constants.pi},
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            phi_start={0,5,0})  annotation (extent=[92,-30; 72,-10], rotation=0);
          annotation (
            Diagram,
            experiment(StopTime=10, Algorithm="Euler"),
            experimentSetupOutput,
            Icon(
              Text(extent=[-140,162; 136,102],  string="%name"),
              Ellipse(extent=[-100,100; 100,-100], style(
                  color=78,
                  rgbcolor={127,0,127},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Text(
                extent=[-100,100; 100,-80],
                string="ex",
                style(color=78, rgbcolor={127,0,127}))));
          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[-90,58;
                -70,78]);
          MotorcycleLib.BasicBicycle.RigidRider.BicycleModel_3dof
            bicycleModel_3dof(
            p1={0.3,0.9,0},
            p2={0.9,0.7,0},
            p3={0.8,0.9,0},
            I_RF_11=9.2,
            I_RF_22=2.8,
            I_RF_33=11,
            I_RF_21=2.4,
            I_FF_11=0.0546,
            I_FF_33=0.06,
            I_FF_22=0.0114,
            I_FF_21=-0.0162,
            enforceStates=true,
            init_steerAngle=0)  annotation (extent=[-50,-2; 54,78]);
          Modelica.Blocks.Sources.Constant const1(k=0*Modelica.Constants.pi/180)
            annotation (extent=[-90,-94; -70,-74]);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StateSpace_VR
            stateSpace_VR(
            p=1.02,
            eps=18.4349,
            F=[15.9523615979054,1.81106337719821,21.5057512252129,
                2.1654011773943])
            annotation (extent=[-40,-86; -10,-56]);
          Modelica.Blocks.Sources.Constant const2(k=vs)
            annotation (extent=[-90,-60; -70,-40]);
        equation
          connect(FWheelJoint.frame_b, FWheelMass.frame_a) annotation (points=[-69,-20;
                -51,-20],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(bicycleModel_3dof.connectFW, FWheelJoint.frame_b)
            annotation (points=[-53.2,10; -60,10; -60,-20; -69,-20],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(bicycleModel_3dof.connectRW, RWheel.frame_b)
            annotation (points=[53.2,6; 64,6; 64,-20; 71,-20],     style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=70,
              rgbfillColor={45,96,172},
              fillPattern=1));
          connect(stateSpace_VR.T_steer, bicycleModel_3dof.T_Steering)
                                                                annotation (
              points=[-8.5,-71; -2,-71; -2,-6.8], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=68,
              rgbfillColor={170,213,255},
              fillPattern=1));
          connect(const2.y, stateSpace_VR.v)
                                      annotation (points=[-69,-50; -60,-50; -60,
                -65; -43,-65], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=68,
              rgbfillColor={170,213,255},
              fillPattern=1));
          connect(const1.y, stateSpace_VR.phi_set)
                                            annotation (points=[-69,-84; -60,
                -84; -60,-77; -43,-77], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=68,
              rgbfillColor={170,213,255},
              fillPattern=1));
          connect(bicycleModel_3dof.steer_angle, stateSpace_VR.delta)
                                                               annotation (
              points=[-22,-6; -22,-46; -52,-46; -52,-59; -43,-59], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=68,
              rgbfillColor={170,213,255},
              fillPattern=1));
          connect(bicycleModel_3dof.phi, stateSpace_VR.phi)
                                                     annotation (points=[58,70;
                96,70; 96,-96; -52,-96; -52,-83; -43,-83], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=68,
              rgbfillColor={170,213,255},
              fillPattern=1));
        end controlled_3dof_bicycle;

        model LQR_3dof_bicycle
          import MotorcycleLib;

          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 4;
          MultiBondLib.Mechanics3D.RollingObjects.WheelJoint FWheelJoint(        rodColor=
               {128,0,0}, r=0.35)
                    annotation (extent=[-90,-22; -70,-2]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
            I_21=0,
            I_31=0,
            I_32=0,
            animation=false,
            m=3,
            I_11=0.14,
            I_22=0.14,
            I_33=0.28)
                 annotation (extent=[-50,-22; -30,-2]);
          MultiBondLib.Mechanics3D.RollingObjects.Wheel RWheel(
            m=2,
            I_11=0.06,
            I_22=0.06,
            I_33=0.12,
            r=0.3,
            w_start=vs*{0,0,1/0.3*180/Modelica.Constants.pi},
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            phi_start={0,5,0})  annotation (extent=[92,-22; 72,-2],  rotation=0);
          annotation (
            Diagram(Text(
                extent=[-92,-84; 94,-112],
                string=
                    "execute the MATLAB file \"LQR_Controller.m\" in order to caclulate the state feedback matrix",

                style(color=10, rgbcolor={95,95,95}))),
            experiment(StopTime=5, Algorithm="Dassl"),
            experimentSetupOutput,
            Icon(
              Text(extent=[-140,162; 136,102],  string="%name"),
              Ellipse(extent=[-100,100; 100,-100], style(
                  color=78,
                  rgbcolor={127,0,127},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Text(
                extent=[-100,100; 100,-80],
                string="ex",
                style(color=78, rgbcolor={127,0,127}))));
          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[-90,70;
                -70,90]);
          MotorcycleLib.BasicBicycle.RigidRider.BicycleModel_3dof
            bicycleModel_3dof(
            p1={0.3,0.9,0},
            p2={0.9,0.7,0},
            p3={0.8,0.9,0},
            I_RF_11=9.2,
            I_RF_22=2.8,
            I_RF_33=11,
            I_RF_21=2.4,
            I_FF_11=0.0546,
            I_FF_33=0.06,
            I_FF_22=0.0114,
            I_FF_21=-0.0162,
            enforceStates=true,
            init_steerAngle=0)  annotation (extent=[-50,6; 54,86]);
          Modelica.Blocks.Sources.Constant const1(k=0*Modelica.Constants.pi/180)
            annotation (extent=[-90,-86; -70,-66]);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.LQR_VR
            lQR_VR(                                                        F=[
                0.6038,0.0424,0.6934,0.0420],
            p=1.02,
            eps=18.4349)
            annotation (extent=[-40,-78; -10,-48]);
          Modelica.Blocks.Sources.Constant const2(k=vs)
            annotation (extent=[-90,-52; -70,-32]);
        equation
          connect(FWheelJoint.frame_b, FWheelMass.frame_a) annotation (points=[-69,-12;
                -51,-12],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(bicycleModel_3dof.connectFW, FWheelJoint.frame_b)
            annotation (points=[-53.2,18; -60,18; -60,-12; -69,-12],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(bicycleModel_3dof.connectRW, RWheel.frame_b)
            annotation (points=[53.2,14; 64,14; 64,-12; 71,-12],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=70,
              rgbfillColor={45,96,172},
              fillPattern=1));
          connect(lQR_VR.T_steer, bicycleModel_3dof.T_Steering) annotation (
              points=[-8.5,-63; -2,-63; -2,1.2],  style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=68,
              rgbfillColor={170,213,255},
              fillPattern=1));
          connect(const2.y, lQR_VR.v) annotation (points=[-69,-42; -60,-42; -60,
                -57; -43,-57], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=68,
              rgbfillColor={170,213,255},
              fillPattern=1));
          connect(const1.y, lQR_VR.phi_set) annotation (points=[-69,-76; -60,
                -76; -60,-69; -43,-69], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=68,
              rgbfillColor={170,213,255},
              fillPattern=1));
          connect(bicycleModel_3dof.steer_angle, lQR_VR.delta) annotation (
              points=[-22,2; -22,-38; -52,-38; -52,-51; -43,-51],  style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=68,
              rgbfillColor={170,213,255},
              fillPattern=1));
          connect(bicycleModel_3dof.phi, lQR_VR.phi) annotation (points=[58,78;
                96,78; 96,-88; -52,-88; -52,-75; -43,-75], style(
              color=74,
              rgbcolor={0,0,127},
              fillColor=68,
              rgbfillColor={170,213,255},
              fillPattern=1));
        end LQR_3dof_bicycle;
      end RigidRider;

      package MovableRider
        model uncontrolled_4dof_bicycle
          import MotorcycleLib;

          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 3;
          MultiBondLib.Mechanics3D.RollingObjects.WheelJoint FWheelJoint(        rodColor=
               {128,0,0}, r=0.35)
                    annotation (extent=[-90,-78; -70,-58]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
            I_21=0,
            I_31=0,
            I_32=0,
            animation=false,
            m=3,
            I_11=0.14,
            I_22=0.14,
            I_33=0.28)
                 annotation (extent=[-50,-78; -30,-58]);
          MultiBondLib.Mechanics3D.RollingObjects.Wheel RWheel(
            m=2,
            I_11=0.06,
            I_22=0.06,
            I_33=0.12,
            phi_start={0,5,0},
            r=0.3,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            enforceStates=false,
            w_start=vs*{0,0,1/0.3*180/Modelica.Constants.pi})
                                annotation (extent=[88,-78; 68,-58], rotation=0);
          annotation (
            Diagram(             Text(
                extent=[-98,-92; -12,-100],
                style(
                  color=9,
                  rgbcolor={175,175,175},
                  thickness=4),
                string="... essential for controller design"),
              Text(
                extent=[-51,85; 52,72],
                style(
                  color=70,
                  rgbcolor={45,96,172},
                  fillColor=70,
                  rgbfillColor={45,96,172}),
                string="Initial Conditions: initial steer angle = 0deg"),
              Text(
                extent=[-50,74; 53,68],
                style(
                  color=70,
                  rgbcolor={45,96,172},
                  fillColor=70,
                  rgbfillColor={45,96,172}),
                string="Advanced: enforce states = TRUE"),
              Line(points=[-54,88; -54,56; 54,56; 54,88; -28,88], style(
                  color=9,
                  rgbcolor={175,175,175},
                  thickness=2,
                  fillColor=70,
                  rgbfillColor={45,96,172},
                  fillPattern=1)),
              Text(
                extent=[-52,94; -30,84],
                style(
                  color=9,
                  rgbcolor={175,175,175},
                  thickness=4,
                  fillColor=70,
                  rgbfillColor={45,96,172},
                  fillPattern=1),
                string="Hints"),
              Text(
                extent=[-51,68; 53,59],
                style(
                  color=70,
                  rgbcolor={45,96,172},
                  fillColor=70,
                  rgbfillColor={45,96,172}),
                string="Initialization: Rear wheel: phi_start = {0,5,0}")),
            experiment(StopTime=10),
            experimentSetupOutput,
            Icon(
              Text(extent=[-140,162; 136,102],  string="%name"),
              Ellipse(extent=[-100,100; 100,-100], style(
                  color=78,
                  rgbcolor={127,0,127},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Text(
                extent=[-100,100; 100,-80],
                string="ex",
                style(color=78, rgbcolor={127,0,127}))));
          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[-90,70; -70,
                90]);
          MotorcycleLib.BasicBicycle.MovableRider.BicycleModel_4dof
            bicycleModel_4dof(
            p2={0.9,0.7,0},
            p3={0.8,0.9,0},
            p4={0.3,0.9,0},
            p1={0.345,0.765,0},
            p5={0.27,0.99,0},
            I_RF_11=3.869,
            I_RF_22=1.272,
            I_RF_33=4.667,
            I_RF_21=1.3,
            I_RUP_11=4.299,
            I_RUP_22=1.413,
            I_RUP_33=5.186,
            I_RUP_21=1.444,
            I_FF_11=0.0546,
            I_FF_22=0.0114,
            I_FF_33=0.06,
            I_FF_21=-0.0162,
            enforceStates=true,
            init_steerAngle=0)
                             annotation (extent=[-52,-54; 52,52]);
          Modelica.Blocks.Interfaces.RealInput SteeringTorque
            "this input is needed for controller design"
            annotation (extent=[-134,-105; -100,-71],
                                                   rotation=0);
          Modelica.Blocks.Interfaces.RealInput RiderTorque
            "this input is needed for controller design"
            annotation (extent=[-134,-15; -100,19],rotation=0);
        equation
          connect(FWheelJoint.frame_b, FWheelMass.frame_a) annotation (points=[-69,-68;
                -51,-68],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(RWheel.frame_b, bicycleModel_4dof.connectRW)     annotation (
              points=[67,-68; 60,-68; 60,-45.8462; 51.2,-45.8462], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(bicycleModel_4dof.connectFW, FWheelJoint.frame_b)
            annotation (points=[-55.2,-41.7692; -60,-41.7692; -60,-68; -69,-68],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(bicycleModel_4dof.T_Steering, SteeringTorque)
            annotation (points=[-4,-58.8923; -4,-88; -117,-88], style(color=74,
                rgbcolor={0,0,127}));
          connect(RiderTorque, bicycleModel_4dof.T_RiderLean)
            annotation (points=[-117,2; -86.7,2; -86.7,23.4615; -56.4,23.4615],
              style(color=74, rgbcolor={0,0,127}));
        end uncontrolled_4dof_bicycle;

        function StabilityAnalysis
          "Stability analysis of an uncontrolled bicycle, plots eigenvalues as a function of motorcycles's forward velocity"

          input String modelName = "MotorcycleLib.Examples.BenchmarkBicycle.MovableRider.uncontrolled_4dof_bicycle";
          input String independentVariableName = "vs";
          input Real startValue = 0 "lowest velocity";
          input Real endValue = 10 "highest velocity";
          input Integer n = 101 "Number of steps";

          input Real states[6] = {7, 8, 3, 4, 9, 10}
            "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle), rider lean angle, der(rider lean angle)";

          input Integer plotSignals = 0
            "|Signals to plot| 0 ... real and imaginary eigenvalues; 1 ... real eigenvalues; 2 ... imaginary eigenvalues";

        algorithm
          MotorcycleLib.AdvancedMotorcycle.StabilityAnalysis.CalculateEigenvaluesAdvancedMotorcycle(
                    modelName,
                    "vs",
                    startValue,
                    endValue,
                    n,
                    states,
                    plotSignals);
          annotation (Documentation(info="<HTML>
<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The function exploits
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.BasicBicycle.MovableRider.CalculateEigenvaluesBicycle_4dof\">BasicBicycle.RigidRider.CalculateEigenvaluesBicycle_4dof</a>]</span>.
</p>
</HTML>"));
        end StabilityAnalysis;

        model controlled_4dof_bicycle
          "controlled 4 d.o.f. bicycle; the controller is based on lqr (calculated with MATLAB)"
          import MotorcycleLib;

          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 3;
          MultiBondLib.Mechanics3D.RollingObjects.WheelJoint FWheelJoint(        rodColor=
               {128,0,0}, r=0.35)
                    annotation (extent=[-86,-50; -66,-30]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
            I_21=0,
            I_31=0,
            I_32=0,
            animation=false,
            m=3,
            I_11=0.14,
            I_22=0.14,
            I_33=0.28)
                 annotation (extent=[-46,-50; -26,-30]);
          MultiBondLib.Mechanics3D.RollingObjects.Wheel RWheel(
            m=2,
            I_11=0.06,
            I_22=0.06,
            I_33=0.12,
            r=0.3,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            w_start={0,0,0},
            enforceStates=false,
            phi_start={0,5,0})  annotation (extent=[90,-50; 70,-30], rotation=0);
          annotation (
            Diagram,
            experiment(StopTime=10),
            experimentSetupOutput,
            Icon(
              Text(extent=[-140,162; 136,102],  string="%name"),
              Ellipse(extent=[-100,100; 100,-100], style(
                  color=78,
                  rgbcolor={127,0,127},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Text(
                extent=[-100,100; 100,-80],
                string="ex",
                style(color=78, rgbcolor={127,0,127}))),
            Coordsys(extent=[-120,-120; 120,120], scale=0.1));
          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[-109,76;
                -89,96]);
          MotorcycleLib.BasicBicycle.MovableRider.BicycleModel_4dof
            bicycleModel_4dof(
            p2={0.9,0.7,0},
            p3={0.8,0.9,0},
            p4={0.3,0.9,0},
            p1={0.345,0.765,0},
            p5={0.27,0.99,0},
            I_RF_11=3.869,
            I_RF_22=1.272,
            I_RF_33=4.667,
            I_RF_21=1.3,
            I_RUP_11=4.299,
            I_RUP_22=1.413,
            I_RUP_33=5.186,
            I_RUP_21=1.444,
            I_FF_11=0.0546,
            I_FF_22=0.0114,
            I_FF_33=0.06,
            I_FF_21=-0.0162) annotation (extent=[-48,-8; 56,98]);
          MotorcycleLib.VirtualRider.VirtualMovableRider.RollAngleTracking.StateSpace_VMR
            stabilityController(F=[16.5667,1.6496,21.8597,1.3027,0.6104,0.1844;
                -79.5174,-11.4260,-109.7068,4.2119,65.8985,30.5641])
            annotation (extent=[-38,-102; -8,-72]);
          Modelica.Blocks.Sources.Constant const(k=vs)
            annotation (extent=[-120,-70; -100,-50]);
          MotorcycleLib.VirtualRider.VelocityControl.SpeedController
            speedController(r=0.3)
            annotation (extent=[12,-70; 32,-50]);
          Modelica.Blocks.Sources.Constant const1(k=0*Modelica.Constants.pi/180)
            annotation (extent=[-120,-106; -100,-86]);
        equation
          connect(FWheelJoint.frame_b, FWheelMass.frame_a) annotation (points=[-65,-40;
                -47,-40],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(RWheel.frame_b, bicycleModel_4dof.connectRW)     annotation (
              points=[69,-40; 64,-40; 64,0.153846; 55.2,0.153846], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(bicycleModel_4dof.connectFW, FWheelJoint.frame_b)
            annotation (points=[-51.2,4.23077; -56,4.23077; -56,-40; -65,-40],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(stabilityController.T_steer, bicycleModel_4dof.T_Steering)
            annotation (points=[-6.5,-81; 0,-81; 0,-12.8923], style(color=74,
                rgbcolor={0,0,127}));
          connect(stabilityController.T_Rider, bicycleModel_4dof.T_RiderLean)
            annotation (points=[-6.5,-93; 6,-93; 6,-25; -66,-25; -66,69; -56,69;
                -56,70; -54,70; -54,69.4615; -52.4,69.4615], style(color=74,
                rgbcolor={0,0,127}));
          connect(speedController.T_engine, bicycleModel_4dof.T_engine)
            annotation (points=[33,-60; 40,-60; 40,-12.8923], style(color=74,
                rgbcolor={0,0,127}));
          connect(bicycleModel_4dof.w, speedController.w)     annotation (
              points=[60,20.5385; 96,20.5385; 96,-80; 22,-80; 22,-72], style(
                color=74, rgbcolor={0,0,127}));
          connect(const.y, speedController.v) annotation (points=[-99,-60; 10,
                -60], style(color=74, rgbcolor={0,0,127}));
          connect(stabilityController.v, const.y) annotation (points=[-41,-78;
                -70,-78; -70,-60; -99,-60], style(color=74, rgbcolor={0,0,127}));
          connect(bicycleModel_4dof.steer_angle, stabilityController.delta)
            annotation (points=[-16,-12.0769; -16,-64; -50,-64; -50,-72; -41,
                -72], style(color=74, rgbcolor={0,0,127}));
          connect(const1.y, stabilityController.phi_set) annotation (points=[
                -99,-96; -70,-96; -70,-84; -41,-84], style(color=74, rgbcolor={
                  0,0,127}));
          connect(const1.y, stabilityController.phi_rider_set) annotation (
              points=[-99,-96; -41,-96], style(color=74, rgbcolor={0,0,127}));
          connect(stabilityController.phi_rider, bicycleModel_4dof.riderLeanAngle)
            annotation (points=[-41,-102; -50,-102; -50,-114; 112,-114; 112,
                69.4615; 60,69.4615], style(color=74, rgbcolor={0,0,127}));
          connect(bicycleModel_4dof.phi, stabilityController.phi)     annotation (
             points=[60,45; 104,45; 104,-108; -58,-108; -58,-90; -41,-90],
              style(color=74, rgbcolor={0,0,127}));
        end controlled_4dof_bicycle;

        model LQR_4dof_bicycle
          "controlled 4 d.o.f. bicycle; the controller is based on lqr (calculated with MATLAB)"
          import MotorcycleLib;

          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 3;
          MultiBondLib.Mechanics3D.RollingObjects.WheelJoint FWheelJoint(        rodColor=
               {128,0,0}, r=0.35)
                    annotation (extent=[-86,-50; -66,-30]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
            I_21=0,
            I_31=0,
            I_32=0,
            animation=false,
            m=3,
            I_11=0.14,
            I_22=0.14,
            I_33=0.28)
                 annotation (extent=[-46,-50; -26,-30]);
          MultiBondLib.Mechanics3D.RollingObjects.Wheel RWheel(
            m=2,
            I_11=0.06,
            I_22=0.06,
            I_33=0.12,
            r=0.3,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            w_start={0,0,0},
            enforceStates=false,
            phi_start={0,0,0})  annotation (extent=[90,-50; 70,-30], rotation=0);
          annotation (
            Diagram,
            experiment(StopTime=10),
            experimentSetupOutput,
            Icon(
              Text(extent=[-140,162; 136,102],  string="%name"),
              Ellipse(extent=[-100,100; 100,-100], style(
                  color=78,
                  rgbcolor={127,0,127},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Text(
                extent=[-100,100; 100,-80],
                string="ex",
                style(color=78, rgbcolor={127,0,127}))),
            Coordsys(extent=[-120,-120; 120,120], scale=0.1));
          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[-110,88;
                -90,108]);
          MotorcycleLib.BasicBicycle.MovableRider.BicycleModel_4dof
            bicycleModel_4dof(
            p2={0.9,0.7,0},
            p3={0.8,0.9,0},
            p4={0.3,0.9,0},
            p1={0.345,0.765,0},
            p5={0.27,0.99,0},
            I_RF_11=3.869,
            I_RF_22=1.272,
            I_RF_33=4.667,
            I_RF_21=1.3,
            I_RUP_11=4.299,
            I_RUP_22=1.413,
            I_RUP_33=5.186,
            I_RUP_21=1.444,
            I_FF_11=0.0546,
            I_FF_22=0.0114,
            I_FF_33=0.06,
            I_FF_21=-0.0162) annotation (extent=[-48,-8; 56,98]);
          MotorcycleLib.VirtualRider.VirtualMovableRider.RollAngleTracking.LQR_VMR
            stabilityController(F=[28.1962,2.5176,51.0262,7.3671,-33.9664,-9.0695;
                -14.2983,-0.6687,3.7947,11.6672,78.9845,23.2098])
            annotation (extent=[-38,-102; -8,-72]);
          Modelica.Blocks.Sources.Constant const(k=vs)
            annotation (extent=[-120,-70; -100,-50]);
          MotorcycleLib.VirtualRider.VelocityControl.SpeedController
            speedController
            annotation (extent=[12,-70; 32,-50]);
          Modelica.Blocks.Sources.Constant const1(k=0*Modelica.Constants.pi/180)
            annotation (extent=[-120,-106; -100,-86]);
        equation
          connect(FWheelJoint.frame_b, FWheelMass.frame_a) annotation (points=[-65,-40;
                -47,-40],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(RWheel.frame_b, bicycleModel_4dof.connectRW)     annotation (
              points=[69,-40; 64,-40; 64,0.153846; 55.2,0.153846], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(bicycleModel_4dof.connectFW, FWheelJoint.frame_b)
            annotation (points=[-51.2,4.23077; -56,4.23077; -56,-40; -65,-40],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(stabilityController.T_steer, bicycleModel_4dof.T_Steering)
            annotation (points=[-6.5,-81; 0,-81; 0,-12.8923], style(color=74,
                rgbcolor={0,0,127}));
          connect(stabilityController.T_Rider, bicycleModel_4dof.T_RiderLean)
            annotation (points=[-6.5,-93; 6,-93; 6,-25; -66,-25; -66,69; -56,69;
                -56,70; -54,70; -54,69.4615; -52.4,69.4615], style(color=74,
                rgbcolor={0,0,127}));
          connect(speedController.T_engine, bicycleModel_4dof.T_engine)
            annotation (points=[33,-60; 40,-60; 40,-12.8923], style(color=74,
                rgbcolor={0,0,127}));
          connect(bicycleModel_4dof.w, speedController.w)     annotation (
              points=[60,20.5385; 96,20.5385; 96,-80; 22,-80; 22,-72], style(
                color=74, rgbcolor={0,0,127}));
          connect(const.y, speedController.v) annotation (points=[-99,-60; 10,
                -60], style(color=74, rgbcolor={0,0,127}));
          connect(stabilityController.v, const.y) annotation (points=[-41,-78;
                -70,-78; -70,-60; -99,-60], style(color=74, rgbcolor={0,0,127}));
          connect(bicycleModel_4dof.steer_angle, stabilityController.delta)
            annotation (points=[-16,-12.0769; -16,-64; -50,-64; -50,-72; -41,
                -72], style(color=74, rgbcolor={0,0,127}));
          connect(const1.y, stabilityController.phi_set) annotation (points=[
                -99,-96; -70,-96; -70,-84; -41,-84], style(color=74, rgbcolor={
                  0,0,127}));
          connect(const1.y, stabilityController.phi_rider_set) annotation (
              points=[-99,-96; -41,-96], style(color=74, rgbcolor={0,0,127}));
          connect(stabilityController.phi_rider, bicycleModel_4dof.riderLeanAngle)
            annotation (points=[-41,-102; -50,-102; -50,-112; 112,-112; 112,
                69.4615; 60,69.4615], style(color=74, rgbcolor={0,0,127}));
          connect(bicycleModel_4dof.phi, stabilityController.phi)     annotation (
             points=[60,45; 102,45; 102,-108; -60,-108; -60,-90; -41,-90],
              style(color=74, rgbcolor={0,0,127}));
        end LQR_4dof_bicycle;

        model LQR_4dof_bicycle_openLoop
          "controlled 4 d.o.f. bicycle; the controller is based on lqr (calculated with MATLAB)"
          import MotorcycleLib;

          import SI = Modelica.SIunits;

          parameter SI.Velocity v = 3;
          MultiBondLib.Mechanics3D.RollingObjects.WheelJoint FWheelJoint(        rodColor=
               {128,0,0}, r=0.35)
                    annotation (extent=[-86,-50; -66,-30]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
            I_21=0,
            I_31=0,
            I_32=0,
            animation=false,
            m=3,
            I_11=0.14,
            I_22=0.14,
            I_33=0.28)
                 annotation (extent=[-46,-50; -26,-30]);
          annotation (
            Diagram,
            experiment(StopTime=30),
            experimentSetupOutput,
            Icon(
              Text(extent=[-140,162; 136,102],  string="%name"),
              Ellipse(extent=[-100,100; 100,-100], style(
                  color=78,
                  rgbcolor={127,0,127},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Text(
                extent=[-100,100; 100,-80],
                string="ex",
                style(color=78, rgbcolor={127,0,127}))),
            Coordsys(extent=[-120,-120; 120,120], scale=0.1));

          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[-110,88;
                -90,108]);
          MotorcycleLib.BasicBicycle.MovableRider.BicycleModel_4dof
            bicycleModel_4dof(
            p2={0.9,0.7,0},
            p3={0.8,0.9,0},
            p4={0.3,0.9,0},
            p1={0.345,0.765,0},
            p5={0.27,0.99,0},
            I_RF_11=3.869,
            I_RF_22=1.272,
            I_RF_33=4.667,
            I_RF_21=1.3,
            I_RUP_11=4.299,
            I_RUP_22=1.413,
            I_RUP_33=5.186,
            I_RUP_21=1.444,
            I_FF_11=0.0546,
            I_FF_22=0.0114,
            I_FF_33=0.06,
            I_FF_21=-0.0162,
            enforceStates=true,
            init_steerAngle=0)
                             annotation (extent=[-48,-8; 56,98]);
          MotorcycleLib.VirtualRider.VirtualMovableRider.RollAngleTracking.LQR_VMR
            stabilityController(F=[28.1962,2.5176,51.0262,7.3671,-33.9664,-9.0695;
                -14.2983,-0.6687,3.7947,11.6672,78.9845,23.2098],
            p=1.02,
            eps=18.4349)
            annotation (extent=[-38,-102; -8,-72]);
          Modelica.Blocks.Sources.Constant const(k=v)
            annotation (extent=[-120,-70; -100,-50]);
          MotorcycleLib.VirtualRider.VelocityControl.SpeedController
            speedController
            annotation (extent=[12,-70; 32,-50]);
          MultiBondLib.Mechanics3D.RollingObjects.Wheel RWheel(
            m=2,
            I_11=0.06,
            I_22=0.06,
            I_33=0.12,
            r=0.3,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            w_start={0,0,0},
            enforceStates=false,
            phi_start={0,0,0})  annotation (extent=[90,-50; 70,-30], rotation=0);
          MotorcycleLib.Environments.Tracks.OpenLoopMethod.Curve_90degree
            standard_90degree_curve(v=v, table=curve90degree_4dof_bicycle.table)
            annotation (extent=[-120,-106; -100,-86]);
          MotorcycleLib.Environments.Tracks.OpenLoopMethod.Data.Curve90degree_4dof_bicycle
            curve90degree_4dof_bicycle(v=v)
            annotation (extent=[-72,88; -52,108]);
        equation
          connect(FWheelJoint.frame_b, FWheelMass.frame_a) annotation (points=[-65,-40;
                -47,-40],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=7,
              rgbfillColor={255,255,255},
              fillPattern=1));
          connect(bicycleModel_4dof.connectFW, FWheelJoint.frame_b)
            annotation (points=[-51.2,4.23077; -56,4.23077; -56,-40; -65,-40],
              style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(stabilityController.T_Rider, bicycleModel_4dof.T_RiderLean)
            annotation (points=[-6.5,-93; 6,-93; 6,-25; -66,-25; -66,69; -56,69;
                -56,70; -54,70; -54,69.4615; -52.4,69.4615], style(color=74,
                rgbcolor={0,0,127}));
          connect(speedController.T_engine, bicycleModel_4dof.T_engine)
            annotation (points=[33,-60; 40,-60; 40,-12.8923], style(color=74,
                rgbcolor={0,0,127}));
          connect(bicycleModel_4dof.w, speedController.w)     annotation (
              points=[60,20.5385; 96,20.5385; 96,-80; 22,-80; 22,-72], style(
                color=74, rgbcolor={0,0,127}));
          connect(const.y, speedController.v) annotation (points=[-99,-60; 10,
                -60], style(color=74, rgbcolor={0,0,127}));
          connect(stabilityController.v, const.y) annotation (points=[-41,-78;
                -70,-78; -70,-60; -99,-60], style(color=74, rgbcolor={0,0,127}));
          connect(bicycleModel_4dof.steer_angle, stabilityController.delta)
            annotation (points=[-16,-12.0769; -16,-64; -50,-64; -50,-72; -41,
                -72], style(color=74, rgbcolor={0,0,127}));
          connect(stabilityController.phi_rider, bicycleModel_4dof.riderLeanAngle)
            annotation (points=[-41,-102; -50,-102; -50,-112; 108,-112; 108,
                69.4615; 60,69.4615], style(color=74, rgbcolor={0,0,127}));
          connect(bicycleModel_4dof.phi, stabilityController.phi)
            annotation (points=[60,45; 104,45; 104,-108; -60,-108; -60,-90; -41,
                -90], style(color=74, rgbcolor={0,0,127}));
          connect(bicycleModel_4dof.connectRW, RWheel.frame_b) annotation (
              points=[55.2,0.153846; 64,0.153846; 64,-40; 69,-40], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(stabilityController.T_steer, bicycleModel_4dof.T_Steering)
            annotation (points=[-6.5,-81; 0,-81; 0,-12.8923], style(color=74,
                rgbcolor={0,0,127}));
          connect(standard_90degree_curve.leanAngle, stabilityController.phi_rider_set)
            annotation (points=[-99,-96; -41,-96], style(color=74, rgbcolor={0,
                  0,127}));
          connect(standard_90degree_curve.leanAngle, stabilityController.phi_set)
            annotation (points=[-99,-96; -70,-96; -70,-84; -41,-84], style(
                color=74, rgbcolor={0,0,127}));
        end LQR_4dof_bicycle_openLoop;
      end MovableRider;
    end BenchmarkBicycle;

    package BasicMotorcycle
      model uncontrolled_3dof_motorcycle "uncontrolled motorcycle model"
        import SI = Modelica.SIunits;

        parameter SI.Velocity vs = 6;

        MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
          motorcycle_Vittore_complete(
          I_RF_11=31.2,
          I_RF_22=21.08,
          I_RF_33=0,
          I_RF_21=1.74,
          p2={0.024,0.461,0},
          p1={0.48,0.616,0},
          d=6.8,
          I_FF_33=0,
          I_FF_11=1.23,
          I_FF_22=0.44,
          I_FF_21=0,
          enforceStates=true,
          rFW=0.305)
                 annotation (extent=[-60,-39; 60,51]);
        MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false,
          I_11=0,
          I_22=0,
          I_33=0.72,
          m=1) annotation (extent=[-62,-64; -42,-44]);
        IdealWheels.Wheel wheel(
          r=0.305,
          I_11=0,
          I_22=0,
          I_33=1.05,
          m=1,
          useTransVelocities=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          w_start=vs*{0,0,1/0.305*180/Modelica.Constants.pi},
          enforceStates=false,
          phi_start={0,5,0})   annotation (extent=[94,-64; 74,-44]);
        MotorcycleLib.IdealWheels.WheelJoint wheelJoint(r=0.305)
          annotation (extent=[-94,-64; -74,-44]);
        inner MultiBondLib.Mechanics3D.World3D world3D
          annotation (extent=[-90,70; -70,90]);
        Modelica.Blocks.Interfaces.RealInput ControllerDesignInput
          "this input is needed for controller design"
          annotation (extent=[-96,-105; -62,-71],rotation=0);
      equation
        connect(wheelJoint.frame_b,FWheelMass. frame_a) annotation (points=[-73,-54;
              -63,-54],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        annotation (
          Diagram(             Text(
              extent=[-60,-92; 26,-100],
              style(
                color=9,
                rgbcolor={175,175,175},
                thickness=4),
              string="... essential for controller design"),
            Text(
              extent=[-51,85; 52,72],
              style(
                color=70,
                rgbcolor={45,96,172},
                fillColor=70,
                rgbfillColor={45,96,172}),
              string="Initial Conditions: initial steer angle = 0deg"),
            Text(
              extent=[-50,74; 53,68],
              style(
                color=70,
                rgbcolor={45,96,172},
                fillColor=70,
                rgbfillColor={45,96,172}),
              string="Advanced: enforce states = TRUE"),
            Line(points=[-54,88; -54,56; 54,56; 54,88; -28,88], style(
                color=9,
                rgbcolor={175,175,175},
                thickness=2,
                fillColor=70,
                rgbfillColor={45,96,172},
                fillPattern=1)),
            Text(
              extent=[-52,94; -30,84],
              style(
                color=9,
                rgbcolor={175,175,175},
                thickness=4,
                fillColor=70,
                rgbfillColor={45,96,172},
                fillPattern=1),
              string="Hints"),
            Text(
              extent=[-51,68; 53,59],
              style(
                color=70,
                rgbcolor={45,96,172},
                fillColor=70,
                rgbfillColor={45,96,172}),
              string="Initialization: Rear wheel: phi_start = {0,5,0}")),
          experiment(StopTime=25),
          experimentSetupOutput,
          DymolaStoredErrors,
          Icon(
            Text(extent=[-140,162; 136,102],  string="%name"),
            Ellipse(extent=[-100,100; 100,-100], style(
                color=78,
                rgbcolor={127,0,127},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,100; 100,-80],
              string="ex",
              style(color=78, rgbcolor={127,0,127}))));
        connect(wheel.frame_b, motorcycle_Vittore_complete.connectRW) annotation (
           points=[73,-54; 68,-54; 68,-16.5; 59.0769,-16.5],
                                                           style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(motorcycle_Vittore_complete.connectFW, wheelJoint.frame_b)
          annotation (points=[-63.6923,-16.5; -68,-16.5; -68,-54; -73,-54],
                                                                        style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(motorcycle_Vittore_complete.T_Steering, ControllerDesignInput)
                                                           annotation (points=[0,-44.4;
              0,-88; -79,-88],          style(color=74, rgbcolor={0,0,127}));
      end uncontrolled_3dof_motorcycle;

      model uncontrolled_3dof_motorcycle_PT
        "uncontrolled motorcycle model including a path preview model in order to develop a controller"
        import SI = Modelica.SIunits;

        parameter SI.Velocity vs = 6;

        MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
          motorcycle_Vittore_complete(
          I_RF_11=31.2,
          I_RF_22=21.08,
          I_RF_33=0,
          I_RF_21=1.74,
          p2={0.024,0.461,0},
          p1={0.48,0.616,0},
          d=6.8,
          I_FF_33=0,
          I_FF_11=1.23,
          I_FF_22=0.44,
          I_FF_21=0,
          enforceStates=true,
          rFW=0.305)
                 annotation (extent=[-60,-39; 60,51]);
        MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false,
          I_11=0,
          I_22=0,
          I_33=0.72,
          m=1) annotation (extent=[-62,-64; -42,-44]);
        IdealWheels.Wheel wheel(
          r=0.305,
          I_11=0,
          I_22=0,
          I_33=1.05,
          m=1,
          useTransVelocities=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          w_start=vs*{0,0,1/0.305*180/Modelica.Constants.pi},
          enforceStates=false,
          phi_start={0,5,0})   annotation (extent=[94,-64; 74,-44]);
        MotorcycleLib.IdealWheels.WheelJoint wheelJoint(r=0.305)
          annotation (extent=[-94,-64; -74,-44]);
        inner MultiBondLib.Mechanics3D.World3D world3D
          annotation (extent=[-90,70; -70,90]);
        Modelica.Blocks.Interfaces.RealInput ControllerDesignInput
          "this input is needed for controller design"
          annotation (extent=[-96,-105; -62,-71],rotation=0);
        Environments.Tracks.ClosedLoopMethod.PathPreview_StateSpace pathPreview(
                      height=0.616, preview=6)
                      annotation (extent=[42,-92; 62,-72]);
      equation
        connect(wheelJoint.frame_b,FWheelMass. frame_a) annotation (points=[-73,-54;
              -63,-54],      style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        annotation (
          Diagram(             Text(
              extent=[-60,-92; 26,-100],
              style(
                color=9,
                rgbcolor={175,175,175},
                thickness=4),
              string="... essential for controller design"),
            Text(
              extent=[-51,85; 52,72],
              style(
                color=70,
                rgbcolor={45,96,172},
                fillColor=70,
                rgbfillColor={45,96,172}),
              string="Initial Conditions: initial steer angle = 0deg"),
            Text(
              extent=[-50,74; 53,68],
              style(
                color=70,
                rgbcolor={45,96,172},
                fillColor=70,
                rgbfillColor={45,96,172}),
              string="Advanced: enforce states = TRUE"),
            Line(points=[-54,88; -54,56; 54,56; 54,88; -28,88], style(
                color=9,
                rgbcolor={175,175,175},
                thickness=2,
                fillColor=70,
                rgbfillColor={45,96,172},
                fillPattern=1)),
            Text(
              extent=[-52,94; -30,84],
              style(
                color=9,
                rgbcolor={175,175,175},
                thickness=4,
                fillColor=70,
                rgbfillColor={45,96,172},
                fillPattern=1),
              string="Hints"),
            Text(
              extent=[-51,68; 53,59],
              style(
                color=70,
                rgbcolor={45,96,172},
                fillColor=70,
                rgbfillColor={45,96,172}),
              string="Initialization: Rear wheel: phi_start = {0,5,0}")),
          experiment(StopTime=25),
          experimentSetupOutput,
          DymolaStoredErrors,
          Icon(
            Text(extent=[-140,162; 136,102],  string="%name"),
            Ellipse(extent=[-100,100; 100,-100], style(
                color=78,
                rgbcolor={127,0,127},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,100; 100,-80],
              string="ex",
              style(color=78, rgbcolor={127,0,127}))));
        connect(wheel.frame_b, motorcycle_Vittore_complete.connectRW) annotation (
           points=[73,-54; 68,-54; 68,-16.5; 59.0769,-16.5],
                                                           style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(motorcycle_Vittore_complete.connectFW, wheelJoint.frame_b)
          annotation (points=[-63.6923,-16.5; -68,-16.5; -68,-54; -73,-54],
                                                                        style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(motorcycle_Vittore_complete.T_Steering, ControllerDesignInput)
                                                           annotation (points=[0,-44.4;
              0,-88; -79,-88],          style(color=74, rgbcolor={0,0,127}));
        connect(pathPreview.frame_a, motorcycle_Vittore_complete.CoM_RearFrame)
          annotation (points=[62,-80; 100,-80; 100,41.1; 59.0769,41.1], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end uncontrolled_3dof_motorcycle_PT;

      model uncontrolled_3dof_motorcycle_AndresTires
        "uncontrolled motorcycle model with wheels from M. Andres' WheelsAndTires library"
        import SI = Modelica.SIunits;

        parameter SI.Velocity vs = 15;

        MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
          motorcycle_Vittore_complete(
          I_RF_11=31.2,
          I_RF_22=21.08,
          I_RF_33=0,
          I_RF_21=1.74,
          p2={0.024,0.461,0},
          p1={0.48,0.616,0},
          d=6.8,
          I_FF_33=0,
          I_FF_11=1.23,
          I_FF_22=0.44,
          I_FF_21=0,
          enforceStates=true)
                 annotation (extent=[-60,-57; 60,33]);
        inner MultiBondLib.Mechanics3D.World3D world3D
          annotation (extent=[-100,60; -80,80]);
        annotation (
          Diagram(
            Text(
              extent=[-40,84; 104,56],
              string=
                  "... needed in combination with Tires provided by the WheelsAndTires library",
              style(
                color=10,
                rgbcolor={95,95,95},
                fillColor=70,
                rgbfillColor={45,96,172})), Rectangle(extent=[-64,84; 104,56], style(
                color=9,
                rgbcolor={175,175,175},
                thickness=2))),
          experiment(StopTime=25),
          experimentSetupOutput,
          DymolaStoredErrors,
          Icon(
            Text(extent=[-140,162; 136,102],  string="%name"),
            Ellipse(extent=[-100,100; 100,-100], style(
                color=78,
                rgbcolor={127,0,127},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,100; 100,-80],
              string="ex",
              style(color=78, rgbcolor={127,0,127}))),
          Coordsys(extent=[-110,-100; 110,100], scale=0.1));

        WheelsAndTires.Tires.Slim.IdealTire FWheel(
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          I_11=0,
          I_22=0,
          I_33=0.72,
          mRim=1e-3,
          visForcesEnabled=false,
          visBeltEnabled=true,
          visContactPointEnabled=true,
          rWheel=0.305,
          height=20e-3)
          annotation (extent=[-70,-80; -110,-40], rotation=180);
        WheelsAndTires.Tires.Slim.IdealTire RWheel(
          enforceStates=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          phi_start={5*Modelica.Constants.pi/180,0,0},
          I_11=0,
          I_22=0,
          I_33=1.05,
          mRim=1e-3,
          visForcesEnabled=false,
          rWheel=0.305,
          height=20e-3,
          w_start=vs*{0,0,1/0.305})
          annotation (extent=[70,-80; 110,-40], rotation=180);
        inner WheelsAndTires.Environment.Surface Surface(visSurface=false)
          annotation (extent=[-60,60; -40,80]);
      equation
        connect(RWheel.TireHub, motorcycle_Vittore_complete.connectRW) annotation (
            points=[70,-60; 66,-60; 66,-34.5; 59.0769,-34.5], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(FWheel.TireHub, motorcycle_Vittore_complete.connectFW) annotation (
            points=[-70,-60; -66,-60; -66,-34.5; -63.6923,-34.5], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end uncontrolled_3dof_motorcycle_AndresTires;

      function StabilityAnalysis
        "Stability analysis of an uncontrolled motorcycle, plots eigenvalues as a function of bicycle's forward velocity"

        input String modelName = "MotorcycleLib.Examples.BasicMotorcycle.uncontrolled_3dof_motorcycle";
        input String independentVariableName = "vs";
        input Real startValue = 0 "lowest velocity";
        input Real endValue = 12 "highest velocity";
        input Integer n = 101 "Number of steps";

        input Real states[4] =  {5,6,1,2}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

        input Integer plotSignals = 0
          "|Signals to plot| 0 ... real and imaginary eigenvalues; 1 ... real eigenvalues; 2 ... imaginary eigenvalues";

      algorithm
        MotorcycleLib.BasicMotorcycle.CalculateEigenvaluesMotorcycle(
                modelName,
                "vs",
                startValue,
                endValue,
                n,
                states,
                plotSignals);
        annotation (Documentation(info="<HTML>

<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The function exploits
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.BasicMotorcycle.CalculateEigenvaluesMotorcycle\">Examples.BasicMotorcycle.CalculateEigenvaluesMotorcycle</a>]</span>.
</p>
</HTML>"));
      end StabilityAnalysis;

      model ClassicControlled_3dof_motorcycle
        import MotorcycleLib;
        import SI = Modelica.SIunits;

        parameter SI.Velocity vs = 6;
        MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
          motorcycle_Vittore_complete(
          p1={0.48,0.616,0},
          p2={0.024,0.461,0},
          d=6.8,
          enforceStates=true)
          annotation (extent=[-51,-10; 53,70]);
        MotorcycleLib.VirtualRider.VelocityControl.SpeedController
          speedController
          annotation (extent=[20,-50; 40,-30]);
        MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false,
          I_11=0,
          I_22=0,
          I_33=0.72,
          m=1) annotation (extent=[-62,-18; -42,2]);
        MotorcycleLib.IdealWheels.Wheel wheel(
          r=0.305,
          I_11=0,
          I_22=0,
          I_33=1.05,
          m=1,
          useTransVelocities=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          enforceStates=false,
          w_start=0*{0,0,1/0.305*180/Modelica.Constants.pi},
          phi_start={0,5,0})   annotation (extent=[84,-18; 64,2],   rotation=0);
        MotorcycleLib.IdealWheels.WheelJoint wheelJoint(
                                                   r=0.305)
          annotation (extent=[-98,-18; -78,2]);
        inner MultiBondLib.Mechanics3D.World3D world3D
          annotation (extent=[-90,50; -70,70]);
        Modelica.Blocks.Sources.Constant const(k=vs)
          annotation (extent=[-90,-50; -70,-30]);
        MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.Classic_VR
          classic_StabilityController(
          Tmax=5,
          k=20,
          Ti=2.5,
          Td=0.001)
                  annotation (extent=[-48,-74; -18,-44]);
        Modelica.Blocks.Sources.Constant const1(k=35*Modelica.Constants.pi/180)
          annotation (extent=[-90,-88; -70,-68]);
      equation
        connect(wheelJoint.frame_b,FWheelMass. frame_a) annotation (points=[-77,-8;
              -63,-8],       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(wheelJoint.frame_b, motorcycle_Vittore_complete.connectFW)
          annotation (points=[-77,-8; -70,-8; -70,10; -54.2,10],   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        annotation (Diagram,
          experiment(StopTime=15),
          experimentSetupOutput,
          Icon(
            Text(extent=[-140,162; 136,102],  string="%name"),
            Ellipse(extent=[-100,100; 100,-100], style(
                color=78,
                rgbcolor={127,0,127},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,100; 100,-80],
              string="ex",
              style(color=78, rgbcolor={127,0,127}))));
        connect(speedController.T_engine, motorcycle_Vittore_complete.T_engine)
          annotation (points=[41,-40; 49,-40; 49,-14.8],style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(motorcycle_Vittore_complete.w, speedController.w) annotation (
            points=[57,26; 86,26; 86,-66; 30,-66; 30,-52], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(const.y, speedController.v) annotation (points=[-69,-40; 18,-40],
            style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(wheel.frame_b, motorcycle_Vittore_complete.connectRW)
          annotation (points=[63,-8; 60,-8; 60,10; 52.2,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(motorcycle_Vittore_complete.phi, classic_StabilityController.phi)
          annotation (points=[57,46; 94,46; 94,-88; -56,-88; -56,-68; -51,-68],
            style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=51,
            rgbfillColor={255,255,170},
            fillPattern=1));
        connect(const1.y, classic_StabilityController.phi_set) annotation (
            points=[-69,-78; -62,-78; -62,-50; -51,-50], style(color=74,
              rgbcolor={0,0,127}));
        connect(classic_StabilityController.SteeringTorque,
          motorcycle_Vittore_complete.T_Steering) annotation (points=[-16.5,-59;
              1,-59; 1,-14.8], style(color=74, rgbcolor={0,0,127}));
      end ClassicControlled_3dof_motorcycle;

      model Controlled_3dof_motorcycle_simple
        import MotorcycleLib;

        import SI = Modelica.SIunits;
        parameter SI.Velocity vs = 6;
        MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
          motorcycle_Vittore_complete(
          p1={0.48,0.616,0},
          p2={0.024,0.461,0},
          d=6.8,
          enforceStates=true)
          annotation (extent=[-45,4; 59,84]);
        MotorcycleLib.VirtualRider.VelocityControl.SpeedController
          speedController
          annotation (extent=[20,-36; 40,-16]);
        MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false,
          I_11=0,
          I_22=0,
          I_33=0.72,
          m=1) annotation (extent=[-56,-4; -36,16]);
        MotorcycleLib.IdealWheels.Wheel wheel(
          r=0.305,
          I_11=0,
          I_22=0,
          I_33=1.05,
          m=1,
          useTransVelocities=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          enforceStates=false,
          phi_start={0,0,0},
          w_start=0*{0,0,1/0.305*180/Modelica.Constants.pi})
                               annotation (extent=[90,-4; 70,16],   rotation=0);
        MotorcycleLib.IdealWheels.WheelJoint wheelJoint(
                                                   r=0.305)
          annotation (extent=[-92,-4; -72,16]);
        inner MultiBondLib.Mechanics3D.World3D world3D
          annotation (extent=[-90,70; -70,90]);
        Modelica.Blocks.Sources.Constant const(k=vs)
          annotation (extent=[-82,-36; -62,-16]);
        Modelica.Blocks.Sources.Constant const1(k=35*Modelica.Constants.pi/180)
          annotation (extent=[-82,-66; -62,-46]);
        MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.Simple_StateSpace_VR
          simple_StateSpace_VR(F=[263.8445,81.4279])
                               annotation (extent=[-38,-80; -8,-50]);
      equation
        connect(wheelJoint.frame_b,FWheelMass. frame_a) annotation (points=[-71,6;
              -57,6],        style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(wheelJoint.frame_b, motorcycle_Vittore_complete.connectFW)
          annotation (points=[-71,6; -64,6; -64,24; -48.2,24],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        annotation (Diagram,
          experiment(StopTime=30),
          experimentSetupOutput,
          Icon(
            Text(extent=[-140,162; 136,102],  string="%name"),
            Ellipse(extent=[-100,100; 100,-100], style(
                color=78,
                rgbcolor={127,0,127},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,100; 100,-80],
              string="ex",
              style(color=78, rgbcolor={127,0,127}))));
        connect(speedController.T_engine, motorcycle_Vittore_complete.T_engine)
          annotation (points=[41,-26; 55,-26; 55,-0.8], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(motorcycle_Vittore_complete.w, speedController.w) annotation (
            points=[63,40; 92,40; 92,-50; 30,-50; 30,-38], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(const.y, speedController.v) annotation (points=[-61,-26; 18,-26],
            style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(wheel.frame_b, motorcycle_Vittore_complete.connectRW)
          annotation (points=[69,6; 66,6; 66,24; 58.2,24],   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(simple_StateSpace_VR.phi_set, const1.y) annotation (points=[-41,
              -56; -61,-56], style(color=74, rgbcolor={0,0,127}));
        connect(motorcycle_Vittore_complete.phi, simple_StateSpace_VR.phi)
          annotation (points=[63,60; 98,60; 98,-88; -54,-88; -54,-74; -41,-74],
            style(color=74, rgbcolor={0,0,127}));
        connect(simple_StateSpace_VR.T_steer, motorcycle_Vittore_complete.T_Steering)
          annotation (points=[-6.5,-65; 7,-65; 7,-0.8], style(color=74,
              rgbcolor={0,0,127}));
      end Controlled_3dof_motorcycle_simple;

      function ControllerDesign
        "Controller design via pole-placement according to a preceding stability analysis"
        import SI = Modelica.SIunits;

        input String modelName = "MotorcycleLib.Examples.BasicMotorcycle.uncontrolled_3dof_motorcycle";
        input String independentVariableName = "vs";

        input SI.Velocity v = 10 "Forward velocity of the motorcycle";

        input Real d = 10
          "|Input for Controller Design| Offset in order to shift the poles";

        input Real states[4] = {5,6,1,2}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

        output Real F[1, 4] "State Feedback Matrix";

      algorithm
        F := MotorcycleLib.ControllerDesign.RigidRider.place(
                modelName,
                "vs",
                v,
                d,
                states);
        annotation (Documentation(info="<HTML>
<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The function exploits
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.ControllerDesign.RigidRider.place\">ControllerDesign.RigidRider.place</a>]</span>.
</p>
</HTML>"));
      end ControllerDesign;

      model Controlled_3dof_motorcycle
        import MotorcycleLib;
        MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
          motorcycle_Vittore_complete(
          p1={0.48,0.616,0},
          p2={0.024,0.461,0},
          d=6.8,
          enforceStates=true)
          annotation (extent=[-51,-10; 53,70]);
        MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StateSpace_VR
          stabilityController(F=[922.152175539882,44.9401285992775,
              1452.8917387369,221.381004052425])
          annotation (extent=[-37,-77; -7,-47]);
        MotorcycleLib.VirtualRider.VelocityControl.SpeedController
          speedController
          annotation (extent=[20,-50; 40,-30]);
        MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false,
          I_11=0,
          I_22=0,
          I_33=0.72,
          m=1) annotation (extent=[-62,-18; -42,2]);
        MotorcycleLib.IdealWheels.Wheel wheel(
          r=0.305,
          I_11=0,
          I_22=0,
          I_33=1.05,
          m=1,
          useTransVelocities=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          phi_start={0,5,0},
          enforceStates=false,
          w_start=0*{0,0,1/0.305*180/Modelica.Constants.pi})
                               annotation (extent=[84,-18; 64,2],   rotation=0);
        MotorcycleLib.IdealWheels.WheelJoint wheelJoint(
                                                   r=0.305)
          annotation (extent=[-98,-18; -78,2]);
        inner MultiBondLib.Mechanics3D.World3D world3D
          annotation (extent=[-88,70; -68,90]);
        Modelica.Blocks.Sources.Constant const(k=10)
          annotation (extent=[-90,-50; -70,-30]);
        Modelica.Blocks.Sources.Constant const1(k=0*Modelica.Constants.pi/180)
          annotation (extent=[-90,-90; -70,-70]);
        MotorcycleLib.Environments.Disturbances.SideWind sideWind(
          a=2000,
          w=0.25,
          f=0.25) annotation (extent=[92,60; 72,80], rotation=0);
      equation
        connect(wheelJoint.frame_b,FWheelMass. frame_a) annotation (points=[-77,-8;
              -63,-8],       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(wheelJoint.frame_b, motorcycle_Vittore_complete.connectFW)
          annotation (points=[-77,-8; -70,-8; -70,10; -54.2,10],   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        annotation (Diagram,
          experiment(StopTime=15),
          experimentSetupOutput,
          Icon(
            Text(extent=[-140,162; 136,102],  string="%name"),
            Ellipse(extent=[-100,100; 100,-100], style(
                color=78,
                rgbcolor={127,0,127},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,100; 100,-80],
              string="ex",
              style(color=78, rgbcolor={127,0,127}))));
        connect(speedController.T_engine, motorcycle_Vittore_complete.T_engine)
          annotation (points=[41,-40; 49,-40; 49,-14.8],style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(motorcycle_Vittore_complete.w, speedController.w) annotation (
            points=[57,26; 86,26; 86,-66; 30,-66; 30,-52], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(stabilityController.delta, motorcycle_Vittore_complete.steer_angle)
          annotation (points=[-40,-50; -48,-50; -48,-30; -19.8,-30; -19.8,-14],
            style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(const.y, speedController.v) annotation (points=[-69,-40; 18,-40],
            style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(stabilityController.v, const.y) annotation (points=[-40,-56;
              -60,-56; -60,-40; -69,-40],   style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(const1.y, stabilityController.phi_set) annotation (points=[-69,-80;
              -54,-80; -54,-68; -40,-68],          style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(sideWind.frame_a, motorcycle_Vittore_complete.CoM_RearFrame)
          annotation (points=[72,70; 64,70; 64,61.2; 52.2,61.2], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(wheel.frame_b, motorcycle_Vittore_complete.connectRW)
          annotation (points=[63,-8; 60,-8; 60,10; 52.2,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(stabilityController.T_steer, motorcycle_Vittore_complete.T_Steering)
          annotation (points=[-5.5,-62; 1,-62; 1,-14.8], style(color=74,
              rgbcolor={0,0,127}));
        connect(motorcycle_Vittore_complete.phi, stabilityController.phi)
          annotation (points=[57,46; 92,46; 92,-88; -48,-88; -48,-74; -40,-74],
            style(color=74, rgbcolor={0,0,127}));
      end Controlled_3dof_motorcycle;

      function ControllerDesign_Range
        "Controller design via pole-placement according to a preceding stability analysis"
        import SI = Modelica.SIunits;

        input String modelName = "MotorcycleLib.Examples.BasicMotorcycle.uncontrolled_3dof_motorcycle";
        input String independentVariableName = "vs";
        input Real startValue = 4 "Start velocity";
        input Real endValue = 12 "Final velocity";
        input Integer number_of_values = 41;

        input Real d = 5
          "|Input for Controller Design| Offset in order to shift the poles";

        input Real states[4] = {5,6,1,2}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

        input String filename = "place.mat"
          "|Store Settings| Filename to store the feedback matrix";

        output Real F[1, 4] "State Feedback Matrix";

      algorithm
        F := MotorcycleLib.ControllerDesign.RigidRider.placeRange_offset(
                modelName,
                "vs",
                startValue,
                endValue,
                number_of_values,
                d,
                states,
                filename);
        annotation (Documentation(info="<HTML>
<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The function exploits
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.ControllerDesign.RigidRider.placeRange_offset\">ControllerDesign.RigidRider.placeRange_offset</a>]</span>.
</p>
</HTML>"),       DymolaStoredErrors);
      end ControllerDesign_Range;

      function ControllerDesign_Individual
        "Controller design via pole-placement according to a preceding stability analysis"
        import SI = Modelica.SIunits;

        input String modelName = "MotorcycleLib.Examples.BasicMotorcycle.uncontrolled_3dof_motorcycle";
        input String independentVariableName = "vs";
        input Real startValue = 4 "Start velocity";
        input Real endValue = 12 "Final velocity";
        input Integer number_of_values = 41;
        input Real vw = 6.1 "|Stable Region| weave velocity";
        input Real vc = 10.3 "|Stable Region| capsize velocity";
        input Real dw = 0.75
          "|Input for Controller Design| Gain in order to shift the weave poles";
        input Real dc = 0.1
          "|Input for Controller Design| Gain in order to shift the capsize pole";

        input Real states[4] = {5,6,1,2}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

        input String filename = "place_ind.mat"
          "|Store Settings| Filename to store the feedback matrix";

        output Real F[1, 4] "State Feedback Matrix";

        // Graphical interpretation
        annotation(Images(Parameters(name="|Geometric Description||", source="images/place_individual_des.png")),
            DymolaStoredErrors,
          Documentation(info="<HTML>
<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The function exploits
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.ControllerDesign.RigidRider.placeRange_individual_vw_vc\">ControllerDesign.RigidRider.placeRange_individual_vw_vc</a>]</span>.
</p>
</HTML>"));

      algorithm
        F :=
          MotorcycleLib.ControllerDesign.RigidRider.placeRange_individual_vw_vc(
                modelName,
                "vs",
                startValue,
                endValue,
                number_of_values,
                vw,
                vc,
                dw,
                dc,
                states,
                filename);
        annotation (Documentation(info="<HTML>
<p>
This example demonstrates plotting of a root locus for the Motor Drive example with repect to the gain of the controller, controller.k.
</p>
<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The example exploits
<pre>
LinearSystems.rootLocus(\"LinearSystems.Examples.DriveLib.TestMotorDrive\", \"controller.k\", startValue = 1, endValue = 100, n=20);
<\\pre>
</p>
</HTML>"),       DymolaStoredErrors);
      end ControllerDesign_Individual;

      function ControllerDesign_Individual_improved
        "Controller design via pole-placement according to a preceding stability analysis"
        import SI = Modelica.SIunits;

        input String modelName = "MotorcycleLib.Examples.BasicMotorcycle.uncontrolled_3dof_motorcycle";
        input String independentVariableName = "vs";
        input Real startValue = 4 "Start velocity";
        input Real endValue = 12 "Final velocity";
        input Integer number_of_values = 41;
        input Real vi = 6.9
          "|Stable Region| intersection velocity (weave/capsize)";
        input Real dw = 0.75
          "|Input for Controller Design| Gain in order to shift the weave poles";
        input Real dc = 0.1
          "|Input for Controller Design| Gain in order to shift the capsize pole";
        input Real d0 = 0
          "|Input for Controller Design| Offset in order to shift the weave poles and the capsize pole";

        input Real states[4] = {5,6,1,2}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

        input String filename = "place_vi.mat"
          "|Store Settings| Filename to store the feedback matrix";

        output Real F[1, 4] "State Feedback Matrix";

        // Graphical interpretation
        annotation(Images(Parameters(name="|Geometric Description||", source="images/place_individual_des.png")),
            Documentation(info="<HTML>
<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The function exploits
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.ControllerDesign.RigidRider.placeRange_individual_vi\">ControllerDesign.RigidRider.placeRange_individual_vi</a>]</span>.
</p>
</HTML>"));

      algorithm
        F := MotorcycleLib.ControllerDesign.RigidRider.placeRange_individual_vi(
                modelName,
                "vs",
                startValue,
                endValue,
                number_of_values,
                vi,
                dw,
                dc,
      d0,       states,
                filename);
        annotation (Documentation(info="<HTML>
<p>
This example demonstrates plotting of a root locus for the Motor Drive example with repect to the gain of the controller, controller.k.
</p>
<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The example exploits
<pre>
LinearSystems.rootLocus(\"LinearSystems.Examples.DriveLib.TestMotorDrive\", \"controller.k\", startValue = 1, endValue = 100, n=20);
<\\pre>
</p>
</HTML>"),       DymolaStoredErrors);
      end ControllerDesign_Individual_improved;

      model Controlled_3dof_motorcycle_Range
        import MotorcycleLib;
        import SI = Modelica.SIunits;

        parameter SI.Velocity vs = 6;

        MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
          motorcycle_Vittore_complete(
          p1={0.48,0.616,0},
          p2={0.024,0.461,0},
          d=6.8,
          enforceStates=true)
          annotation (extent=[-55,-10; 49,70]);
        MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StateSpace_VR_Range
          VirtualRider(filename="place_vi.mat")
          annotation (extent=[-41,-77; -11,-47]);
        inner MultiBondLib.Mechanics3D.World3D world3D
          annotation (extent=[-94,34; -74,54]);
        Modelica.Blocks.Sources.Constant const1(k=0*Modelica.Constants.pi/180)
          annotation (extent=[-96,-90; -76,-70]);
        Modelica.Blocks.Sources.Constant const(k=vs)
          annotation (extent=[-96,-58; -76,-38]);
        annotation (Diagram(
            Text(
              extent=[-40,98; 104,70],
              string=
                  "... needed in combination with Tires provided by the WheelsAndTires library",
              style(
                color=10,
                rgbcolor={95,95,95},
                fillColor=70,
                rgbfillColor={45,96,172})), Rectangle(extent=[-64,98; 104,70], style(
                color=9,
                rgbcolor={175,175,175},
                thickness=2))),
          experiment(StopTime=15, Algorithm="Dassl"),
          experimentSetupOutput,
          Icon(
            Text(extent=[-140,162; 136,102],  string="%name"),
            Ellipse(extent=[-100,100; 100,-100], style(
                color=78,
                rgbcolor={127,0,127},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,100; 100,-80],
              string="ex",
              style(color=78, rgbcolor={127,0,127}))),
          Coordsys(extent=[-110,-100; 110,100], scale=0.1));
        WheelsAndTires.Tires.Slim.IdealTire RWheel(
          enforceStates=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          phi_start={5*Modelica.Constants.pi/180,0,0},
          I_11=0,
          I_22=0,
          I_33=1.05,
          mRim=1e-3,
          visForcesEnabled=false,
          rWheel=0.305,
          height=20e-3,
          w_start=vs*{0,0,1/0.305})
          annotation (extent=[60,-34; 100,6],   rotation=180);
        WheelsAndTires.Tires.Slim.IdealTire FWheel(
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          I_11=0,
          I_22=0,
          I_33=0.72,
          mRim=1e-3,
          visForcesEnabled=false,
          visBeltEnabled=true,
          visContactPointEnabled=true,
          rWheel=0.305,
          height=20e-3)
          annotation (extent=[-66,-32; -106,8],   rotation=180);
        inner WheelsAndTires.Environment.Surface Surface(visSurface=false)
          annotation (extent=[-60,74; -40,94]);
      equation
        connect(VirtualRider.delta, motorcycle_Vittore_complete.steer_angle)
          annotation (points=[-44,-50; -54,-50; -54,-30; -23.8,-30; -23.8,-14],
            style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(const1.y, VirtualRider.phi_set)        annotation (points=[-75,-80;
              -60,-80; -60,-68; -44,-68],          style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(VirtualRider.T_steer, motorcycle_Vittore_complete.T_Steering)
          annotation (points=[-9.5,-62; -3,-62; -3,-14.8],
                                                         style(color=74,
              rgbcolor={0,0,127}));
        connect(motorcycle_Vittore_complete.phi, VirtualRider.phi)
          annotation (points=[53,46; 104,46; 104,-90; -54,-90; -54,-74; -44,-74],
            style(color=74, rgbcolor={0,0,127}));
        connect(const.y, VirtualRider.v)        annotation (points=[-75,-48;
              -60,-48; -60,-56; -44,-56], style(color=74, rgbcolor={0,0,127}));
        connect(FWheel.TireHub, motorcycle_Vittore_complete.connectFW) annotation (
            points=[-66,-12; -62,-12; -62,10; -58.2,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RWheel.TireHub, motorcycle_Vittore_complete.connectRW)
          annotation (points=[60,-14; 56,-14; 56,10; 48.2,10], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end Controlled_3dof_motorcycle_Range;

      model controlled_3dof_motorcycle_Curve
        import MotorcycleLib;
        import SI = Modelica.SIunits;

        parameter SI.Velocity v = 10;

        MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
          motorcycle_Vittore_complete(
          p1={0.48,0.616,0},
          p2={0.024,0.461,0},
          d=6.8,
          enforceStates=true)
          annotation (extent=[-51,-10; 53,70]);
        MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StateSpace_VR_Range
          stabilityController(filename="placeRange5.mat")
          annotation (extent=[-37,-77; -7,-47]);
        MotorcycleLib.VirtualRider.VelocityControl.SpeedController
          speedController
          annotation (extent=[20,-50; 40,-30]);
        MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false,
          I_11=0,
          I_22=0,
          I_33=0.72,
          m=1) annotation (extent=[-62,-18; -42,2]);
        MotorcycleLib.IdealWheels.Wheel wheel(
          r=0.305,
          I_11=0,
          I_22=0,
          I_33=1.05,
          m=1,
          useTransVelocities=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          enforceStates=false,
          w_start={0,0,0},
          phi_start={0,0,0})   annotation (extent=[84,-18; 64,2],   rotation=0);
        MotorcycleLib.IdealWheels.WheelJoint wheelJoint(
                                                   r=0.305)
          annotation (extent=[-98,-18; -78,2]);
        inner MultiBondLib.Mechanics3D.World3D world3D
          annotation (extent=[-90,50; -70,70]);
        Modelica.Blocks.Sources.Constant const(k=v)
          annotation (extent=[-90,-50; -70,-30]);
        MotorcycleLib.Environments.Tracks.OpenLoopMethod.Curve_90degree
          standard_90degree_curve(v=v, table=curve90degree_basicMotorcycle.table)
                                  annotation (extent=[-90,-78; -70,-58]);
        MotorcycleLib.Environments.Tracks.OpenLoopMethod.Data.Curve90degree_basicMotorcycle
          curve90degree_basicMotorcycle(v=v)
          annotation (extent=[-60,50; -40,70]);
      equation
        connect(wheelJoint.frame_b,FWheelMass. frame_a) annotation (points=[-77,-8;
              -63,-8],       style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(wheel.frame_b, motorcycle_Vittore_complete.connectRW)
          annotation (points=[63,-8; 60,-8; 60,10; 52.2,10],   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(wheelJoint.frame_b, motorcycle_Vittore_complete.connectFW)
          annotation (points=[-77,-8; -70,-8; -70,10; -54.2,10],   style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        annotation (Diagram, Icon(
            Text(extent=[-140,162; 136,102],  string="%name"),
            Ellipse(extent=[-100,100; 100,-100], style(
                color=78,
                rgbcolor={127,0,127},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,100; 100,-80],
              string="ex",
              style(color=78, rgbcolor={127,0,127}))),
          experiment(StopTime=15),
          experimentSetupOutput);
        connect(speedController.T_engine, motorcycle_Vittore_complete.T_engine)
          annotation (points=[41,-40; 49,-40; 49,-14.8],style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(motorcycle_Vittore_complete.w, speedController.w) annotation (
            points=[57,26; 86,26; 86,-66; 30,-66; 30,-52], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(stabilityController.T_steer, motorcycle_Vittore_complete.T_Steering)
          annotation (points=[-5.5,-62; 1,-62; 1,-14.8],
                                                       style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(stabilityController.delta, motorcycle_Vittore_complete.steer_angle)
          annotation (points=[-40,-50; -46,-50; -46,-30; -19.8,-30; -19.8,-14],
            style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(const.y, speedController.v) annotation (points=[-69,-40; 18,-40],
            style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(stabilityController.v, const.y) annotation (points=[-40,-56;
              -60,-56; -60,-40; -69,-40],   style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(standard_90degree_curve.leanAngle, stabilityController.phi_set)
          annotation (points=[-69,-68; -40,-68],                       style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(motorcycle_Vittore_complete.phi, stabilityController.phi)
          annotation (points=[57,46; 92,46; 92,-88; -46,-88; -46,-74; -40,-74],
            style(color=74, rgbcolor={0,0,127}));
      end controlled_3dof_motorcycle_Curve;

      function ControllerDesign_pathPreview
        "Controller design via pole-placement according to a preceding stability analysis"
        import SI = Modelica.SIunits;

        input String modelName = "MotorcycleLib.Examples.BasicMotorcycle.uncontrolled_3dof_motorcycle_PT";
        input String independentVariableName = "vs";
        input SI.Velocity v = 10 "Forward velocity of the motorcycle";
        input Real d = 5
          "|Input for Controller Design| Offset in order to shift the poles";
        input Real d_lat = 1
          "|Input for Controller Design| Offset in order to shift the poles";

        input Real states[6] = {5, 6, 1, 2, 11, 10}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

        output Real F[1, 6] "State Feedback Matrix";

      algorithm
        F :=
          MotorcycleLib.ControllerDesign.RigidRider.PathPreview.place_pathPreview(
                modelName,
                "vs",
                v,
                d,
                d_lat,
                states);
        annotation (Documentation(info="<HTML>
<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The function exploits
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.ControllerDesign.RigidRider.PathPreview.placeRange_pathPreview\">ControllerDesign.RigidRider.PathPreview.placeRange_pathPreview</a>]</span>.
</p>
</HTML>"),       DymolaStoredErrors);
      end ControllerDesign_pathPreview;

      function ControllerDesign_pathPreview_Range
        "Controller design via pole-placement according to a preceding stability analysis"
        import SI = Modelica.SIunits;

        input String modelName = "MotorcycleLib.Examples.BasicMotorcycle.uncontrolled_3dof_motorcycle_PT";
        input String independentVariableName = "vs";
        input Real startValue = 4 "Start velocity";
        input Real endValue = 12 "Final velocity";
        input Integer number_of_values = 41;

        input Real d = 5
          "|Input for Controller Design| Offset in order to shift the poles";
        input Real d_lat = 1
          "|Input for Controller Design| Offset in order to shift the poles";

        input Real states[6] = {5, 6, 1, 2, 11, 10}
          "|State Selection (state vector)| steer angle, der(steer angle), lean angle, der(lean angle)";

        input String filename = "place_pathPreview.mat"
          "|Store Settings| Filename to store the feedback matrix";

        output Real F[1, 6] "State Feedback Matrix";

      algorithm
        F :=
          MotorcycleLib.ControllerDesign.RigidRider.PathPreview.placeRange_pathPreview(
                modelName,
                "vs",
                startValue,
                endValue,
                number_of_values,
                d,
                d_lat,
                states,
                filename);
        annotation (Documentation(info="<HTML>
<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The function exploits
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.ControllerDesign.RigidRider.PathPreview.placeRange_pathPreview\">ControllerDesign.RigidRider.PathPreview.placeRange_pathPreview</a>]</span>.
</p>
</HTML>"),       DymolaStoredErrors);
      end ControllerDesign_pathPreview_Range;

      model controlled_3dof_motorcycle_closedLoop
        import MotorcycleLib;
        import SI = Modelica.SIunits;

        parameter SI.Velocity v = 10;

        MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
          motorcycle_Vittore_complete(
          p1={0.48,0.616,0},
          p2={0.024,0.461,0},
          d=6.8,
          enforceStates=true)
          annotation (extent=[-45,2; 59,82]);
        MotorcycleLib.VirtualRider.VelocityControl.SpeedController
          speedController
          annotation (extent=[20,-36; 40,-16]);
        MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false,
          I_11=0,
          I_22=0,
          I_33=0.72,
          m=1) annotation (extent=[-56,-6; -36,14]);
        MotorcycleLib.IdealWheels.Wheel wheel(
          r=0.305,
          I_11=0,
          I_22=0,
          I_33=1.05,
          m=1,
          useTransVelocities=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          phi_start={0,5,0},
          enforceStates=false) annotation (extent=[90,-6; 70,14],   rotation=0);
        MotorcycleLib.IdealWheels.WheelJoint wheelJoint(
                                                   r=0.305)
          annotation (extent=[-92,-6; -72,14]);
        inner MultiBondLib.Mechanics3D.World3D world3D
          annotation (extent=[-110,60; -90,80]);
        Modelica.Blocks.Sources.Constant const(k=v)
          annotation (extent=[-110,-36; -90,-16]);
        MotorcycleLib.VirtualRider.VirtualRigidRider.PathTracking.Classic_StateSpace_VR
          pathPreviewControllerV2_1(
          F=[922.152175539882,44.9401285992775,1452.8917387369,221.381004052425],
          T=25,
          k=500)                    annotation (extent=[-30,-81; 0,-51]);

        MotorcycleLib.Environments.Tracks.ClosedLoopMethod.PathPreview
          pathPreview annotation (extent=[20,-114; 40,-94]);
        MotorcycleLib.Environments.Tracks.ClosedLoopMethod.Path path(v=v)
          annotation (extent=[-110,-65; -90,-45]);
      equation
        connect(wheelJoint.frame_b,FWheelMass. frame_a) annotation (points=[-71,4;
              -57,4],        style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(wheel.frame_b, motorcycle_Vittore_complete.connectRW)
          annotation (points=[69,4; 66,4; 66,22; 58.2,22],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(wheelJoint.frame_b, motorcycle_Vittore_complete.connectFW)
          annotation (points=[-71,4; -64,4; -64,22; -48.2,22],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        annotation (Diagram,
          Coordsys(extent=[-120,-120; 120,120], scale=0.1),
          experiment(StopTime=15),
          experimentSetupOutput,
          Icon(
            Text(extent=[-140,162; 136,102],  string="%name"),
            Ellipse(extent=[-100,100; 100,-100], style(
                color=78,
                rgbcolor={127,0,127},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,100; 100,-80],
              string="ex",
              style(color=78, rgbcolor={127,0,127}))));
        connect(speedController.T_engine, motorcycle_Vittore_complete.T_engine)
          annotation (points=[41,-26; 55,-26; 55,-2.8], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(motorcycle_Vittore_complete.w, speedController.w) annotation (
            points=[63,38; 92,38; 92,-54; 30,-54; 30,-38], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(const.y, speedController.v) annotation (points=[-89,-26; 18,-26],
            style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(pathPreviewControllerV2_1.T_steer, motorcycle_Vittore_complete.T_Steering)
          annotation (points=[1.5,-66; 7,-66; 7,-2.8], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=3,
            rgbfillColor={0,0,255},
            fillPattern=1));
        connect(pathPreviewControllerV2_1.v, const.y) annotation (points=[-33,-66;
              -76,-66; -76,-26; -89,-26],      style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=3,
            rgbfillColor={0,0,255},
            fillPattern=1));
        connect(motorcycle_Vittore_complete.steer_angle,
          pathPreviewControllerV2_1.steerAngle) annotation (points=[-13.8,-2;
              -13.8,-40; -46,-40; -46,-73.5; -33,-73.5],
                                                     style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=3,
            rgbfillColor={0,0,255},
            fillPattern=1));
        connect(pathPreview.x_lat, pathPreviewControllerV2_1.xlat) annotation (
            points=[19,-102; -56,-102; -56,-58.5; -33,-58.5],
                                                        style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=3,
            rgbfillColor={0,0,255},
            fillPattern=1));
        connect(pathPreview.frame_a, motorcycle_Vittore_complete.CoM_RearFrame)
          annotation (points=[40,-102; 108,-102; 108,73.2; 58.2,73.2], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(motorcycle_Vittore_complete.phi, pathPreviewControllerV2_1.leanAngle)
          annotation (points=[63,58; 100,58; 100,-88; -46,-88; -46,-81; -33,-81],
            style(color=74, rgbcolor={0,0,127}));
        connect(path.p_pre, pathPreviewControllerV2_1.xlat_set) annotation (
            points=[-89,-59; -66.5,-59; -66.5,-51; -33,-51], style(color=74,
              rgbcolor={0,0,127}));
      end controlled_3dof_motorcycle_closedLoop;

      model controlled_3dof_motorcycle_closedLoop_Range
        import MotorcycleLib;
        import SI = Modelica.SIunits;

        parameter SI.Velocity v = 6;

        MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
          motorcycle_Vittore_complete(
          p1={0.48,0.616,0},
          p2={0.024,0.461,0},
          d=6.8,
          enforceStates=true)
          annotation (extent=[-65,2; 39,82]);
        MotorcycleLib.VirtualRider.VelocityControl.SpeedController
          speedController
          annotation (extent=[6,-40; 26,-20]);
        inner MultiBondLib.Mechanics3D.World3D world3D
          annotation (extent=[-110,54; -90,74]);
        Modelica.Blocks.Sources.Constant const(k=v)
          annotation (extent=[-110,-40; -90,-20]);
        MotorcycleLib.VirtualRider.VirtualRigidRider.PathTracking.StateSpace_PT_VR_Range
          VR_pathPreview(filename="place_pathPreview2")
                                    annotation (extent=[-30,-85; 0,-55]);

        MotorcycleLib.Environments.Tracks.ClosedLoopMethod.PathPreview_StateSpace
          pathPreview(preview=6, height=0.616)
                      annotation (extent=[20,-118; 40,-98]);
        MotorcycleLib.Environments.Tracks.ClosedLoopMethod.Path path(v=v, offset=6)
          annotation (extent=[-110,-97; -90,-77]);
        Modelica.Blocks.Sources.Constant const1(k=0)
          annotation (extent=[-110,-70; -90,-50]);
        annotation (Diagram(
            Text(
              extent=[-48,114; 96,86],
              string=
                  "... needed in combination with Tires provided by the WheelsAndTires library",
              style(
                color=10,
                rgbcolor={95,95,95},
                fillColor=70,
                rgbfillColor={45,96,172})), Rectangle(extent=[-72,115; 96,87], style(
                color=9,
                rgbcolor={175,175,175},
                thickness=2))),
          Coordsys(extent=[-120,-120; 120,120], scale=0.1),
          experiment(StopTime=30),
          experimentSetupOutput,
          Icon(
            Text(extent=[-140,162; 136,102],  string="%name"),
            Ellipse(extent=[-100,100; 100,-100], style(
                color=78,
                rgbcolor={127,0,127},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,100; 100,-80],
              string="ex",
              style(color=78, rgbcolor={127,0,127}))));
        MultiBondLib.Mechanics3D.MechSensors.AbsoluteSensor absoluteSensor
          annotation (extent=[20,-92; 40,-72], rotation=180);
        WheelsAndTires.Tires.Slim.IdealTire FWheel(
          initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
          I_11=0,
          I_22=0,
          I_33=0.72,
          mRim=1e-3,
          visForcesEnabled=false,
          visBeltEnabled=true,
          visContactPointEnabled=true,
          rWheel=0.305,
          height=20e-3)
          annotation (extent=[-78,-14; -118,26],  rotation=180);
        WheelsAndTires.Tires.Slim.IdealTire RWheel(
          enforceStates=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          I_11=0,
          I_22=0,
          I_33=1.05,
          mRim=1e-3,
          visForcesEnabled=false,
          rWheel=0.305,
          height=20e-3,
          w_start=0*{0,0,1/0.305},
          phi_start={0*Modelica.Constants.pi/180,0,0})
          annotation (extent=[52,-14; 92,26],   rotation=180);
        inner WheelsAndTires.Environment.Surface Surface(visSurface=false)
          annotation (extent=[-68,90; -48,110]);
      equation
        connect(speedController.T_engine, motorcycle_Vittore_complete.T_engine)
          annotation (points=[27,-30; 35,-30; 35,-2.8], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(motorcycle_Vittore_complete.w, speedController.w) annotation (
            points=[43,38; 92,38; 92,-58; 16,-58; 16,-42], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(const.y, speedController.v) annotation (points=[-89,-30; 4,-30],
            style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(VR_pathPreview.v, const.y)            annotation (points=[-33,-61;
              -58,-61; -58,-30; -89,-30],      style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=3,
            rgbfillColor={0,0,255},
            fillPattern=1));
        connect(pathPreview.frame_a, motorcycle_Vittore_complete.CoM_RearFrame)
          annotation (points=[40,-106; 108,-106; 108,73.2; 38.2,73.2], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(motorcycle_Vittore_complete.phi, VR_pathPreview.phi)
          annotation (points=[43,58; 100,58; 100,-94; -44,-94; -44,-73; -33,-73],
            style(color=74, rgbcolor={0,0,127}));
        connect(const1.y, VR_pathPreview.phi_set)            annotation (points=[-89,-60;
              -74,-60; -74,-67; -33,-67],          style(color=74, rgbcolor={0,
                0,127}));
        connect(pathPreview.x1_lateralPosition, VR_pathPreview.xlat)
          annotation (points=[19,-110; -58,-110; -58,-85; -33,-85], style(color=
               74, rgbcolor={0,0,127}));
        connect(motorcycle_Vittore_complete.steer_angle, VR_pathPreview.lambda)
                                            annotation (points=[-33.8,-2; -33.8,
              -18; -44,-18; -44,-55; -33,-55], style(color=74, rgbcolor={0,0,
                127}));
        connect(VR_pathPreview.T_steer, motorcycle_Vittore_complete.T_Steering)
          annotation (points=[1.5,-70; 6,-70; 6,-48; -13,-48; -13,-2.8], style(
              color=74, rgbcolor={0,0,127}));
        connect(absoluteSensor.frame_a, pathPreview.frame_a) annotation (points=
             [41,-82; 52,-82; 52,-106; 40,-106], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(path.p_pre, VR_pathPreview.xlat_set)            annotation (
            points=[-89,-91; -74,-91; -74,-79; -33,-79], style(color=74,
              rgbcolor={0,0,127}));
        connect(FWheel.TireHub, motorcycle_Vittore_complete.connectFW)
          annotation (points=[-78,6; -72,6; -72,22; -68.2,22], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(RWheel.TireHub, motorcycle_Vittore_complete.connectRW)
          annotation (points=[52,6; 46,6; 46,22; 38.2,22], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
      end controlled_3dof_motorcycle_closedLoop_Range;

      model controlled_3dof_motorcycle_closedLoop_LQR
        import MotorcycleLib;
        import SI = Modelica.SIunits;

        parameter SI.Velocity vs = 6;

        MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
          motorcycle_Vittore_complete(
          p1={0.48,0.616,0},
          p2={0.024,0.461,0},
          d=6.8,
          enforceStates=true)
          annotation (extent=[-45,2; 59,82]);
        MotorcycleLib.VirtualRider.VelocityControl.SpeedController
          speedController
          annotation (extent=[20,-36; 40,-16]);
        MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
          I_21=0,
          I_31=0,
          I_32=0,
          animation=false,
          I_11=0,
          I_22=0,
          I_33=0.72,
          m=1) annotation (extent=[-56,-6; -36,14]);
        MotorcycleLib.IdealWheels.Wheel wheel(
          r=0.305,
          I_11=0,
          I_22=0,
          I_33=1.05,
          m=1,
          useTransVelocities=false,
          initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
          enforceStates=false,
          phi_start={0,0,0})   annotation (extent=[90,-6; 70,14],   rotation=0);
        MotorcycleLib.IdealWheels.WheelJoint wheelJoint(
                                                   r=0.305)
          annotation (extent=[-92,-6; -72,14]);
        inner MultiBondLib.Mechanics3D.World3D world3D
          annotation (extent=[-110,60; -90,80]);
        Modelica.Blocks.Sources.Constant const(k=vs)
          annotation (extent=[-110,-36; -90,-16]);
        MotorcycleLib.VirtualRider.VirtualRigidRider.PathTracking.LQR_PT_VR
          pathPreviewControllerV2_1(F=[179.1033,7.3040,86.8796,19.6154,3.1623,
              3.8066])              annotation (extent=[-30,-87; 0,-57]);

        MotorcycleLib.Environments.Tracks.ClosedLoopMethod.PathPreview_StateSpace
          pathPreview(height=0.616, preview=6)
                      annotation (extent=[20,-118; 40,-98]);
        MotorcycleLib.Environments.Tracks.ClosedLoopMethod.Path path(v=vs,
            offset=6)
          annotation (extent=[-110,-63; -90,-43]);
        Modelica.Blocks.Sources.Constant const1(k=0)
          annotation (extent=[-110,-91; -90,-71]);
        MultiBondLib.Mechanics3D.MechSensors.AbsoluteSensor absoluteSensor
          annotation (extent=[20,-90; 40,-70], rotation=180);
      equation
        connect(wheelJoint.frame_b,FWheelMass. frame_a) annotation (points=[-71,4;
              -57,4],        style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(wheel.frame_b, motorcycle_Vittore_complete.connectRW)
          annotation (points=[69,4; 66,4; 66,22; 58.2,22],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(wheelJoint.frame_b, motorcycle_Vittore_complete.connectFW)
          annotation (points=[-71,4; -64,4; -64,22; -48.2,22],     style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        annotation (Diagram,
          Coordsys(extent=[-120,-120; 120,120], scale=0.1),
          experiment(StopTime=30),
          experimentSetupOutput,
          Icon(
            Text(extent=[-140,162; 136,102],  string="%name"),
            Ellipse(extent=[-100,100; 100,-100], style(
                color=78,
                rgbcolor={127,0,127},
                fillColor=7,
                rgbfillColor={255,255,255})),
            Text(
              extent=[-100,100; 100,-80],
              string="ex",
              style(color=78, rgbcolor={127,0,127}))));
        connect(speedController.T_engine, motorcycle_Vittore_complete.T_engine)
          annotation (points=[41,-26; 55,-26; 55,-2.8], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(motorcycle_Vittore_complete.w, speedController.w) annotation (
            points=[63,38; 92,38; 92,-54; 30,-54; 30,-38], style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(const.y, speedController.v) annotation (points=[-89,-26; 18,-26],
            style(
            color=74,
            rgbcolor={0,0,127},
            pattern=0,
            fillColor=7,
            rgbfillColor={255,255,255},
            fillPattern=1));
        connect(pathPreviewControllerV2_1.v, const.y) annotation (points=[-33,-75;
              -70,-75; -70,-26; -89,-26],      style(
            color=74,
            rgbcolor={0,0,127},
            fillColor=3,
            rgbfillColor={0,0,255},
            fillPattern=1));
        connect(pathPreview.frame_a, motorcycle_Vittore_complete.CoM_RearFrame)
          annotation (points=[40,-106; 104,-106; 104,73.2; 58.2,73.2], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(motorcycle_Vittore_complete.phi, pathPreviewControllerV2_1.phi)
          annotation (points=[63,58; 96,58; 96,-94; -48,-94; -48,-87; -33,-87],
            style(color=74, rgbcolor={0,0,127}));
        connect(const1.y, pathPreviewControllerV2_1.phi_set) annotation (points=[-89,-81;
              -33,-81],                            style(color=74, rgbcolor={0,
                0,127}));
        connect(motorcycle_Vittore_complete.steer_angle,
          pathPreviewControllerV2_1.delta) annotation (points=[-13.8,-2; -14,-2;
              -14,-36; -48,-36; -48,-69; -33,-69], style(color=74, rgbcolor={0,
                0,127}));
        connect(pathPreview.x1_lateralPosition, pathPreviewControllerV2_1.xlat)
          annotation (points=[19,-110; -58,-110; -58,-63; -33,-63], style(color=
               74, rgbcolor={0,0,127}));
        connect(pathPreviewControllerV2_1.T_steer, motorcycle_Vittore_complete.T_Steering)
          annotation (points=[1.5,-72; 7,-72; 7,-2.8], style(color=74, rgbcolor=
               {0,0,127}));
        connect(absoluteSensor.frame_a, pathPreview.frame_a) annotation (points=
             [41,-80; 60,-80; 60,-106; 40,-106], style(
            color=0,
            rgbcolor={0,0,0},
            thickness=2));
        connect(path.p_pre, pathPreviewControllerV2_1.xlat_set) annotation (
            points=[-89,-57; -61.5,-57; -61.5,-57; -33,-57], style(color=74,
              rgbcolor={0,0,127}));
      end controlled_3dof_motorcycle_closedLoop_LQR;

      package Temp
        model Controlled_3dof_motorcycle_zeroSteadyState
          import MotorcycleLib;
          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 6;

          MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
            motorcycle_Vittore_complete(
            p1={0.48,0.616,0},
            p2={0.024,0.461,0},
            d=6.8,
            enforceStates=true)
            annotation (extent=[-63,4; 41,84]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
            I_21=0,
            I_31=0,
            I_32=0,
            animation=false,
            I_11=0,
            I_22=0,
            I_33=0.72,
            m=1) annotation (extent=[-74,-4; -54,16]);
          MotorcycleLib.IdealWheels.Wheel wheel(
            r=0.305,
            I_11=0,
            I_22=0,
            I_33=1.05,
            m=1,
            useTransVelocities=false,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            enforceStates=false,
            phi_start={0,0,0},
            w_start=vs*{0,0,1/0.305*180/Modelica.Constants.pi})
                                 annotation (extent=[72,-4; 52,16],   rotation=0);
          MotorcycleLib.IdealWheels.WheelJoint wheelJoint(
                                                     r=0.305)
            annotation (extent=[-110,-4; -90,16]);
          inner MultiBondLib.Mechanics3D.World3D world3D
            annotation (extent=[-130,70; -110,90]);
          Modelica.Blocks.Sources.Constant const1(k=35*Modelica.Constants.pi/180)
            annotation (extent=[-132,-106; -112,-86]);
          Modelica.Blocks.Continuous.Der derivative
            annotation (extent=[-2,-122; 18,-102], rotation=0);
          Modelica.Blocks.Continuous.Der derivative1
            annotation (extent=[-2,-85; 18,-65],   rotation=0);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StateSpace_LeanSteer
            stateSpaceController annotation (extent=[52,-88; 72,-68]);
          Modelica.Blocks.Math.Feedback feedback
            annotation (extent=[-62,-86; -42,-106]);
          Modelica.Blocks.Math.Feedback feedback1
            annotation (extent=[-42,-46; -22,-66], rotation=0);
          MotorcycleLib.VirtualRider.Utilities.lean2steer lean2steer
                                        annotation (extent=[-90,-66; -70,-46]);
          Modelica.Blocks.Sources.Constant const2(k=vs)
            annotation (extent=[-132,-72; -112,-52]);
          Modelica.Blocks.Math.Add add3_1(k1=1)
            annotation (extent=[88,-110; 108,-90]);
          Modelica.Blocks.Continuous.PI PI1(k=25, T=0.4)
            annotation (extent=[52,-136; 72,-116]);
          Modelica.Blocks.Nonlinear.Limiter limiter(uMax=10)
            annotation (extent=[110,-74; 130,-54], rotation=90);
        equation
          connect(wheelJoint.frame_b,FWheelMass. frame_a) annotation (points=[-89,6;
                -75,6],        style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(wheelJoint.frame_b, motorcycle_Vittore_complete.connectFW)
            annotation (points=[-89,6; -82,6; -82,24; -66.2,24],     style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          annotation (Diagram,
            experiment(StopTime=15),
            experimentSetupOutput,
            Icon(
              Text(extent=[-140,162; 136,102],  string="%name"),
              Ellipse(extent=[-100,100; 100,-100], style(
                  color=78,
                  rgbcolor={127,0,127},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Text(
                extent=[-100,100; 100,-80],
                string="ex",
                style(color=78, rgbcolor={127,0,127}))),
            Coordsys(extent=[-140,-150; 140,100], scale=0.1));
          connect(wheel.frame_b, motorcycle_Vittore_complete.connectRW)
            annotation (points=[51,6; 48,6; 48,24; 40.2,24],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(derivative.u,feedback. y) annotation (points=[-4,-112; -12,-112;
                -12,-96; -43,-96],       style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController.phi_lean,feedback. y) annotation (points=[50,-81;
                32,-81; 32,-96; -43,-96],
                                  style(color=74, rgbcolor={0,0,127}));
          connect(derivative.y,stateSpaceController. der_phi_lean) annotation (
              points=[19,-112; 40,-112; 40,-86; 50,-86],  style(color=74,
                rgbcolor={0,0,127}));
          connect(feedback1.y,stateSpaceController. phi_steer) annotation (
              points=[-23,-56; 40,-56; 40,-70; 50,-70], style(color=74,
                rgbcolor={0,0,127}));
          connect(derivative1.u,feedback1. y) annotation (points=[-4,-75; -12,-75;
                -12,-56; -23,-56],      style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer,feedback1. u1) annotation (points=[-69,-56;
                -40,-56],                                       style(color=74,
                rgbcolor={0,0,127}));
          connect(derivative1.y,stateSpaceController. der_phi_steer) annotation (
              points=[19,-75; 50,-75],
                                     style(color=74, rgbcolor={0,0,127}));
          connect(const1.y, feedback.u1) annotation (points=[-111,-96; -60,-96],
              style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.lean, const1.y) annotation (points=[-92,-50; -102,
                -50; -102,-96; -111,-96], style(color=74, rgbcolor={0,0,127}));
          connect(const2.y, lean2steer.v) annotation (points=[-111,-62; -92,-62],
              style(color=74, rgbcolor={0,0,127}));
          connect(motorcycle_Vittore_complete.steer_angle, feedback1.u2)
            annotation (points=[-31.8,0; -32,0; -32,-48], style(color=74,
                rgbcolor={0,0,127}));
          connect(motorcycle_Vittore_complete.phi, feedback.u2) annotation (
              points=[45,60; 86,60; 86,-14; -52,-14; -52,-88], style(color=74,
                rgbcolor={0,0,127}));
          connect(PI1.u, feedback.y) annotation (points=[50,-126; -30,-126; -30,
                -96; -43,-96], style(color=74, rgbcolor={0,0,127}));
          connect(add3_1.u1, stateSpaceController.SteeringTorque) annotation (
              points=[86,-94; 80,-94; 80,-78; 73,-78], style(color=74, rgbcolor={
                  0,0,127}));
          connect(add3_1.u2, PI1.y) annotation (points=[86,-106; 80,-106; 80,-126;
                73,-126], style(color=74, rgbcolor={0,0,127}));
          connect(add3_1.y, limiter.u) annotation (points=[109,-100; 120,-100;
                120,-76], style(color=74, rgbcolor={0,0,127}));
          connect(limiter.y, motorcycle_Vittore_complete.T_Steering) annotation (
              points=[120,-53; 120,-30; -12,-30; -12,-0.8; -11,-0.8], style(color=
                 74, rgbcolor={0,0,127}));
        end Controlled_3dof_motorcycle_zeroSteadyState;

        model ControlledRange_3dof_motorcycle_zeroSteadyState
          import MotorcycleLib;
          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 6;

          MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
            motorcycle_Vittore_complete(
            p1={0.48,0.616,0},
            p2={0.024,0.461,0},
            d=6.8,
            enforceStates=true)
            annotation (extent=[-63,4; 41,84]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
            I_21=0,
            I_31=0,
            I_32=0,
            animation=false,
            I_11=0,
            I_22=0,
            I_33=0.72,
            m=1) annotation (extent=[-74,-4; -54,16]);
          MotorcycleLib.IdealWheels.Wheel wheel(
            r=0.305,
            I_11=0,
            I_22=0,
            I_33=1.05,
            m=1,
            useTransVelocities=false,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            enforceStates=false,
            phi_start={0,0,0},
            w_start=vs*{0,0,1/0.305*180/Modelica.Constants.pi})
                                 annotation (extent=[72,-4; 52,16],   rotation=0);
          MotorcycleLib.IdealWheels.WheelJoint wheelJoint(
                                                     r=0.305)
            annotation (extent=[-110,-4; -90,16]);
          inner MultiBondLib.Mechanics3D.World3D world3D
            annotation (extent=[-130,70; -110,90]);
          Modelica.Blocks.Sources.Constant const1(k=0*Modelica.Constants.pi/180)
            annotation (extent=[-132,-106; -112,-86]);
          Modelica.Blocks.Continuous.Der derivative
            annotation (extent=[-2,-122; 18,-102], rotation=0);
          Modelica.Blocks.Continuous.Der derivative1
            annotation (extent=[-2,-82; 18,-62],   rotation=0);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StabilityController_table
            stateSpaceController(filename="placeRange5.mat")
                                 annotation (extent=[52,-88; 72,-68]);
          Modelica.Blocks.Math.Feedback feedback
            annotation (extent=[-62,-86; -42,-106]);
          Modelica.Blocks.Math.Feedback feedback1
            annotation (extent=[-42,-46; -22,-66], rotation=0);
          MotorcycleLib.VirtualRider.Utilities.lean2steer lean2steer
                                        annotation (extent=[-84,-66; -64,-46]);
          Modelica.Blocks.Sources.Constant const2(k=vs)
            annotation (extent=[-132,-72; -112,-52]);
          Modelica.Blocks.Math.Add add3_1(k1=1)
            annotation (extent=[88,-110; 108,-90]);
          Modelica.Blocks.Continuous.PI PI1(k=1, T=0.015)
            annotation (extent=[52,-136; 72,-116]);
          Modelica.Blocks.Nonlinear.Limiter limiter(uMax=1000)
            annotation (extent=[110,-74; 130,-54], rotation=90);
        equation
          connect(wheelJoint.frame_b,FWheelMass. frame_a) annotation (points=[-89,6;
                -75,6],        style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(wheelJoint.frame_b, motorcycle_Vittore_complete.connectFW)
            annotation (points=[-89,6; -82,6; -82,24; -66.2,24],     style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          annotation (Diagram,
            experiment(StopTime=15),
            experimentSetupOutput,
            Icon(
              Text(extent=[-140,162; 136,102],  string="%name"),
              Ellipse(extent=[-100,100; 100,-100], style(
                  color=78,
                  rgbcolor={127,0,127},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Text(
                extent=[-100,100; 100,-80],
                string="ex",
                style(color=78, rgbcolor={127,0,127}))),
            Coordsys(extent=[-140,-150; 140,100], scale=0.1));
          connect(wheel.frame_b, motorcycle_Vittore_complete.connectRW)
            annotation (points=[51,6; 48,6; 48,24; 40.2,24],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(derivative.u,feedback. y) annotation (points=[-4,-112; -12,-112;
                -12,-96; -43,-96],       style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController.phi_lean,feedback. y) annotation (points=[50,-78;
                32,-78; 32,-96; -43,-96],
                                  style(color=74, rgbcolor={0,0,127}));
          connect(derivative.y,stateSpaceController. der_phi_lean) annotation (
              points=[19,-112; 40,-112; 40,-82; 50,-82],  style(color=74,
                rgbcolor={0,0,127}));
          connect(feedback1.y,stateSpaceController. phi_steer) annotation (
              points=[-23,-56; 40,-56; 40,-68; 50,-68], style(color=74,
                rgbcolor={0,0,127}));
          connect(derivative1.u,feedback1. y) annotation (points=[-4,-72; -12,-72;
                -12,-56; -23,-56],      style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer,feedback1. u1) annotation (points=[-63,-56;
                -40,-56],                                       style(color=74,
                rgbcolor={0,0,127}));
          connect(derivative1.y,stateSpaceController. der_phi_steer) annotation (
              points=[19,-72; 50,-72],
                                     style(color=74, rgbcolor={0,0,127}));
          connect(const1.y, feedback.u1) annotation (points=[-111,-96; -60,-96],
              style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.lean, const1.y) annotation (points=[-86,-50; -102,
                -50; -102,-96; -111,-96], style(color=74, rgbcolor={0,0,127}));
          connect(const2.y, lean2steer.v) annotation (points=[-111,-62; -86,-62],
              style(color=74, rgbcolor={0,0,127}));
          connect(motorcycle_Vittore_complete.steer_angle, feedback1.u2)
            annotation (points=[-31.8,0; -32,0; -32,-48], style(color=74,
                rgbcolor={0,0,127}));
          connect(motorcycle_Vittore_complete.phi, feedback.u2) annotation (
              points=[45,60; 86,60; 86,-14; -52,-14; -52,-88], style(color=74,
                rgbcolor={0,0,127}));
          connect(PI1.u, feedback.y) annotation (points=[50,-126; -30,-126; -30,
                -96; -43,-96], style(color=74, rgbcolor={0,0,127}));
          connect(add3_1.u2, PI1.y) annotation (points=[86,-106; 80,-106; 80,-126;
                73,-126], style(color=74, rgbcolor={0,0,127}));
          connect(add3_1.y, limiter.u) annotation (points=[109,-100; 120,-100;
                120,-76], style(color=74, rgbcolor={0,0,127}));
          connect(limiter.y, motorcycle_Vittore_complete.T_Steering) annotation (
              points=[120,-53; 120,-30; -12,-30; -12,-0.8; -11,-0.8], style(color=
                 74, rgbcolor={0,0,127}));
          connect(stateSpaceController.v, const2.y) annotation (points=[50,-88;
                -96,-88; -96,-62; -111,-62], style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController.T_steering, add3_1.u1) annotation (points=
                [73,-78; 80,-78; 80,-94; 86,-94], style(color=74, rgbcolor={0,0,
                  127}));
        end ControlledRange_3dof_motorcycle_zeroSteadyState;

        model ControlledRange_3dof_motorcycle_zeroSteadyState_Curve
          import MotorcycleLib;
          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 6;

          MotorcycleLib.BasicMotorcycle.Motorcycle_Vittore_3dof
            motorcycle_Vittore_complete(
            p1={0.48,0.616,0},
            p2={0.024,0.461,0},
            d=6.8,
            enforceStates=true)
            annotation (extent=[-63,4; 41,84]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody FWheelMass(
            I_21=0,
            I_31=0,
            I_32=0,
            animation=false,
            I_11=0,
            I_22=0,
            I_33=0.72,
            m=1) annotation (extent=[-74,-4; -54,16]);
          MotorcycleLib.IdealWheels.Wheel wheel(
            r=0.305,
            I_11=0,
            I_22=0,
            I_33=1.05,
            m=1,
            useTransVelocities=false,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            enforceStates=false,
            phi_start={0,0,0},
            w_start=vs*{0,0,1/0.305*180/Modelica.Constants.pi})
                                 annotation (extent=[72,-4; 52,16],   rotation=0);
          MotorcycleLib.IdealWheels.WheelJoint wheelJoint(
                                                     r=0.305)
            annotation (extent=[-110,-4; -90,16]);
          inner MultiBondLib.Mechanics3D.World3D world3D
            annotation (extent=[-130,70; -110,90]);
          Modelica.Blocks.Continuous.Der derivative
            annotation (extent=[-2,-122; 18,-102], rotation=0);
          Modelica.Blocks.Continuous.Der derivative1
            annotation (extent=[-2,-82; 18,-62],   rotation=0);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StabilityControl.StabilityController_table
            stateSpaceController(filename="placeImproved.mat")
                                 annotation (extent=[52,-88; 72,-68]);
          Modelica.Blocks.Math.Feedback feedback
            annotation (extent=[-62,-86; -42,-106]);
          Modelica.Blocks.Math.Feedback feedback1
            annotation (extent=[-42,-46; -22,-66], rotation=0);
          MotorcycleLib.VirtualRider.Utilities.lean2steer lean2steer
                                        annotation (extent=[-84,-66; -64,-46]);
          Modelica.Blocks.Sources.Constant const2(k=vs)
            annotation (extent=[-132,-72; -112,-52]);
          Modelica.Blocks.Math.Add add3_1(k1=1)
            annotation (extent=[88,-110; 108,-90]);
          Modelica.Blocks.Continuous.PI PI1(k=1, T=0.015)
            annotation (extent=[52,-136; 72,-116]);
          Modelica.Blocks.Nonlinear.Limiter limiter(uMax=1000)
            annotation (extent=[110,-74; 130,-54], rotation=90);
          MotorcycleLib.Environments.Tracks.OpenLoopMethod.Curve_90degree
            standard_90degree_curve(v=vs)
                                    annotation (extent=[-132,-106; -112,-86]);
        equation
          connect(wheelJoint.frame_b,FWheelMass. frame_a) annotation (points=[-89,6;
                -75,6],        style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(wheelJoint.frame_b, motorcycle_Vittore_complete.connectFW)
            annotation (points=[-89,6; -82,6; -82,24; -66.2,24],     style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          annotation (Diagram,
            experiment(StopTime=15),
            experimentSetupOutput,
            Icon(
              Text(extent=[-140,162; 136,102],  string="%name"),
              Ellipse(extent=[-100,100; 100,-100], style(
                  color=78,
                  rgbcolor={127,0,127},
                  fillColor=7,
                  rgbfillColor={255,255,255})),
              Text(
                extent=[-100,100; 100,-80],
                string="ex",
                style(color=78, rgbcolor={127,0,127}))),
            Coordsys(extent=[-140,-150; 140,100], scale=0.1));
          connect(wheel.frame_b, motorcycle_Vittore_complete.connectRW)
            annotation (points=[51,6; 48,6; 48,24; 40.2,24],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(derivative.u,feedback. y) annotation (points=[-4,-112; -12,-112;
                -12,-96; -43,-96],       style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController.phi_lean,feedback. y) annotation (points=[50,-78;
                32,-78; 32,-96; -43,-96],
                                  style(color=74, rgbcolor={0,0,127}));
          connect(derivative.y,stateSpaceController. der_phi_lean) annotation (
              points=[19,-112; 40,-112; 40,-82; 50,-82],  style(color=74,
                rgbcolor={0,0,127}));
          connect(feedback1.y,stateSpaceController. phi_steer) annotation (
              points=[-23,-56; 40,-56; 40,-68; 50,-68], style(color=74,
                rgbcolor={0,0,127}));
          connect(derivative1.u,feedback1. y) annotation (points=[-4,-72; -12,-72;
                -12,-56; -23,-56],      style(color=74, rgbcolor={0,0,127}));
          connect(lean2steer.steer,feedback1. u1) annotation (points=[-63,-56;
                -40,-56],                                       style(color=74,
                rgbcolor={0,0,127}));
          connect(derivative1.y,stateSpaceController. der_phi_steer) annotation (
              points=[19,-72; 50,-72],
                                     style(color=74, rgbcolor={0,0,127}));
          connect(const2.y, lean2steer.v) annotation (points=[-111,-62; -86,-62],
              style(color=74, rgbcolor={0,0,127}));
          connect(motorcycle_Vittore_complete.steer_angle, feedback1.u2)
            annotation (points=[-31.8,0; -32,0; -32,-48], style(color=74,
                rgbcolor={0,0,127}));
          connect(motorcycle_Vittore_complete.phi, feedback.u2) annotation (
              points=[45,60; 86,60; 86,-14; -52,-14; -52,-88], style(color=74,
                rgbcolor={0,0,127}));
          connect(PI1.u, feedback.y) annotation (points=[50,-126; -30,-126; -30,
                -96; -43,-96], style(color=74, rgbcolor={0,0,127}));
          connect(add3_1.u2, PI1.y) annotation (points=[86,-106; 80,-106; 80,-126;
                73,-126], style(color=74, rgbcolor={0,0,127}));
          connect(add3_1.y, limiter.u) annotation (points=[109,-100; 120,-100;
                120,-76], style(color=74, rgbcolor={0,0,127}));
          connect(limiter.y, motorcycle_Vittore_complete.T_Steering) annotation (
              points=[120,-53; 120,-30; -12,-30; -12,-0.8; -11,-0.8], style(color=
                 74, rgbcolor={0,0,127}));
          connect(stateSpaceController.v, const2.y) annotation (points=[50,-88;
                -96,-88; -96,-62; -111,-62], style(color=74, rgbcolor={0,0,127}));
          connect(stateSpaceController.T_steering, add3_1.u1) annotation (points=
                [73,-78; 80,-78; 80,-94; 86,-94], style(color=74, rgbcolor={0,0,
                  127}));
          connect(standard_90degree_curve.leanAngle, feedback.u1) annotation (
              points=[-111,-96; -60,-96], style(color=74, rgbcolor={0,0,127}));
          connect(standard_90degree_curve.leanAngle, lean2steer.lean) annotation (
             points=[-111,-96; -102,-96; -102,-50; -86,-50], style(color=74,
                rgbcolor={0,0,127}));
        end ControlledRange_3dof_motorcycle_zeroSteadyState_Curve;
      end Temp;
    end BasicMotorcycle;

    package AdvancedMotorcycle
      package SL2001 "Limebeer and Sharps 2001 Motorcycle Model"
        model SL2001Motorcycle "Motorcycle Model based on the SL2001 Model"
          import MotorcycleLib;
          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 6;
          MotorcycleLib.AdvancedMotorcycle.Parts.RearFrame RearFrame(
            R_rw=0.321,
            m=209.6,
            p2={1.168,0.834,0},
            p8={0.68,0.532,0},
            p9={0.6,1,0},
            p11={0.4,0.321,0},
            I_11=6.9,
            I_22=21.1,
            I_33=34.1,
            enforceStates=true,
            p1={0.77,0.9,0},
            I_21=1.7)  annotation (extent=[-39,-26; 21,24]);
          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontFrame
            FrontFrame(
            w=1.539,
            epsilon=30,
            p2={1.168,0.834,0},
            p3={1.165,0.869,0},
            p4={1.225,0.867,0},
            offset=0.0656,
            mFF=13.1,
            ds=7.4,
            I_FS_11=0,
            I_FS_22=0,
            I_FS_33=0,
            I_FF_11=0.8,
            I_FF_22=0.5,
            I_FF_33=1.2,
            p5={1.539,0.318,0},
            init_steerAngle=0,
            R_rw=0.321,
            d=550,
            ctw=34100,
            dtw=99.7,
            bias=0.2,
            mFS=17.5,
            c=9000,
            R_fw=0.319)  annotation (extent=[-80,-9; -40,31]);
          annotation (Diagram,
            experiment(StopTime=10, Algorithm="Dassl"),
            experimentSetupOutput,
            Icon(
              Ellipse(extent=[-40,-60; -100,0], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[100,-60; 40,0], style(color=0, rgbcolor={0,0,0})),
              Line(points=[-70,-30; -40,60; -20,60; -20,60], style(color=0,
                    rgbcolor={0,0,0})),
              Line(points=[70,-30; 28,-30; -10,-30; -46,40; 20,20; 32,-30], style(
                    color=0, rgbcolor={0,0,0})),
              Line(points=[20,20; 80,40], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[-65,-35; -75,-25], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[75,-35; 65,-25], style(color=0, rgbcolor={0,0,0}))));

          MotorcycleLib.IdealWheels.Wheel RearWheel(
            r=0.321,
            m=25.6,
            I_11=0,
            I_22=0,
            I_33=0.74,
            animation=true,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            enforceStates=false,
            w_start=vs*{0,0,1/0.321*180/Modelica.Constants.pi},
            phi_start={0,5,0})  annotation (extent=[82,-50; 62,-30]);
          MotorcycleLib.IdealWheels.WheelJoint FrontWheel(r=0.321)
            annotation (extent=[-90,-50; -70,-30]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody simpleBody(
            animation=false,
            I_11=0,
            I_22=0,
            I_33=0.58,
            m=17.5)    annotation (extent=[-50,-50; -30,-30]);
          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[-90,70; -70,90]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RiderUpperBody Rider(
            m=44.5,
            p10={0.6,1.19,0},
            I_11=1.3,
            I_22=1.4,
            I_33=2.1,
            I_21=0.3,
            p9={0.6,1.0,0},
            phi_start=0,
            c=10000,
            d=85.2)
                  annotation (extent=[-26,22; 0,50]);
          MotorcycleLib.AdvancedMotorcycle.Parts.SwingingArms.SwingingArm_classic
            SwingingArm(
            p11={0.4,0.321,0},
            p12={0,0.33,0},
            p13={0,0.7,0},
            p14={0.1,0.33,0},
            mSA=0,
            R_rw=0.321,
            c=25700,
            d=1100,
            bias=0.05,
            I_11=0,
            I_22=0,
            I_33=0)   annotation (extent=[18,-25; 48,5]);
          Modelica.Blocks.Interfaces.RealInput ControllerDesignInput
            "this input is needed for controller design"
            annotation (extent=[-134,33; -100,67], rotation=0);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.LiftForce liftForce(
              arrowColor={0,0,255}, CL=0.114)
                                    annotation (extent=[-56,-100; -36,-80]);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.DragForce dragForce
            annotation (extent=[-56,-76; -36,-56]);
          Modelica.Blocks.Sources.Constant const(k=vs)
            annotation (extent=[-98,-88; -78,-68]);
        equation
          connect(FrontFrame.SteeringAxis, RearFrame.SteeringAxis)
            annotation (points=[-50,19; -41.5,19],
                                                 style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(simpleBody.frame_a, FrontWheel.frame_b) annotation (points=[-51,-40;
                -69,-40],      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(FrontFrame.RevoltueAxis, FrontWheel.frame_b)     annotation (
              points=[-60,-9; -60,-40; -69,-40],  style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Rider.RearFrame, RearFrame.RiderUpperBody) annotation (points=[-11.7,
                22.84; -11.7,6.42; -11.5,6.42; -11.5,5],       style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SwingingArm.RearFrameCon1, RearFrame.SwingingArm) annotation (
              points=[15.9,-16; 14.5,-16],
                                        style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RearWheel.frame_b, SwingingArm.RearWheel) annotation (points=[61,-40;
                54,-40; 54,-16; 50.1,-16],         style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(ControllerDesignInput, FrontFrame.T_Steering) annotation (
              points=[-117,50; -60,50; -60,30], style(color=74, rgbcolor={0,0,
                  127}));
          connect(dragForce.frame_a, RearFrame.Aerodynamics_CoP) annotation (
              points=[-36,-66; -21.5,-66; -21.5,-1], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(liftForce.frame_a, RearFrame.Aerodynamics_CoP) annotation (
              points=[-36,-90; -21.5,-90; -21.5,-1], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(const.y, dragForce.v) annotation (points=[-77,-78; -68,-78;
                -68,-66; -58,-66], style(color=74, rgbcolor={0,0,127}));
          connect(const.y, liftForce.v) annotation (points=[-77,-78; -68,-78;
                -68,-90; -58,-90], style(color=74, rgbcolor={0,0,127}));
        end SL2001Motorcycle;

        model SL2001Motorcycle_externalForces
          "Motorcycle Model based on the SL2001 Model including side wind and aerodynamic forces"
          import MotorcycleLib;

          import SI = Modelica.SIunits;

          //parameter SI.Velocity v = 10;

          annotation (Diagram,
            experiment(StopTime=10),
            experimentSetupOutput,
            Icon(
              Ellipse(extent=[-40,-60; -100,0], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[100,-60; 40,0], style(color=0, rgbcolor={0,0,0})),
              Line(points=[-70,-30; -40,60; -20,60; -20,60], style(color=0,
                    rgbcolor={0,0,0})),
              Line(points=[70,-30; 28,-30; -10,-30; -46,40; 20,20; 32,-30], style(
                    color=0, rgbcolor={0,0,0})),
              Line(points=[20,20; 80,40], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[-65,-35; -75,-25], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[75,-35; 65,-25], style(color=0, rgbcolor={0,0,0}))));

          MotorcycleLib.IdealWheels.Wheel RearWheel(
            r=0.321,
            m=25.6,
            I_11=0,
            I_22=0,
            I_33=0.74,
            animation=true,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            enforceStates=false,
            w_start={0,0,0},
            phi_start={0,5,0})  annotation (extent=[90,-68; 70,-48]);
          MotorcycleLib.IdealWheels.WheelJoint FrontWheel(         r=0.321)
            annotation (extent=[-90,-68; -70,-48]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody simpleBody(
            animation=false,
            m=1e-3,
            I_11=0,
            I_22=0,
            I_33=0.58) annotation (extent=[-50,-68; -30,-48]);
          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[-100,80;
                -80,100]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RiderUpperBody Rider(
            m=44.5,
            p10={0.6,1.19,0},
            I_11=1.3,
            I_22=1.4,
            I_33=2.1,
            I_21=0.3,
            p9={0.6,1.0,0},
            phi_start=0,
            c=10000,
            d=85.2)
                  annotation (extent=[-23,2; 3,30]);
          MotorcycleLib.AdvancedMotorcycle.Parts.SwingingArms.SwingingArm_classic
            SwingingArm(
            p11={0.4,0.321,0},
            p12={0,0.33,0},
            p13={0,0.7,0},
            p14={0.1,0.33,0},
            mSA=0,
            R_rw=0.321,
            c=25000,
            d=1100,
            bias=0.1) annotation (extent=[20,-43; 50,-13]);
          Modelica.Blocks.Sources.Ramp ramp1(
            duration=10,
            startTime=3,
            offset=6,
            height=4)          annotation (extent=[-90,46; -70,66]);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.LiftForce liftForce(
              arrowColor={0,0,255}) annotation (extent=[-52,28; -32,48]);
          BondLib.Mechanical.Rotational.Sensors.SpeedSensor speedSensor
            annotation (extent=[50,6; 70,26],     rotation=180);
          MotorcycleLib.VirtualRider.VelocityControl.SpeedController
            speedController(r=0.321)
            annotation (extent=[30,46; 50,66]);
          MotorcycleLib.AdvancedMotorcycle.Parts.Engine torqueEngine
            annotation (extent=[60,44; 80,64],   rotation=0);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.DragForce dragForce
            annotation (extent=[-52,60; -32,80]);
          MotorcycleLib.Environments.Disturbances.SideWind sideWind(a=200, s=
               5)
            annotation (extent=[-42,-92; -22,-72]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RearFrame RearFrame(
            R_rw=0.321,
            m=209.6,
            p2={1.168,0.834,0},
            p8={0.68,0.532,0},
            p9={0.6,1,0},
            p11={0.4,0.321,0},
            I_11=6.9,
            I_22=21.1,
            I_33=34.1,
            enforceStates=true,
            p1={0.77,0.9,0},
            I_21=1.7)  annotation (extent=[-41,-44; 19,6]);
          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontFrame
            FrontFrame(
            w=1.539,
            epsilon=30,
            p2={1.168,0.834,0},
            p3={1.165,0.869,0},
            p4={1.225,0.867,0},
            offset=0.0656,
            mFS=17.5,
            mFF=13.1,
            ds=7.4,
            I_FS_11=0,
            I_FS_22=0,
            I_FS_33=0,
            I_FF_11=0.8,
            I_FF_22=0.5,
            I_FF_33=1.2,
            p5={1.539,0.318,0},
            init_steerAngle=0,
            R_fw=0.321,
            R_rw=0.321,
            c=9000,
            d=550,
            ctw=34100,
            dtw=99.7,
            bias=0.2)    annotation (extent=[-80,-27; -40,13]);
        equation
          connect(simpleBody.frame_a, FrontWheel.frame_b) annotation (points=[-51,-58;
                -69,-58],      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RearWheel.frame_b, SwingingArm.RearWheel) annotation (points=[69,-58;
                60,-58; 60,-34; 52.1,-34],      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(speedSensor.w,speedController. w) annotation (points=[50,16;
                40,16; 40,44],
                            style(color=74, rgbcolor={0,0,127}));
          connect(torqueEngine.u,speedController. T_engine)
            annotation (points=[61,56; 51,56],style(color=74, rgbcolor={0,0,127}));
          connect(torqueEngine.flange_b, SwingingArm.flange_a) annotation (points=[80,56;
                90,56; 90,-40; 50,-40],                style(color=0, rgbcolor={0,0,
                  0}));
          connect(torqueEngine.flange_a, SwingingArm.flange_b) annotation (points=[80,46;
                80,-28; 50,-28],             style(color=0, rgbcolor={0,0,0}));
          connect(speedSensor.flange_a, SwingingArm.flange_a) annotation (points=[70,16;
                90,16; 90,-40; 50,-40],                  style(color=0, rgbcolor={0,
                  0,0}));
          connect(ramp1.y, speedController.v) annotation (points=[-69,56; 28,56],
              style(color=74, rgbcolor={0,0,127}));
          connect(liftForce.v, ramp1.y) annotation (points=[-54,38; -60,38; -60,
                56; -69,56],
                         style(color=74, rgbcolor={0,0,127}));
          connect(dragForce.v, ramp1.y) annotation (points=[-54,70; -60,70; -60,
                56; -69,56],
                         style(color=74, rgbcolor={0,0,127}));
          connect(FrontWheel.frame_b, FrontFrame.RevoltueAxis) annotation (
              points=[-69,-58; -60,-58; -60,-27], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(FrontFrame.SteeringAxis, RearFrame.SteeringAxis) annotation (
              points=[-50,1; -43.5,1], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RearFrame.RiderUpperBody, Rider.RearFrame) annotation (points=[-13.5,
                -13; -13.5,-4; -8.7,-4; -8.7,2.84],       style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RearFrame.SwingingArm, SwingingArm.RearFrameCon1) annotation (
             points=[12.5,-34; 17.9,-34], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(liftForce.frame_a, RearFrame.Aerodynamics_CoP) annotation (
              points=[-32,38; -23.5,38; -23.5,-19], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(dragForce.frame_a, RearFrame.Aerodynamics_CoP) annotation (
              points=[-32,70; -23.5,70; -23.5,-19], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(sideWind.frame_a, RearFrame.CoM) annotation (points=[-22,-82;
                -6,-82; -6,-25], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
        end SL2001Motorcycle_externalForces;

        model SL2001Motorcycle_AndresTires
          "Motorcycle Model based on the SL2001 Model"
          import MotorcycleLib;
          import SI = Modelica.SIunits;

          parameter SI.Velocity v = 10;
          annotation (Diagram(
              Text(
                extent=[-50,94; 94,66],
                string=
                    "... needed in combination with Tires provided by the WheelsAndTires library",
                style(
                  color=10,
                  rgbcolor={95,95,95},
                  fillColor=70,
                  rgbfillColor={45,96,172})), Rectangle(extent=[-74,94; 94,66],  style(
                  color=9,
                  rgbcolor={175,175,175},
                  thickness=2))),
            experiment(StopTime=10, Algorithm="Dassl"),
            experimentSetupOutput,
            Icon(
              Ellipse(extent=[-40,-60; -100,0], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[100,-60; 40,0], style(color=0, rgbcolor={0,0,0})),
              Line(points=[-70,-30; -40,60; -20,60; -20,60], style(color=0,
                    rgbcolor={0,0,0})),
              Line(points=[70,-30; 28,-30; -10,-30; -46,40; 20,20; 32,-30], style(
                    color=0, rgbcolor={0,0,0})),
              Line(points=[20,20; 80,40], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[-65,-35; -75,-25], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[75,-35; 65,-25], style(color=0, rgbcolor={0,0,0}))),
            Coordsys(extent=[-120,-110; 100,100], scale=0.1));

          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[-110,70;
                -90,90]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RiderUpperBody Rider(
            m=44.5,
            p10={0.6,1.19,0},
            I_11=1.3,
            I_22=1.4,
            I_33=2.1,
            I_21=0.3,
            p9={0.6,1.0,0},
            phi_start=5,
            d=5,
            c=250)
                  annotation (extent=[-16,34; 10,62]);
          MotorcycleLib.AdvancedMotorcycle.Parts.SwingingArms.SwingingArm_classic
            SwingingArm(
            p11={0.4,0.321,0},
            p12={0,0.33,0},
            p13={0,0.7,0},
            p14={0.1,0.33,0},
            c=25700,
            d=1100,
            mSA=0,
            R_rw=0.321,
            bias=0.05)
                      annotation (extent=[24,-9; 54,21]);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StateSpace_VR
            stabilityController(F=[657.2662,23.0009,246.2359,47.0975],
            p=1.539,
            eps=30)
            annotation (extent=[-41,-85; -11,-55]);
          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontFrame
            FrontFrame(
            w=1.539,
            epsilon=30,
            p2={1.168,0.834,0},
            p3={1.165,0.869,0},
            p4={1.225,0.867,0},
            offset=0.0656,
            mFS=17.5,
            mFF=13.1,
            ds=7.4,
            I_FS_11=0,
            I_FS_22=0,
            I_FS_33=0,
            I_FF_11=0.8,
            I_FF_22=0.5,
            I_FF_33=1.2,
            p5={1.539,0.318,0},
            init_steerAngle=0,
            R_fw=0.321,
            R_rw=0.321,
            c=9000,
            d=550,
            ctw=34100,
            dtw=99.7,
            bias=0.2)    annotation (extent=[-72,7; -32,47]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RearFrame RearFrame(
            R_rw=0.321,
            m=209.6,
            p2={1.168,0.834,0},
            p8={0.68,0.532,0},
            p9={0.6,1,0},
            p11={0.4,0.321,0},
            I_11=6.9,
            I_22=21.1,
            I_33=34.1,
            enforceStates=true,
            p1={0.77,0.9,0},
            I_21=1.7)  annotation (extent=[-33,-10; 27,40]);
          Modelica.Blocks.Sources.Constant const(k=v)
            annotation (extent=[-110,-74; -90,-54]);
          WheelsAndTires.Tires.Slim.IdealTire RWheel(
            enforceStates=false,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            phi_start={5*Modelica.Constants.pi/180,0,0},
            I_11=0,
            I_22=0,
            mRim=1e-3,
            visForcesEnabled=false,
            I_33=0.74,
            w_start=v*{0,0,1/0.321},
            rWheel=0.321,
            height=20e-3)
            annotation (extent=[62,-52; 102,-12], rotation=180);
          WheelsAndTires.Tires.Slim.IdealTire FWheel(
            initType=Modelica.Mechanics.MultiBody.Types.Init.Free,
            I_11=0,
            I_22=0,
            mRim=1e-3,
            visForcesEnabled=false,
            visBeltEnabled=true,
            I_33=0.58,
            rWheel=0.321,
            height=20e-3)
            annotation (extent=[-60,-50; -100,-10], rotation=180);
          inner WheelsAndTires.Environment.Surface Surface(visSurface=false)
            annotation (extent=[-70,70; -50,90]);
          MotorcycleLib.Environments.Tracks.OpenLoopMethod.Curve_90degree
            standard_90degree_curve(v=v, table=curve90degree_basicMotorcycle.table)
                                    annotation (extent=[-110,-100; -90,-80]);
          MotorcycleLib.Environments.Tracks.OpenLoopMethod.Data.Curve90degree_basicMotorcycle
            curve90degree_basicMotorcycle(v=v)
            annotation (extent=[-110,40; -90,60]);
        equation
          connect(RearFrame.SwingingArm, SwingingArm.RearFrameCon1) annotation (
             points=[20.5,0; 21.9,0], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RearFrame.RiderUpperBody, Rider.RearFrame) annotation (points=[-5.5,21;
                -5.5,28.5; -1.7,28.5; -1.7,34.84],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(FrontFrame.SteeringAxis, RearFrame.SteeringAxis) annotation (
              points=[-42,35; -35.5,35], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(stabilityController.T_steer, FrontFrame.T_Steering)
            annotation (points=[-9.5,-70; -4,-70; -4,-12; -72,-12; -72,54; -52,
                54; -52,46], style(color=74, rgbcolor={0,0,127}));
          connect(FrontFrame.y, stabilityController.delta) annotation (points=[-52,25;
                -52,-58; -44,-58],         style(color=74, rgbcolor={0,0,127}));
          connect(RearFrame.phi, stabilityController.phi) annotation (points=[29.5,
                32.5; 64,32.5; 64,-94; -52,-94; -52,-82; -44,-82],        style(
                color=74, rgbcolor={0,0,127}));
          connect(const.y, stabilityController.v) annotation (points=[-89,-64;
                -44,-64],                   style(color=74, rgbcolor={0,0,127}));
          connect(RWheel.TireHub, SwingingArm.RearWheel) annotation (points=[62,-32;
                58,-32; 58,0; 56.1,0],
                                    style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(FWheel.TireHub, FrontFrame.RevoltueAxis) annotation (points=[-60,-30;
                -52,-30; -52,7],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(standard_90degree_curve.leanAngle, stabilityController.phi_set)
            annotation (points=[-89,-90; -60,-90; -60,-76; -44,-76], style(
                color=74, rgbcolor={0,0,127}));
        end SL2001Motorcycle_AndresTires;


        annotation (Documentation(info="<html>


</html>"));
        function StabilityAnalysis
          "Stability analysis of an uncontrolled motorcycle, plots eigenvalues as a function of bicycle's forward velocity"

          input String modelName = "MotorcycleLib.Examples.AdvancedMotorcycle.SL2001.SL2001Motorcycle";
          input String independentVariableName = "vs";
          input Real startValue = 0 "lowest velocity";
          input Real endValue = 16 "highest velocity";
          input Integer n = 51 "Number of steps";

          input Real states[15] = {1,2, 3,4, 5,6, 7,8, 11,12, 13,14, 15, 16, 18}
            "|State Selection (state vector)| execute getStates in order to determine the names of the state variables";

          input Integer plotSignals = 0
            "|Signals to plot| 0 ... real and imaginary eigenvalues; 1 ... real eigenvalues; 2 ... imaginary eigenvalues";

        algorithm
         MotorcycleLib.AdvancedMotorcycle.StabilityAnalysis.CalculateEigenvaluesAdvancedMotorcycle(
                  modelName,
                  "vs",
                  startValue,
                  endValue,
                  n,
                  states,
                  plotSignals);
          annotation (Documentation(info="<HTML>

<p>
To run the example in Dymola, select this model in the package browser, click the right mouse button and select Call Function and click Execute.
</p>
<p>
The function exploits
<span class=\"cite\">[<a href=\"Modelica://MotorcycleLib.BasicMotorcycle.CalculateEigenvaluesMotorcycle\">Examples.BasicMotorcycle.CalculateEigenvaluesMotorcycle</a>]</span>.
</p>
</HTML>"));
        end StabilityAnalysis;

        model SL2001MotorcycleSS_ControlledV2
          "Motorcycle Model based on the SL2001 Model"
          import MotorcycleLib;
          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 6;
          annotation (Diagram,
            experiment(StopTime=20, Tolerance=1e-006),
            experimentSetupOutput,
            Icon(
              Ellipse(extent=[-40,-60; -100,0], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[100,-60; 40,0], style(color=0, rgbcolor={0,0,0})),
              Line(points=[-70,-30; -40,60; -20,60; -20,60], style(color=0,
                    rgbcolor={0,0,0})),
              Line(points=[70,-30; 28,-30; -10,-30; -46,40; 20,20; 32,-30], style(
                    color=0, rgbcolor={0,0,0})),
              Line(points=[20,20; 80,40], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[-65,-35; -75,-25], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[75,-35; 65,-25], style(color=0, rgbcolor={0,0,0}))),
            Coordsys(extent=[-120,-120; 120,120], scale=0.1));

          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[90,90; 110,
                110]);
          Modelica.Blocks.Sources.Constant const(k=vs)
            annotation (extent=[-108,70; -88,90]);
          Modelica.Blocks.Sources.Constant const1(k=0*Modelica.Constants.pi/180)
            annotation (extent=[-108,40; -88,60]);
          MotorcycleLib.VirtualRider.VirtualRigidRider.RollAngleTracking.StateSpace_VR
            stabilityController(
            p=1.539,
            eps=30,
            F=[182.8642,51.3195,271.3657,11.6059])
            annotation (extent=[-38,59; -8,89],rotation=0);
          MotorcycleLib.AdvancedMotorcycle.Parts.RearFrame RearFrame(
            R_rw=0.321,
            m=209.6,
            p2={1.168,0.834,0},
            p8={0.68,0.532,0},
            p9={0.6,1,0},
            p11={0.4,0.321,0},
            I_11=6.9,
            I_22=21.1,
            I_33=34.1,
            enforceStates=true,
            p1={0.77,0.9,0},
            I_21=1.7)  annotation (extent=[-31,-42; 29,8]);
          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontFrame
            FrontFrame(
            w=1.539,
            epsilon=30,
            p2={1.168,0.834,0},
            p3={1.165,0.869,0},
            p4={1.225,0.867,0},
            offset=0.0656,
            mFF=13.1,
            ds=7.4,
            I_FS_11=0,
            I_FS_22=0,
            I_FS_33=0,
            I_FF_11=0.8,
            I_FF_22=0.5,
            I_FF_33=1.2,
            p5={1.539,0.318,0},
            init_steerAngle=0,
            R_rw=0.321,
            d=550,
            ctw=34100,
            dtw=99.7,
            bias=0.2,
            mFS=17.5,
            c=9000,
            R_fw=0.319)  annotation (extent=[-72,-25; -32,15]);
          MotorcycleLib.IdealWheels.Wheel RearWheel(
            r=0.321,
            m=25.6,
            I_11=0,
            I_22=0,
            I_33=0.74,
            animation=true,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            enforceStates=false,
            w_start=vs*{0,0,1/0.321*180/Modelica.Constants.pi},
            phi_start={0,5,0})  annotation (extent=[90,-66; 70,-46]);
          MotorcycleLib.IdealWheels.WheelJoint FrontWheel(r=0.321)
            annotation (extent=[-82,-66; -62,-46]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody simpleBody(
            animation=false,
            I_11=0,
            I_22=0,
            I_33=0.58,
            m=17.5)    annotation (extent=[-42,-66; -22,-46]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RiderUpperBody Rider(
            m=44.5,
            p10={0.6,1.19,0},
            I_11=1.3,
            I_22=1.4,
            I_33=2.1,
            I_21=0.3,
            p9={0.6,1.0,0},
            phi_start=0,
            c=10000,
            d=85.2)
                  annotation (extent=[-18,6; 8,34]);
          MotorcycleLib.AdvancedMotorcycle.Parts.SwingingArms.SwingingArm_classic
            SwingingArm(
            p11={0.4,0.321,0},
            p12={0,0.33,0},
            p13={0,0.7,0},
            p14={0.1,0.33,0},
            mSA=0,
            R_rw=0.321,
            c=25700,
            d=1100,
            bias=0.05,
            I_11=0,
            I_22=0,
            I_33=0)   annotation (extent=[26,-41; 56,-11]);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.LiftForce liftForce(
              arrowColor={0,0,255}, CL=0.114)
                                    annotation (extent=[-48,-116; -28,-96]);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.DragForce dragForce
            annotation (extent=[-48,-92; -28,-72]);
          Modelica.Blocks.Sources.Constant const2(
                                                 k=vs)
            annotation (extent=[-90,-104; -70,-84]);
        equation
          connect(const1.y, stabilityController.phi_set) annotation (points=[-87,50;
                -58,50; -58,68; -41,68],   style(color=74, rgbcolor={0,0,127}));
          connect(stabilityController.v, const.y) annotation (points=[-41,80;
                -87,80],             style(color=74, rgbcolor={0,0,127}));
          connect(FrontFrame.SteeringAxis,RearFrame. SteeringAxis)
            annotation (points=[-42,3; -33.5,3], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(simpleBody.frame_a,FrontWheel. frame_b) annotation (points=[-43,-56;
                -61,-56],      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(FrontFrame.RevoltueAxis,FrontWheel. frame_b)     annotation (
              points=[-52,-25; -52,-56; -61,-56], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Rider.RearFrame,RearFrame. RiderUpperBody) annotation (points=[-3.7,
                6.84; -3.7,-9.58; -3.5,-9.58; -3.5,-11],       style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SwingingArm.RearFrameCon1,RearFrame. SwingingArm) annotation (
              points=[23.9,-32; 22.5,-32],
                                        style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RearWheel.frame_b,SwingingArm. RearWheel) annotation (points=[69,-56;
                62,-56; 62,-32; 58.1,-32],         style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(dragForce.frame_a,RearFrame. Aerodynamics_CoP) annotation (
              points=[-28,-82; -13.5,-82; -13.5,-17],style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(liftForce.frame_a,RearFrame. Aerodynamics_CoP) annotation (
              points=[-28,-106; -13.5,-106; -13.5,-17],
                                                     style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(const2.y, dragForce.v)
                                        annotation (points=[-69,-94; -60,-94;
                -60,-82; -50,-82], style(color=74, rgbcolor={0,0,127}));
          connect(const2.y, liftForce.v)
                                        annotation (points=[-69,-94; -60,-94;
                -60,-106; -50,-106],
                                   style(color=74, rgbcolor={0,0,127}));
          connect(FrontFrame.T_Steering, stabilityController.T_steer)
            annotation (points=[-52,14; -52,46; 0,46; 0,74; -6.5,74], style(
                color=74, rgbcolor={0,0,127}));
          connect(stabilityController.phi, RearFrame.phi) annotation (points=[
                -41,62; -48,62; -48,40; 38,40; 38,0.5; 31.5,0.5], style(color=
                  74, rgbcolor={0,0,127}));
          connect(FrontFrame.y, stabilityController.delta) annotation (points=[
                -52,-7; -52,-14; -74,-14; -74,86; -41,86], style(color=74,
                rgbcolor={0,0,127}));
        end SL2001MotorcycleSS_ControlledV2;
      end SL2001;

      package Sharp2004 "Sharps improved SL2001 motorcycle model"

        model Suzuki_GSX_R1000
          "Motorcycle Model based on Sharp's improved motorcycle model"
          import MotorcycleLib;
          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 10;
          MotorcycleLib.AdvancedMotorcycle.Parts.RearFrame RearFrame(
            enforceStates=true,
            p11={0.549,0.3608,0},
            R_rw=0.297,
            p2={1.173,0.749,0},
            p8={0.6779,0.4724,0},
            p9={0.364,0.8438,0},
            I_11=11.085,
            I_22=14.982,
            I_33=22.013,
            I_21=-3.691,
            m=165.13,
            p1={1.41/2,0,0})
                       annotation (extent=[-39,-6; 21,44]);
          annotation (Diagram,
            experiment(StopTime=10, Algorithm="Dassl"),
            experimentSetupOutput,
            Icon(
              Ellipse(extent=[-40,-60; -100,0], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[100,-60; 40,0], style(color=0, rgbcolor={0,0,0})),
              Line(points=[-70,-30; -40,60; -20,60; -20,60], style(color=0,
                    rgbcolor={0,0,0})),
              Line(points=[70,-30; 28,-30; -10,-30; -46,40; 20,20; 32,-30], style(
                    color=0, rgbcolor={0,0,0})),
              Line(points=[20,20; 80,40], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[-65,-35; -75,-25], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[75,-35; 65,-25], style(color=0, rgbcolor={0,0,0}))));

          MotorcycleLib.IdealWheels.Wheel RearWheel(
            I_22=0,
            animation=true,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            enforceStates=false,
            r=0.297,
            m=14.7,
            I_11=0.383,
            I_33=0.638,
            phi_start={0,5,0},
            w_start=vs*{0,0,1/0.297*180/Modelica.Constants.pi})
                                annotation (extent=[90,-30; 70,-10]);
          MotorcycleLib.IdealWheels.WheelJoint FrontWheel(r=0.282)
            annotation (extent=[-90,-30; -70,-10]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody simpleBody(
            animation=false,
            I_22=0,
            m=11.9,
            I_11=0.27,
            I_33=0.484)
                       annotation (extent=[-50,-30; -30,-10]);
          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[60,40; 80,
                60]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RiderUpperBody Rider(
            I_11=1.3,
            I_22=1.4,
            I_33=2.1,
            I_21=0.3,
            phi_start=0,
            p9={0.364,0.8438,0},
            p10={0.415,1.14,0},
            m=44.5,
            c=380,
            d=34) annotation (extent=[-26,34; 0,62]);
          MotorcycleLib.AdvancedMotorcycle.Parts.SwingingArms.SwingingArm_Rocker
            SwingingArm(
            R_rw=0.297,
            p11={0.549,0.3608,0},
            p22={0.3722,0.2748,0},
            p20={0.4946,0.1522,0},
            p21={0.4443,0.1782,0},
            p19={0.539,0.1878,0},
            p13={0.487,0.4888,0},
            p14={0.196,0.3113,0},
            c=58570,
            d=11650,
            I_11=0.02,
            I_22=0.259,
            I_33=0.259,
            mSA=8,
            bias=0.01)
                      annotation (extent=[21,-11; 51,19]);
          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontFramePreload
            FrontFrame(
            mFS=17.5,
            mFF=13.1,
            ds=7.4,
            I_FS_11=0,
            I_FS_22=0,
            I_FS_33=0,
            init_steerAngle=0,
            R_fw=0.282,
            R_rw=0.297,
            w=1.41,
            epsilon=24,
            p2={1.173,0.749,0},
            p3={1.164,0.77,0},
            p4={1.342,0.426,0},
            p5={1.365,0.324,0},
            d=2134,
            I_FF_11=1.341,
            I_FF_22=0.4125,
            I_FF_33=1.584,
            offset=0.026553,
            ctw=100000,
            dtw=100,
            c=25000,
            preload=882.1265)
                         annotation (extent=[-80,11; -40,51]);
        equation
          connect(simpleBody.frame_a, FrontWheel.frame_b) annotation (points=[-51,-20;
                -69,-20],      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RearWheel.frame_b, SwingingArm.RearWheel) annotation (points=[69,-20;
                60,-20; 60,4; 53.1,4],             style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SwingingArm.RearFrameCon1, RearFrame.SwingingArm) annotation (
             points=[18.9,4; 16.7,4; 16.7,4; 14.5,4],
                                          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=10,
              rgbfillColor={135,135,135}));
          connect(Rider.RearFrame, RearFrame.RiderUpperBody) annotation (points=[-11.7,
                34.84; -11.7,33.42; -11.5,33.42; -11.5,25],      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=70,
              rgbfillColor={45,96,172}));
          connect(FrontFrame.SteeringAxis, RearFrame.SteeringAxis) annotation (
              points=[-50,39; -41.5,39], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=10,
              rgbfillColor={135,135,135},
              fillPattern=1));
          connect(FrontFrame.RevoltueAxis, FrontWheel.frame_b) annotation (
              points=[-60,11; -60,-20; -69,-20], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=10,
              rgbfillColor={135,135,135},
              fillPattern=1));
        end Suzuki_GSX_R1000;

        model Suzuki_GSX_R1000_AndresTires
          "Motorcycle Model based on Sharp's improved motorcycle model"
          import MotorcycleLib;
          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 7;
          MotorcycleLib.AdvancedMotorcycle.Parts.RearFrame RearFrame(
            enforceStates=true,
            p11={0.549,0.3608,0},
            R_rw=0.297,
            p2={1.173,0.749,0},
            p8={0.6779,0.4724,0},
            p9={0.364,0.8438,0},
            m=165.13,
            I_11=11.085,
            I_22=14.982,
            I_33=22.013,
            I_21=-3.691,
            p1={0.77,0,0})
                       annotation (extent=[-39,-4; 21,46]);
          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontFrameUSD
            FrontFrame(
            ds=7.4,
            I_FS_11=0,
            I_FS_22=0,
            I_FS_33=0,
            init_steerAngle=0,
            R_fw=0.282,
            R_rw=0.297,
            w=1.41,
            epsilon=24,
            p2={1.173,0.749,0},
            p3={1.164,0.77,0},
            p4={1.342,0.426,0},
            p5={1.365,0.324,0},
            offset=0.026553,
            bias=0.2,
            mFS=7.25,
            mFF=9.99,
            I_FF_11=1.341,
            I_FF_22=0.4125,
            I_FF_33=1.584,
            c=25000,
            d=2134,
            ctw=100000,
            dtw=100)     annotation (extent=[-74,13; -34,53]);
          annotation (Diagram(
              Text(
                extent=[-44,100; 100,72],
                string=
                    "... needed in combination with Tires provided by the WheelsAndTires library",
                style(
                  color=10,
                  rgbcolor={95,95,95},
                  fillColor=70,
                  rgbfillColor={45,96,172})), Rectangle(extent=[-68,100; 100,72],style(
                  color=9,
                  rgbcolor={175,175,175},
                  thickness=2))),
            experiment(StopTime=10, Algorithm="Dassl"),
            experimentSetupOutput,
            Icon(
              Ellipse(extent=[-40,-60; -100,0], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[100,-60; 40,0], style(color=0, rgbcolor={0,0,0})),
              Line(points=[-70,-30; -40,60; -20,60; -20,60], style(color=0,
                    rgbcolor={0,0,0})),
              Line(points=[70,-30; 28,-30; -10,-30; -46,40; 20,20; 32,-30], style(
                    color=0, rgbcolor={0,0,0})),
              Line(points=[20,20; 80,40], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[-65,-35; -75,-25], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[75,-35; 65,-25], style(color=0, rgbcolor={0,0,0}))));

          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[60,40; 80,
                60]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RiderUpperBody Rider(
            phi_start=0,
            p9={0.364,0.8438,0},
            p10={0.415,1.14,0},
            I_11=1.428,
            I_22=0.916,
            I_33=1.347,
            I_21=0.443,
            m=33.68,
            c=380,
            d=34) annotation (extent=[-26,38; 0,66]);
          MotorcycleLib.AdvancedMotorcycle.Parts.SwingingArms.SwingingArm_Rocker
            SwingingArm(
            R_rw=0.297,
            p11={0.549,0.3608,0},
            p22={0.3722,0.2748,0},
            p20={0.4946,0.1522,0},
            p21={0.4443,0.1782,0},
            p19={0.539,0.1878,0},
            p13={0.487,0.4888,0},
            p14={0.196,0.3113,0},
            mSA=8,
            I_11=0.02,
            I_22=0.259,
            I_33=0.259,
            bias=0.03,
            c=58570,
            d=11650)  annotation (extent=[19,-9; 49,21]);
          WheelsAndTires.Tires.Slim.IdealTire idealTire(
            mRim=11.9,
            I_11=0.27,
            I_22=0,
            I_33=0.484,
            enforceStates=false,
            visContactPointEnabled=true,
            visForcesEnabled=true,
            rWheel=0.282,
            height=20e-3)
                         annotation (extent=[-98,-46; -58,-6]);
          WheelsAndTires.Tires.Slim.IdealTire idealTire1(
            I_11=0.383,
            I_22=0,
            I_33=0.638,
            mRim=14.7,
            enforceStates=false,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            phi_start={5*Modelica.Constants.pi/180,0,0},
            w_start=vs*{0,0,1/0.297},
            visContactPointEnabled=true,
            visForcesEnabled=true,
            rWheel=0.297,
            height=20e-3) annotation (extent=[98,-46; 58,-6]);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.LiftForce liftForce(
            CL=0.078,
            fA=0.65,
            rho=1.225) annotation (extent=[-52,-52; -32,-32]);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.DragForce dragForce(
            CD=0.48,
            fA=0.65,
            rho=1.225) annotation (extent=[-52,-74; -32,-54]);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.PitchingMoment
            pitchingMoment(
            CP=0.189,
            fA=0.65,
            rho=1.225,
            w=1.41) annotation (extent=[-52,-96; -32,-76]);
          Modelica.Blocks.Sources.Constant const(k=0)
            annotation (extent=[-96,-74; -76,-54]);
          Modelica.Blocks.Interfaces.RealInput RiderTorque
            "this input is needed for controller design"
            annotation (extent=[-134,51; -100,85], rotation=0);
          Modelica.Blocks.Interfaces.RealInput SteeringTorque
            "this input is needed for controller design"
            annotation (extent=[-134,19; -100,53], rotation=0);
          inner WheelsAndTires.Environment.Surface Surface(visSurface=false)
            annotation (extent=[-64,76; -44,96]);
        equation
          connect(FrontFrame.SteeringAxis, RearFrame.SteeringAxis)
            annotation (points=[-44,41; -41.5,41],
                                                 style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Rider.RearFrame, RearFrame.RiderUpperBody) annotation (points=[-11.7,
                38.84; -11.7,28.42; -11.5,28.42; -11.5,27],    style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RearFrame.SwingingArm, SwingingArm.RearFrameCon1) annotation (
             points=[14.5,6; 15.7,6; 15.7,6; 16.9,6],
                                       style(
              color=0,
              rgbcolor={0,0,0},
              pattern=0,
              thickness=2,
              fillColor=10,
              rgbfillColor={135,135,135},
              fillPattern=1));
          connect(pitchingMoment.frame_a, RearFrame.CoM) annotation (points=[-32,-86;
                -4,-86; -4,15],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(liftForce.frame_a, RearFrame.Aerodynamics_CoP) annotation (
              points=[-32,-42; -21.5,-42; -21.5,21], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(dragForce.frame_a, RearFrame.Aerodynamics_CoP) annotation (
              points=[-32,-64; -21.5,-64; -21.5,21], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(const.y,liftForce. v) annotation (points=[-75,-64; -64,-64;
                -64,-42; -54,-42], style(color=74, rgbcolor={0,0,127}));
          connect(const.y,pitchingMoment. v) annotation (points=[-75,-64; -64,
                -64; -64,-86; -54,-86], style(color=74, rgbcolor={0,0,127}));
          connect(const.y,dragForce. v) annotation (points=[-75,-64; -54,-64],
              style(color=74, rgbcolor={0,0,127}));
          connect(RiderTorque, Rider.T_RiderLean) annotation (points=[-117,68;
                10,68; 10,52; 1.43,52], style(color=74, rgbcolor={0,0,127}));
          connect(SteeringTorque, FrontFrame.T_Steering) annotation (points=[-117,36;
                -90,36; -90,58; -54,58; -54,52],          style(color=74,
                rgbcolor={0,0,127}));
          connect(idealTire.TireHub, FrontFrame.RevoltueAxis) annotation (
              points=[-58,-26; -54,-26; -54,13], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(idealTire1.TireHub, SwingingArm.RearWheel) annotation (points=[58,-26;
                54,-26; 54,6; 51.1,6],         style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
        end Suzuki_GSX_R1000_AndresTires;

        model Suzuki_GSX_R1000_test
          "Motorcycle Model based on Sharp's improved motorcycle model"
          import MotorcycleLib;
          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 10;
          MotorcycleLib.AdvancedMotorcycle.Parts.RearFrame RearFrame(
            enforceStates=true,
            p11={0.549,0.3608,0},
            R_rw=0.297,
            p2={1.173,0.749,0},
            p8={0.6779,0.4724,0},
            p9={0.364,0.8438,0},
            I_11=11.085,
            I_22=14.982,
            I_33=22.013,
            I_21=-3.691,
            m=165.13,
            p1={1.41/2,0,0})
                       annotation (extent=[-39,-6; 21,44]);
          annotation (Diagram,
            experiment(StopTime=10, Algorithm="Dassl"),
            experimentSetupOutput,
            Icon(
              Ellipse(extent=[-40,-60; -100,0], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[100,-60; 40,0], style(color=0, rgbcolor={0,0,0})),
              Line(points=[-70,-30; -40,60; -20,60; -20,60], style(color=0,
                    rgbcolor={0,0,0})),
              Line(points=[70,-30; 28,-30; -10,-30; -46,40; 20,20; 32,-30], style(
                    color=0, rgbcolor={0,0,0})),
              Line(points=[20,20; 80,40], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[-65,-35; -75,-25], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[75,-35; 65,-25], style(color=0, rgbcolor={0,0,0}))));

          MotorcycleLib.IdealWheels.Wheel RearWheel(
            I_22=0,
            animation=true,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            enforceStates=false,
            r=0.297,
            m=14.7,
            I_11=0.383,
            I_33=0.638,
            phi_start={0,5,0},
            w_start=vs*{0,0,1/0.297*180/Modelica.Constants.pi})
                                annotation (extent=[90,-30; 70,-10]);
          MotorcycleLib.IdealWheels.WheelJoint FrontWheel(r=0.282)
            annotation (extent=[-90,-30; -70,-10]);
          MultiBondLib.Mechanics3D.Parts.SimpleBody simpleBody(
            animation=false,
            I_22=0,
            m=11.9,
            I_11=0.27,
            I_33=0.484)
                       annotation (extent=[-50,-30; -30,-10]);
          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[60,40; 80,
                60]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RiderUpperBody Rider(
            I_11=1.3,
            I_22=1.4,
            I_33=2.1,
            I_21=0.3,
            phi_start=0,
            p9={0.364,0.8438,0},
            p10={0.415,1.14,0},
            m=44.5,
            c=380,
            d=34) annotation (extent=[-26,34; 0,62]);
          MotorcycleLib.AdvancedMotorcycle.Parts.SwingingArms.SwingingArm_Rocker
            SwingingArm(
            R_rw=0.297,
            p11={0.549,0.3608,0},
            p22={0.3722,0.2748,0},
            p20={0.4946,0.1522,0},
            p21={0.4443,0.1782,0},
            p19={0.539,0.1878,0},
            p13={0.487,0.4888,0},
            p14={0.196,0.3113,0},
            c=58570,
            d=11650,
            I_11=0.02,
            I_22=0.259,
            I_33=0.259,
            mSA=8,
            bias=0.01)
                      annotation (extent=[21,-11; 51,19]);
          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontFramePreload
            FrontFrame(
            mFS=17.5,
            mFF=13.1,
            ds=7.4,
            I_FS_11=0,
            I_FS_22=0,
            I_FS_33=0,
            init_steerAngle=0,
            R_fw=0.282,
            R_rw=0.297,
            w=1.41,
            epsilon=24,
            p2={1.173,0.749,0},
            p3={1.164,0.77,0},
            p4={1.342,0.426,0},
            p5={1.365,0.324,0},
            d=2134,
            I_FF_11=1.341,
            I_FF_22=0.4125,
            I_FF_33=1.584,
            offset=0.026553,
            ctw=100000,
            dtw=100,
            preload=882.1265,
            c=25000)     annotation (extent=[-80,11; -40,51]);
        equation
          connect(simpleBody.frame_a, FrontWheel.frame_b) annotation (points=[-51,-20;
                -69,-20],      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RearWheel.frame_b, SwingingArm.RearWheel) annotation (points=[69,-20;
                60,-20; 60,4; 53.1,4],             style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SwingingArm.RearFrameCon1, RearFrame.SwingingArm) annotation (
             points=[18.9,4; 16.7,4; 16.7,4; 14.5,4],
                                          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=10,
              rgbfillColor={135,135,135}));
          connect(Rider.RearFrame, RearFrame.RiderUpperBody) annotation (points=[-11.7,
                34.84; -11.7,33.42; -11.5,33.42; -11.5,25],      style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              gradient=2,
              fillColor=70,
              rgbfillColor={45,96,172}));
          connect(FrontFrame.SteeringAxis, RearFrame.SteeringAxis) annotation (
              points=[-50,39; -41.5,39], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=10,
              rgbfillColor={135,135,135},
              fillPattern=1));
          connect(FrontFrame.RevoltueAxis, FrontWheel.frame_b) annotation (
              points=[-60,11; -60,-20; -69,-20], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2,
              fillColor=10,
              rgbfillColor={135,135,135},
              fillPattern=1));
        end Suzuki_GSX_R1000_test;

        model Suzuki_GSX_R1000_AndresTires_compare
          "Motorcycle Model based on Sharp's improved motorcycle model"
          import MotorcycleLib;
          import SI = Modelica.SIunits;

          parameter SI.Velocity vs = 7;
          MotorcycleLib.AdvancedMotorcycle.Parts.RearFrame RearFrame(
            enforceStates=true,
            p11={0.549,0.3608,0},
            R_rw=0.297,
            p2={1.173,0.749,0},
            p8={0.6779,0.4724,0},
            p9={0.364,0.8438,0},
            m=165.13,
            I_11=11.085,
            I_22=14.982,
            I_33=22.013,
            I_21=-3.691,
            p1={0.77,0,0})
                       annotation (extent=[-39,74; 21,124]);
          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontFrameUSD
            FrontFrame(
            mFS=17.5,
            mFF=13.1,
            ds=7.4,
            I_FS_11=0,
            I_FS_22=0,
            I_FS_33=0,
            init_steerAngle=0,
            ctw=1e11,
            dtw=1e10,
            R_fw=0.282,
            R_rw=0.297,
            w=1.41,
            epsilon=24,
            p2={1.173,0.749,0},
            p3={1.164,0.77,0},
            p4={1.342,0.426,0},
            p5={1.365,0.324,0},
            c=25000,
            d=2134,
            I_FF_11=1.341,
            I_FF_22=0.4125,
            I_FF_33=1.584,
            offset=0.026553,
            bias=0.1)    annotation (extent=[-74,91; -34,131]);
          annotation (Diagram,
            experiment(StopTime=10, Algorithm="Dassl"),
            experimentSetupOutput,
            Icon(
              Ellipse(extent=[-40,-60; -100,0], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[100,-60; 40,0], style(color=0, rgbcolor={0,0,0})),
              Line(points=[-70,-30; -40,60; -20,60; -20,60], style(color=0,
                    rgbcolor={0,0,0})),
              Line(points=[70,-30; 28,-30; -10,-30; -46,40; 20,20; 32,-30], style(
                    color=0, rgbcolor={0,0,0})),
              Line(points=[20,20; 80,40], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[-65,-35; -75,-25], style(color=0, rgbcolor={0,0,0})),
              Ellipse(extent=[75,-35; 65,-25], style(color=0, rgbcolor={0,0,0}))),
            Coordsys(extent=[-100,-150; 100,150], scale=0.1));

          inner MultiBondLib.Mechanics3D.World3D world3D(
            g=9.81,
            n={0,-1,0},
            nominalLength=2)                     annotation (extent=[60,122; 80,
                142]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RiderUpperBody Rider(
            m=44.5,
            I_11=1.3,
            I_22=1.4,
            I_33=2.1,
            I_21=0.3,
            phi_start=0,
            p9={0.364,0.8438,0},
            p10={0.415,1.14,0},
            c=380,
            d=34) annotation (extent=[-26,118; 0,146]);
          MotorcycleLib.AdvancedMotorcycle.Parts.SwingingArms.SwingingArm_Rocker
            SwingingArm(
            R_rw=0.297,
            p11={0.549,0.3608,0},
            p22={0.3722,0.2748,0},
            p20={0.4946,0.1522,0},
            p21={0.4443,0.1782,0},
            p19={0.539,0.1878,0},
            p13={0.487,0.4888,0},
            p14={0.196,0.3113,0},
            c=58570,
            d=11650,
            mSA=8,
            I_11=0.02,
            I_22=0.259,
            I_33=0.259,
            bias=0.03)
                      annotation (extent=[19,69; 49,99]);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.LiftForce liftForce(
            CL=0.078,
            fA=0.65,
            rho=1.225) annotation (extent=[-52,6; -32,26]);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.DragForce dragForce(
            CD=0.48,
            fA=0.65,
            rho=1.225) annotation (extent=[-52,-16; -32,4]);
          MotorcycleLib.AdvancedMotorcycle.Aerodynamics.PitchingMoment
            pitchingMoment(
            CP=0.189,
            fA=0.65,
            rho=1.225,
            w=1.41) annotation (extent=[-52,-38; -32,-18]);
          Modelica.Blocks.Sources.Constant const(k=vs)
            annotation (extent=[-96,-16; -76,4]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RearFrame RearFrame1(
            enforceStates=true,
            p11={0.549,0.3608,0},
            R_rw=0.297,
            p2={1.173,0.749,0},
            p8={0.6779,0.4724,0},
            p9={0.364,0.8438,0},
            m=165.13,
            I_11=11.085,
            I_22=14.982,
            I_33=22.013,
            I_21=-3.691,
            p1={0.77,0,0})
                       annotation (extent=[-41,-108; 19,-58]);
          MotorcycleLib.AdvancedMotorcycle.Parts.FrontFrames.FrontFrameUSD
            FrontFrame1(
            mFS=17.5,
            mFF=13.1,
            ds=7.4,
            I_FS_11=0,
            I_FS_22=0,
            I_FS_33=0,
            init_steerAngle=0,
            ctw=1e11,
            dtw=1e10,
            R_fw=0.282,
            R_rw=0.297,
            w=1.41,
            epsilon=24,
            p2={1.173,0.749,0},
            p3={1.164,0.77,0},
            p4={1.342,0.426,0},
            p5={1.365,0.324,0},
            c=25000,
            d=2134,
            I_FF_11=1.341,
            I_FF_22=0.4125,
            I_FF_33=1.584,
            offset=0.026553,
            bias=0.1)    annotation (extent=[-76,-91; -36,-51]);
          MotorcycleLib.AdvancedMotorcycle.Parts.RiderUpperBody Rider1(
            m=44.5,
            I_11=1.3,
            I_22=1.4,
            I_33=2.1,
            I_21=0.3,
            phi_start=0,
            p9={0.364,0.8438,0},
            p10={0.415,1.14,0},
            c=380,
            d=34) annotation (extent=[-28,-66; -2,-38]);
          MotorcycleLib.AdvancedMotorcycle.Parts.SwingingArms.SwingingArm_Rocker
            SwingingArm1(
            R_rw=0.297,
            p11={0.549,0.3608,0},
            p22={0.3722,0.2748,0},
            p20={0.4946,0.1522,0},
            p21={0.4443,0.1782,0},
            p19={0.539,0.1878,0},
            p13={0.487,0.4888,0},
            p14={0.196,0.3113,0},
            c=58570,
            d=11650,
            mSA=8,
            I_11=0.02,
            I_22=0.259,
            I_33=0.259,
            bias=0.03)
                      annotation (extent=[17,-113; 47,-83]);
          WheelsAndTires.Tires.Slim.IdealTire idealTire(
            mRim=11.9,
            I_11=0.27,
            I_22=0,
            I_33=0.484,
            enforceStates=false,
            visContactPointEnabled=true,
            visForcesEnabled=true,
            rWheel=0.282,
            height=20e-3)
                         annotation (extent=[-98,32; -58,72]);
          WheelsAndTires.Tires.Slim.IdealTire idealTire1(
            I_11=0.383,
            I_22=0,
            I_33=0.638,
            mRim=14.7,
            enforceStates=false,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            phi_start={5*Modelica.Constants.pi/180,0,0},
            w_start=vs*{0,0,1/0.297},
            visContactPointEnabled=true,
            visForcesEnabled=true,
            rWheel=0.297,
            height=20e-3) annotation (extent=[98,32; 58,72]);
          WheelsAndTires.Tires.Slim.IdealTire idealTire2(
            mRim=11.9,
            I_11=0.27,
            I_22=0,
            I_33=0.484,
            enforceStates=false,
            visContactPointEnabled=true,
            visForcesEnabled=true,
            rWheel=0.282,
            height=20e-3)
                         annotation (extent=[-102,-148; -62,-108]);
          WheelsAndTires.Tires.Slim.IdealTire idealTire3(
            I_11=0.383,
            I_22=0,
            I_33=0.638,
            mRim=14.7,
            enforceStates=false,
            initType=Modelica.Mechanics.MultiBody.Types.Init.PositionVelocity,
            phi_start={5*Modelica.Constants.pi/180,0,0},
            w_start=vs*{0,0,1/0.297},
            visContactPointEnabled=true,
            visForcesEnabled=true,
            rWheel=0.297,
            height=20e-3) annotation (extent=[98,-148; 58,-108]);
          inner WheelsAndTires.Environment.Surface Surface(visSurface=false)
            annotation (extent=[60,94; 80,114]);
        equation
          connect(FrontFrame.SteeringAxis, RearFrame.SteeringAxis)
            annotation (points=[-44,119; -41.5,119],
                                                 style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Rider.RearFrame, RearFrame.RiderUpperBody) annotation (points=[-11.7,
                118.84; -11.7,106.42; -11.5,106.42; -11.5,105],style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RearFrame.SwingingArm, SwingingArm.RearFrameCon1) annotation (
             points=[14.5,84; 16.9,84],style(
              color=0,
              rgbcolor={0,0,0},
              pattern=0,
              thickness=2,
              fillColor=10,
              rgbfillColor={135,135,135},
              fillPattern=1));
          connect(pitchingMoment.frame_a, RearFrame.CoM) annotation (points=[-32,-28;
                -4,-28; -4,93],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(liftForce.frame_a, RearFrame.Aerodynamics_CoP) annotation (
              points=[-32,16; -21.5,16; -21.5,99],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(dragForce.frame_a, RearFrame.Aerodynamics_CoP) annotation (
              points=[-32,-6; -21.5,-6; -21.5,99],   style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(const.y,liftForce. v) annotation (points=[-75,-6; -64,-6; -64,
                16; -54,16],       style(color=74, rgbcolor={0,0,127}));
          connect(const.y,pitchingMoment. v) annotation (points=[-75,-6; -64,-6;
                -64,-28; -54,-28],      style(color=74, rgbcolor={0,0,127}));
          connect(const.y,dragForce. v) annotation (points=[-75,-6; -54,-6],
              style(color=74, rgbcolor={0,0,127}));
          connect(FrontFrame1.SteeringAxis, RearFrame1.SteeringAxis)
            annotation (points=[-46,-63; -43.5,-63],
                                                 style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(Rider1.RearFrame, RearFrame1.RiderUpperBody)
                                                             annotation (points=[-13.7,
                -65.16; -13.7,-75.58; -13.5,-75.58; -13.5,-77],style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(RearFrame1.SwingingArm, SwingingArm1.RearFrameCon1)
                                                                    annotation (
             points=[12.5,-98; 14.9,-98],
                                       style(
              color=0,
              rgbcolor={0,0,0},
              pattern=0,
              thickness=2,
              fillColor=10,
              rgbfillColor={135,135,135},
              fillPattern=1));
          connect(idealTire2.TireHub, FrontFrame1.RevoltueAxis) annotation (
              points=[-62,-128; -56,-128; -56,-91], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(idealTire.TireHub, FrontFrame.RevoltueAxis) annotation (
              points=[-58,52; -54,52; -54,91], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(idealTire3.TireHub, SwingingArm1.RearWheel) annotation (
              points=[58,-128; 52,-128; 52,-98; 49.1,-98], style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
          connect(SwingingArm.RearWheel, idealTire1.TireHub) annotation (points=[51.1,84;
                54,84; 54,52; 58,52],          style(
              color=0,
              rgbcolor={0,0,0},
              thickness=2));
        end Suzuki_GSX_R1000_AndresTires_compare;
      end Sharp2004;
    end AdvancedMotorcycle;

  end Examples;
end MotorcycleLib;
